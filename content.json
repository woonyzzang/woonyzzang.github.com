{"meta":{"title":"J Dev","subtitle":"Web Development Story Blog","description":"FrontEnd Dev","author":"woonyzzang","url":"https://woonyzzang.github.com","root":"/"},"pages":[],"posts":[{"title":"Ubuntu OS Node Update","slug":"ubuntu-os-node-update","date":"2025-03-29T06:51:37.000Z","updated":"2025-03-29T07:17:46.266Z","comments":true,"path":"2025/03/29/ubuntu-os-node-update/","permalink":"https://woonyzzang.github.com/2025/03/29/ubuntu-os-node-update/","excerpt":"","text":"Ubuntu OS - Node 버전 업데이트기존 node 삭제1$ sudo apt remove nodejs Node 레파지토리 추가최신 LTS 버전의 Node.js 를 설치 하려면, 먼저 curl 명령어를 실행하여 NodeSource 저장소를 시스템에 추가해야 한다.다른 버전을 사용하려면 setup_22.x 에서 원하는 버전명으로 변경해서 사용한다. 1$ curl -fsSL https://deb.nodesource.com/setup_22.x | sudo -E bash - node 재설치1$ apt-get install nodejs","categories":[{"name":"OS","slug":"OS","permalink":"https://woonyzzang.github.com/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"https://woonyzzang.github.com/categories/OS/Linux/"},{"name":"Ubuntu","slug":"OS/Linux/Ubuntu","permalink":"https://woonyzzang.github.com/categories/OS/Linux/Ubuntu/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://woonyzzang.github.com/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://woonyzzang.github.com/tags/ubuntu/"}]},{"title":"Docker Harbor","slug":"docker-harbor","date":"2025-02-19T04:57:41.000Z","updated":"2025-03-29T07:17:46.252Z","comments":true,"path":"2025/02/19/docker-harbor/","permalink":"https://woonyzzang.github.com/2025/02/19/docker-harbor/","excerpt":"","text":"Harbor 란?Harbor 는 컨테이너 레지스트리 관리 플랫폼 이다. Docker 와 같은 컨테이너 이미지의 저장소를 관리하는 시스템으로, 특히 이미지 저장소와 보안 관리에 중점을 둔다. 개인 &#x2F; 기업용 프라이빗 레지스트리: Docker Hub 와 같은 공용 레지스트리 외에, 기업이나 팀에서는 자체적으로 Harbor 를 설치해 보안성과 제어권을 강화한 프라이빗 레지스트리를 운영할 수 있다. 호스트 서버 구축 Harbor: https://goharbor.io/ Harbor 설치 가이드: https://goharbor.io/docs/ Harbor 접속Harbor의 설치가 완료되면 접속 가능한 포털 주소와 관리자 계정이 제공된다.포털은 서버나 브라우저를 통해 접속할 수 있다 관리자 계정에는 생성된 모든 프로젝트 및 이미지에 대한 관리 권한이 존재한다.실제 개발 작업 시에는 각 사용자 계정을 등록하여 프로젝트와 이미지를 관리한다.admin 계정으로 로그인하면 아래와 같은 페이지가 나타난다. 프로젝트 관리Harbor 에서는 Registry 가 아닌 “Project” 라는 이름으로 정보 저장소를 제공한다. 프로젝트 만들기NEW PROJECT 버튼을 클릭하여 새 프로젝트를 만들 수 있다.프로젝트 생성 시, 공개 여부를 선택할 수 있다. 추후 프로젝트 페이지의 Configuration 탭에서 수정할 수 있다. 프로젝트 페이지생성된 프로젝트를 클릭하면 저장된 이미지의 목록을 보여주는 Repositories 탭을 비롯해 다양한 관리 탭이 존재한다. Harbor 사용 가이드Client 로 포털에 접속하여 도커 이미지를 업로드하고 다운로드 받을 수 있다. Harbor 로그인하버에 로그인하려면 아래 명령어를 사용하여 사용자 이름과 도메인을 입력한다. 패스워드를 입력하면 “Login Succeeded” 메시지가 출력된다. 1$ docker login -u [USER NAME] [DOMAIN NAME] Harbor 이미지 만들기도커 이미지 ID를 사용하여 이미지를 생성한다. 1$ docker tag [IMAGE ID] [DOMAIN NAME]/[PROJECT]/IMAGE[:TAG] Harbor 이미지 올리기도커 이미지를 하버에 푸시하려면 이미지 이름을 변경한 후 아래 명령어를 사용하여 이미지를 업로드 한다. 1$ docker push [DOMAIN NAME]/[PROJECT]/IMAGE[:TAG] 예시123456789101112131415// 도커 이미지 확인$ docker images// 도커 이미지 결과REPOSITORY TAG IMAGE ID CREATED SIZEtest-cass/cass v1.0 d5bf39116fca 25 minutes ago 1.71GBtest-cass/search v1.0 88f3db0c15ca 25 minutes ago 2.47GB// 하버 태그 등록$ docker tag d5bf39116fca harbor.example.co.kr/cass/cass:v1.0$ docker tag 88f3db0c15ca harbor.example.co.kr/cass/search:v1.0// 하버 이미지 푸시$ docker push harbor.example.co.kr/cass/cass:v1.0$ docker push harbor.example.co.kr/cass/search:v1.0 참조 https://velog.io/@tkfrn4799/harbor-private-docker-registry","categories":[{"name":"Server","slug":"Server","permalink":"https://woonyzzang.github.com/categories/Server/"},{"name":"Docker","slug":"Server/Docker","permalink":"https://woonyzzang.github.com/categories/Server/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://woonyzzang.github.com/tags/docker/"}]},{"title":"Docker Mac Apple Silicon","slug":"docker-mac-apple-silicon","date":"2024-12-31T06:22:59.000Z","updated":"2025-03-29T07:17:46.256Z","comments":true,"path":"2024/12/31/docker-mac-apple-silicon/","permalink":"https://woonyzzang.github.com/2024/12/31/docker-mac-apple-silicon/","excerpt":"","text":"Docker 맥 Apple Silicon (M1, M2) 실행 이슈 해결Apple Silicon 은 Apple 이 설계한 ARM 기반의 프로세서 이며, Intel의 x86 아키텍처를 대체하는 칩셋으로, Apple은 2020년 말에 출시된 특정 Mac 컴퓨터 모델부터 Intel 프로세서에서 Apple Silicon 으로 전환하기 시작하였는데 도커에서 실행 문제가 발생할 경우가 존재한다. 해결 방법 1docker-compose.yml 파일에 platform: linux/amd64 옵션 추가 123456version: &#x27;3.8&#x27;services: cass: image: cassandra:latest platform: linux/amd64 # ARM 기반에서 x86_64 (amd64) 아키텍처로 실행 추가 해결 방법 2Dockerfile 파일 첫번째 코드 라인 FROM 앞에 --platform=linux/amd64 옵션 추가 12FROM --platform=linux/amd64 node:20-slim...","categories":[{"name":"Server","slug":"Server","permalink":"https://woonyzzang.github.com/categories/Server/"},{"name":"Docker","slug":"Server/Docker","permalink":"https://woonyzzang.github.com/categories/Server/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://woonyzzang.github.com/tags/docker/"}]},{"title":"CQRS 패턴을 Redux 와 비교","slug":"redux-cqrs-pattern","date":"2024-06-03T08:50:37.000Z","updated":"2024-06-17T13:18:23.675Z","comments":true,"path":"2024/06/03/redux-cqrs-pattern/","permalink":"https://woonyzzang.github.com/2024/06/03/redux-cqrs-pattern/","excerpt":"","text":"CQRS 패턴을 Redux 와 비교CQRS 패턴과 Redux 패턴의 플로우를 비교해 보면 크게 다르지 않다라는걸 알 수 있다. CQRS Redux 커맨드 모델:Mutation(변이) 위한 Request (동작을 수행하고 상태 변경을 일으킴) 리덕스에서는 액션 디스패치 개념과 동일 (액션을 디스패치 하게 되다면 새로운 커맨드를 서브밋 하게 된다.) CQRS (Commands) 1234addPost(&#123; title: string, body: string&#125;); Redux (Action) 1234567const addPost = &#123; type: &#x27;ADD_POST&#x27;, payload: &#123; title: string, body: string &#125;&#125;; 쿼리 모델:실제 데이터를 fetch 를 하는 동작 리덕스에서는 셀렉터 역할과 동일 CQRS (Query) 1listPost(): Array&lt;Post&gt; Redux (Selector) 1const listPost = useSelector((state) =&gt; state.posts); 도메인 이벤트:변화를 일으키는 행위의 자체 리덕스에서는 액션과 동일하나 리듀서에서 처리된 이후의 이벤트라고 불릴 수 있다. CQRS (Domain Events) 12345678Event(&#123; type: PostAdded, data: &#123; id: string, title: string, body: string &#125;&#125;); Redux (Action) 1234567const addPost = &#123; type: &#x27;ADD_POST&#x27;, payload: &#123; title: string, body: string &#125;&#125;; 어그리게이션:DDD 에서 메인 패턴, 모델의 작은 조각을 표현 리덕스에서는 리듀서의 역할이라고 볼 수 있다. CQRS (Aggregate) 12345678910111213public abstact class Aggregate&#123; public Guid Id &#123; get; protected set; &#125; public void ApplyEvent(Event e) &#123; var eventType = e.GetType(); var handler = GetType() .GetMethod(“Apply”, new[] &#123;eventType&#125;); handler.Invoke(this, new object[] &#123;e&#125;); &#125; protected List&lt;Event&gt; NewEvents &#123; get; private set; &#125; public Event[] GetNewEvents() =&gt; NewEvents.ToArray();&#125; Redux (Reducer) 12345678910function reducer(state, action) &#123; switch (action.type) &#123; case &#x27;INCREMENT&#x27;: return state + 1; case &#x27;DECREMENT&#x27;: return state - 1; default: return state; &#125;&#125; 참조 https://www.youtube.com/watch?v=FeDBlSBPUz8","categories":[{"name":"Web","slug":"Web","permalink":"https://woonyzzang.github.com/categories/Web/"},{"name":"Architecture","slug":"Web/Architecture","permalink":"https://woonyzzang.github.com/categories/Web/Architecture/"}],"tags":[{"name":"architecture","slug":"architecture","permalink":"https://woonyzzang.github.com/tags/architecture/"},{"name":"ddd","slug":"ddd","permalink":"https://woonyzzang.github.com/tags/ddd/"},{"name":"cqrs","slug":"cqrs","permalink":"https://woonyzzang.github.com/tags/cqrs/"}]},{"title":"Frontend MVC 패턴","slug":"frontend-mvc-pattern","date":"2024-05-30T07:17:00.000Z","updated":"2024-06-07T09:27:28.301Z","comments":true,"path":"2024/05/30/frontend-mvc-pattern/","permalink":"https://woonyzzang.github.com/2024/05/30/frontend-mvc-pattern/","excerpt":"","text":"프론트엔드에서 MVC 패턴을 사용 안하는 이유프론트엔드에서 MVC 패턴을 대체하는 패턴들과 등장 배경 이유를 알아보자. 백엔드에서의 수행 절차 client 의 request 를 받는다. (브라우저 or 앱) request 를 분석한다. (라우팅) 필요한 데이터를 수집 &#x2F; 가공 한다. (데이터 베이스 조회) 뷰를 생성하고 response 한다. 플로우 컨트롤러 → 모델 → 뷰 → 컨트롤러가 이렇게 흐름상 하나의 흐름으로 이어진다고 볼 수 있다.이 결과 문제는 각각의 레이어들 사이에 강한 의존성이 생기는 문제가 존재 한다. 그래서 이부분에 대해 실제 MVC 에서는 동작은 아래와 같이 진행된다. 이런식으로 Controller 가 Model 을 통해서 데이터를 수집하고, 가공하는걸 부탁해서 받아온 다음에 그 Model 정보를 다시 View 에 전달을 해준다. 물론 View 에 전달을 할 때 Model 객체를 넣어주는 경우도 있다. 들여다 보면 model 과 View 간에 어느 정도 의존성을 완전히 없애지는 못하지만 중간계층에 컨트롤러가 많은 역할을 해서 Model 과 View 컨트롤을 많이 하는 경우가 있다. Controller 예) 123model = new Model();view = new View(model);view.makeHTML(); 이렇게 백엔드에서는 MVC 패턴이 굉장히 유용한데, 프론트엔드 에서도 소프트웨어 개발 관점에서 이걸 그대로 쓸 수 있지 않을까? 란 생각을 하게 된다. 프론트엔드 SPA 개발 관점으로 보면 아래와 같을 것이다. SPA 에서는 URL 이 여러 개가 존재할 수가 있다. URL 이 존재하는데 페이지는 전환이 되지 않고 컨텐츠 내용만 업데이트 되는 형식이다. 서버에서 리퀘스트 정보를 받아서 처리하는 컨트롤러를 생각해보면 그거와 굉장히 유사한 일을 클라이언트에서도 한다고 볼 수 있다. 그래서 URL 을 분석하는 일들을 좀 할 수가 있다. 사용자가 입력한 URL 분석을 해서 그거에 따라서 어느 부분을 렌더링 해주는 역할을 할 수가 있다.이것만 봐서는 백엔드의 처리와 거의 비슷한 역할을 프론트엔드 에서도 한다는 걸을 알 수가 있고그러다 보면 MVC 를 쉽게 적용해서 그래로 활용할 수 있을 것이라고 생각을 할 수가 있다. 하지만 현실을 그렇지 않은 경우가 더 많다. View 단은 복잡하게 구성되어지게 되기 때문인데.. 10 년 훨씬 전부터 프론트엔드는 복잡한 View 가 많아졌다. 카카오 맵 구글 시트 포털 사이트 쇼핑 사이트 기타 등등 페이지 전환 없이 여러가지 렌더링 일을 하는 싱글 페이지 어플리케이션이 많아지고 있고, 이 부분은 당연히 기술이 발달함에 있어 브라우저에서 CSS, JS 로 이전 보다 표현 및 기능 들이 처리 가능해졌기 때문.. 다시 본론으로 와서 보면… 사실 프론트엔드는 그 자체가 View 이다. 그래서 사실은 MVC 같은 패턴이 필요한게 아니고, 그냥 View 대한 처리가 필요한 걸 수도 있다. 보통 백엔드 관점에서의 View 를 어떤식으로 얘기하는가를 보면 보통 MVC 에서는 View 는 만들어지는 결정체 일뿐… 컨트롤러가 입력을 받고 그 다음 모델에서 데이터를 조회&#x2F;가공하고 클라이언트에 줄 Response 할 View 를 만드는 것. 거기에 반해 프론트엔드의 View 는 아무래도 다르다. 다시 말하자면 프론트엔드에서의 View 는 온갖 이벤트가 발생한다. 즉, 백엔드 관점의 View 개념 처럼 가만히 있는 View 가 아니라, View 가 바로 메인이자 컨트롤러와 같은 일을 할 수 밖에 없는 상황이 생기게되는 것이다. 그러다보니 문제의 진입점이 굉장히 다양하게 되어 버린다. 실제로 View 에서 일어나는 일들을 살펴보면 이처럼 View 안에서 여러가지 일들이 있다. 이런 프론트엔드 특성을 Model 과 View 관계로 정리해 본다면 입력 값을 통해 Model 이 변경 된다. 이와 반대의 케이스의 경우도 있다. 모델의 변경, 즉 서버로 받은 데이터 또는 어떤 주기적으로 데이터를 생성하는 일이 생긴다거나 그럴 때 View 를 바꿔야 되는 경우도 있다. 그러면 결국 View 와 Model 이 양쪽으로 복잡한 관계가 될 거라는 예상을 할 수 있을 것이다. 이런걸 양방향 이라고 볼 수 있는데, 결국 이런 양방향의 문제가 프론트엔드에서는 상당히 복잡도를 올린다고 볼 수 있다.그리고 한가지 더 프론트엔드 상황을 보면 View 는 아주 많다는 것이다. View 를 하나만 만들 수도 있지만, 그렇게 되면 View 가 너무 커지게 되어 버린다.그래서 View 를 컴포넌트로 단위로 쪼개서 나누게 된다. 그러다 보면 View 와 Model 이 양방향으로 데이터를 교환하는 것이데… View 도 엄청 많고 또 흔한 경우는 아니지만 그에 따른 모델도 굉장히 다수의 모델이 존재할 수가 있게 되어 버린다. 그럼 어떻게 되는 것인가? 결국 서로 간에 의존성이 많아지게 되고 View 와 Model 간의 복잡도가 훨씬 더 올라가게 되어 버린다. View 하고 Model 중 어디서 어디로 호출 하는지 굉장히 혼란스럽게 된다. 더구나 Model, View 가 서로 엄청 호출한다. 그래서 강한 의존성도 생기게 되고… 이 문제를 해결하기 위해 당연히 MVC 에 Controller 역할을 하나 만들어 주면 되지 않을까 생각해 볼 수 있다. 하지만 Controller 는 복잡한 View 와 model 을 끌어 안고 있기 때문에 슈퍼 울트라 컨트롤러 같은 역할의 Controller 가 될 수 밖에 없는 것이다.컨트롤러가 굉장히 비대해지는… 여기서 또 하나의 프론트엔드의 View 특징을 알아본다면 View 는 계층적인 구조를 가지는게 필요하다. 컴포넌트로 잘게 쪼개서 나누었을때 View 는 어떻게 보면 결국 DOM 이란걸 브라우저에 렌더링 해서 표현하는 것이다. DOM 은 트리 구조로 되어 있다. 따라서 View 영역도 DOM 만큼 잘게 나누지는 않지만 어느 정도 트리 구조를 가지면서 이를 제어 해야 된다.왜냐하면 View 는 잦은 리렌더링으로 다시 렌더링 되는 경우가 많이 있기 때문이며, 이를 제어하기 위해서는 이 계층적인 것을 원래의 (DOM) 구조를 활용하면서 리렌더링을 최소화 해주는 그런 방법들을 찾아야 한다. 프론트엔드에서 가장 비싼 비용에 속한 부분 중 하나가 DOM 변경이 해당 되며 가장 느린 작업 이기 때문이다. 그렇기 때문에 하나의 큰 덩어리 구조가 아닌 어느정도 계층적인 구조를 만들어서 렌더링 효율성을 얻어야 되는 것이다. 정리 View 가 아주 많다 양방향 처리가 필요하다. 슈퍼 울트라 컨트롤러가 생긴다 View 간의 계층처리가 필요하다. 그래서 , 필요한 것은? 복잡한 View, Model 관계 단순화. View 계층 처리로 쉽고 효율적인 DOM 처리. 백엔드의 MVC 패턴으로 프론트엔드 적용해서 이와 같은 문제를 해결 할 수 있는가….결론적으로 적합 하지 않다고 볼 수 있다. 그렇기에 현재 프론트엔드에서 사용되는 주요 기술들은 데이터 바인딩 (렌더 자동화) MVVM 패턴 (Vue.js) Flux 아키텍처 (React.js) 등을 등장 되어 사용되며 앞서 설명했던 문제들을 잘 해결해 주고 있다. MVVM 패턴 Flux 패턴 이처럼 프론트엔드에서의 View 는 많은 특성이 있다. View 자체가 엄청 많고 그에 따른 인터렉션을 제어하는 이벤트들도 많다. 따라서 백엔드에서 사용하는 MVC 패턴보다 더 나은 선택이 필요하기 때문에 MVVM, Flux 등의 과 같은 패턴들을 채택하게 되어서 사용 되어지고 인기를 얻고 있는 이유 일 것 이다. 참조 https://www.youtube.com/watch?v=Y5vOfv67h8A","categories":[{"name":"Web","slug":"Web","permalink":"https://woonyzzang.github.com/categories/Web/"},{"name":"Architecture","slug":"Web/Architecture","permalink":"https://woonyzzang.github.com/categories/Web/Architecture/"}],"tags":[{"name":"architecture","slug":"architecture","permalink":"https://woonyzzang.github.com/tags/architecture/"},{"name":"mvc","slug":"mvc","permalink":"https://woonyzzang.github.com/tags/mvc/"},{"name":"mvvm","slug":"mvvm","permalink":"https://woonyzzang.github.com/tags/mvvm/"}]},{"title":"도메인 로직 이해","slug":"domain-logic","date":"2024-05-24T06:55:59.000Z","updated":"2024-06-07T09:27:28.298Z","comments":true,"path":"2024/05/24/domain-logic/","permalink":"https://woonyzzang.github.com/2024/05/24/domain-logic/","excerpt":"","text":"비즈니스 로직&#x2F;도메인 로직 이해개발 아키텍처에서 말하는 비즈니스 로직&#x2F;도메인 로직 이해를 하려면 도메인 로직인지 아닌지 판단 기준을 &quot;이 코드가 현실문제에 대한 의사 결정을 하고 있는가?&quot; 로 접근하면 개념을 이해하기가 쉬울 것이다. 개발하면서 자주 듣는 말… “비지니스 로직을 분리하세요.”“도메인 로직은 다른 계층에 의존해서는 안됩니다.” 도메인, 비지니스 이란 단어는 일반적인 일상에서의 이해하고 쓰는 개념으로 접근하면 도메인은 주소? 비지니스는 사업? 으로 풀이해서 접근 해볼 수 있는데, 소프트웨어 공학에서 사용하는 도메인, 비지니스란 용어의 개념은 조금 다르다. 소프트웨어가 풀고자 하는 ‘현실 세상의 문제’ 를 가르키는 말로 풀이 될 수 있다. 이 개념을 바탕으로 예를 들어 도메인이 무엇인가로 접근해본다면 [은행 앱] 아래 리스트는 은행 앱이라는 소프트웨어가 가지고 있는 도메인이라고 볼 수 있다. 이자율 잔액 출금 계좌 개설 계좌 해지 은행 앱이 해결하려는 현실의 문제는 고객의 금융업무를 처리해주는 것이기 때문이다. [틱톡] 아래 리스트는 틱톡 앱이라는 소프트웨어가 가지고 있는 도메인이라고 볼 수 있다. 영상 편집 제목 수정 댓글 조회 공유 다시 말해 이 코드는 도메인 로직 이다 또는 이 코드는 비지니스 로직이다 라고 할 때, 그 뜻은 이 코드가 현실 세상의 문제에 대해서 결정을 하고 있다라는 뜻 이다. 그럼 의문이 들 수 있는게 소프트웨어는 결국 다 현실의 문제를 해결하는거 아닌가? 라고 이렇게 생각할 수도 있다. 그치만 은행 앱이나 SMS 앱의 코드를 한 줄 한 줄 뜯어보게 되면 실제 현실 세계의 대한 결정 말고도 굉장히 많은 코드들을 써야 한다 라는 것을 알 수 있다. 데이터 베이스 연결하기 백엔드 서버에 API 호출하기 수많은 은행 고객 데이터를 효율적으로 적용하기 고화질 동영상을 캐싱해서 빠르게 로딩하기 화면이 밑에서 떠오르는 애니메이션 UI 추가하기 이런것들은 도메인 로직에 해당되지 않으며 어플리케이션 서비스 로직 (비지니스 로직) 이라고 볼 수 있다. 이 코드가 현실 세상의 문제에 대해서 결정하고 있는가로 접근해서 접근하고 있으면 도메인 로직에 해당 될 수 있는 거고 나머지들은 그 결정을 위한 입력값을 만들어 주거나 그 결정의 결과물을 보여주고 전파하는 코드인 거라고 보면 된다. 구체적인 예를 들어 모바일 송금 앱 이라는 서비스가 있다고 가정하고 아래 예시 중 어떤것이 도메인 로직이고 어떤것이 서비스 로직에 해당 될 수 있을까 판단해 보자. 123456789101112131415송금을 담당하는 코드를 생각해 보면 대략 6 가지 단계로 나눠 볼 수 있다.1. 계좌의 잔액이 충분한지 확인 한다. (도메인 로직) a. 송금이 가능한지에 대한 의사 결정하는 것2. 송금 버튼을 활성화하거나, 유효하지 않다면 에러 메시지를 띄운다. (서비스 로직) a. UI 로직에 해당.3. 사용자의 멤버십 등급에 맞춰서 송금 수수료를 계산 한다. (도메인 로직) a. 송금에 드는 비용을 수수료 정책이나 멤버십 정책에 따라서 결정하는 것4. 계산한 송금 수수료를 결제 하도록 회부 서비스에 요청 한다. (서비스 로직) a. 외부 서비스와의 네트워킹에 해당.5. 수수료와 송금액만큼 사용자의 잔액을 감소 시킨다. (도메인 로직) a. 사용자의 잔액에서 수수료와 송금액 만큼을 빼서 잔액을 감소 시킨다. b. 이제 송금 후 이제 얼마인지를 계산하는 것6. 사용자의 잔액을 **DB** 에 저장 한다. (서비스 로직) a. DB와 관련된 영속성 로직에 해당. 도메인 로직에 해당 되는 단계를 살펴보면…이 코드들은 송금이라는 현실 세계의 문제에 대한 의사 결정을 담당하고 있다. 서비스 로직에 해당 되는 단계를 살펴보면…도메인 로직이 의사결정을 할 수 있도록 입력을 제공하거나 그 결과를 외부 서비스, DB, UI 등에 업데이트 하는 역할을 맡는다. 실제로는 깔끔하게 구분되어 지지 않는 경우가 훨씬 더 많다. 어떤 코드를 봤는데 도메인 로직인지 서비스 로직인지 애매하면 대부분 그 둘이 섞여 있는 경우가 높을 것이다. 이럴 경우 함수로 명확하게 구분짓고 나누어서 해결 해 볼 수 있을 것이다. 이렇게 도메인 로직과 서비스 로직 이 둘을 구분 하게 되면 테스트를 해야 될 것과 안해야 될 것이 명확하게 분리 될 수 있어 테스트 가성비도 올라가게 된다. 그리고 결과적으로 개발자가 도메인 로직을 이해하기 쉬워지게 된다. 왜냐하면 UI, DB 같은 기술적인 구현사항에 신경쓰지 않고 현실 세계의 의사결정을 잘 반영하고 있는지 그 정책에 대해서만 이해를 할 수가 있다. 실제로 비지니스 정책이 변경되게 될 경우, 소프트웨어를 변경하고 기능을 추가하는 것도 굉장히 편해지게 된다. 도메인 로직과 서비스 로직의 구분은 결국 서비스 개발함에 있어 나쁜 아키텍처를 만들지 않기 위해서 꼭 필요한 내용 일 것이다. 그렇기에 이런 개념을 잘 잡고 가는게 좋다. 참고 https://enterprisecraftsmanship.com/posts/what-is-domain-logic/ https://www.youtube.com/watch?v=gbzDG_2XQYk","categories":[{"name":"Web","slug":"Web","permalink":"https://woonyzzang.github.com/categories/Web/"},{"name":"Architecture","slug":"Web/Architecture","permalink":"https://woonyzzang.github.com/categories/Web/Architecture/"}],"tags":[{"name":"architecture","slug":"architecture","permalink":"https://woonyzzang.github.com/tags/architecture/"},{"name":"ddd","slug":"ddd","permalink":"https://woonyzzang.github.com/tags/ddd/"}]},{"title":"Hybrid App 웹뷰 이슈 정리","slug":"hybrid-app-webview-issue","date":"2024-03-14T08:37:46.000Z","updated":"2024-06-10T04:53:59.789Z","comments":true,"path":"2024/03/14/hybrid-app-webview-issue/","permalink":"https://woonyzzang.github.com/2024/03/14/hybrid-app-webview-issue/","excerpt":"","text":"하이브리드 앱 이슈 &#x2F; 해결 정리하이브리드 앱 프로젝트 개발 진행 시 이슈 있었던 부분 요약 정리 네이티브 앱 개발 Ios: Swift 웹뷰 Android: Kotlin 웹뷰 1. QA 환경에서 로그인 시 간헐적으로 정상 로그인이 안되는 현상 웹 브라우저 시뮬레이터 (웹뷰) 안드로이드 디바이스 아이폰 디바이스 이슈 없음 이슈 없음 이슈 발생 이슈 발생 [이슈]: 와이파이 zempot-office 설정 후 디바이스에서 로그인 하면 간헐적 발생 [해결]: Dev 환경은 문제 없는데 QA 환경에서 부터 발생한 현상으로,로그 창을 띄어 확인 결과 프론트도어 교체 되면서 발생하는 WAF 이슈로 인한 문제로 인프라 팀에 문의해서 해결! 2. 네이티브 API 와 자바스크립트 연동 시 인식 못하는 현상 웹 브라우저 시뮬레이터 (웹뷰) 안드로이드 디바이스 아이폰 디바이스 이슈 없음 이슈 없음 이슈 발생 이슈 발생 [이슈]: 네이티브단과 API 연동해서 FCM 토큰 획득 후 관련 해당 로직이 실행 되어야 하는데 예외문 로직 플로우로 진행 됨. [해결]: 웹뷰 진입 시점에서 바로 FCM 토큰 API 사용하여 가져오기를 호출하면 값을 인식 못하는 현상으로,요청 시점을 클라이언트에서 바로 호출 하지 말고 DOM 로드 완료 후인 시점에서 사용하게 해서 해결! 3. 로그아웃 후 앱 실행 시 로그인이 자동으로 유지되어 되어 지는 현상 웹 브라우저 시뮬레이터 (웹뷰) 안드로이드 디바이스 아이폰 디바이스 이슈 없음 이슈 없음 이슈 발생 이슈 없음 [이슈]: 로그아웃 후 앱 재실행 시 자동 로그인 기능이 유지되는 현상 [해결]: 안드로이드는 기본적으로 웹뷰의 RAM과 영구 저장소 사이에 쿠키가 동기화가 안되는 현상으로,네이티브단 특정 라이프사이클 onStop 시점에 flush 처리 로직을 추가하여 쿠키를 동기화 시켜 해결! 브라우저에서 쿠키를 사용하려면 웹뷰 개발 시 안드로이드 쿠키 동기화 셋팅 필수 [참고]: 안드로이드 웹뷰를 사용 시 인앱 클라이언트와 쿠키 동기화 안되는 이슈 안드로이드 웹뷰 CookieSyncManager 정확한 사용법 4. KG 모빌리언스 PG4 휴대폰 본인 인증 PASS 앱 연동 웹 브라우저 시뮬레이터 (웹뷰) 안드로이드 디바이스 아이폰 디바이스 확인 불가 이슈 발생 이슈 발생 이슈 발생 [이슈]: 회원가입 PASS 인증 시도 오류 [해결]: 네이티브에서 앱 스킴 등록이 안되서 휴대폰 본인 인증 &gt; pass 앱을 인증 시 연동 안되는 현상으로,안드로이드, 아이폰 네이티브에서 pass 앱 스킴 등록 후 네이티브단 웹뷰에서 url 변경 될 때 마다 감지하는 라이프 사이클의 콜백함수 매개변수 url 이 앱 스킴 URL 인지 판별 후 앱을 실행 또는 스토어&#x2F;마켓 으로 리다이렉트 시키는 로직을 추가하여 해결! [참고]: 웹뷰(WebView) 연동하기 | 토스페이먼츠 개발자센터 5. 웹뷰에서 자바스트립트 클립보드 복사 안되는 현상 웹 브라우저 시뮬레이터 (웹뷰) 안드로이드 디바이스 아이폰 디바이스 이슈 없음 AOS 이슈 발생 이슈 발생 이슈 없음 [이슈]: 자바스크립트로 클립보드 기능 구현 시 웹에서는 이슈 없으나 안드로이드 웹뷰 안에서 에러 발생1window.navigator.clipboard.writeText(&#x27;텍스트&#x27;); [해결]: 해당 이슈로 검색하면 일부 네이티브 안드로이드단에서 android.permission.WRITE_EXTERNAL_STORAGE 퍼미션 추가 설정하면 해결 될 수 있다고 나와 있는데, 실제 확인해 본 결과 이슈가 해결 되진 않았음.Clipboard API 미지원 브라우저일 경우 분기 처리로 레거시 클립보드 기능 구현하여 해결! (안드로이드 네이티브와 통신해서 실제 네이티브 클립보드로 저장하는 방향도 있었지만, 그렇게 되면 아이폰과 저장 기능 주체가 다르게 관리되는 부분과 굳이 이런 부분들로 되도록 네이티브로 해결하고 싶지 않아서 웹기술로 구현) [참고]: 모바일 웹 URL 복사 기능 구현하기 6. 웹뷰에서 새창 페이지 안열리는 현상 웹 브라우저 시뮬레이터 (웹뷰) 안드로이드 디바이스 아이폰 디바이스 이슈 없음 이슈 발생 이슈 발생 이슈 발생 [이슈]: 웹뷰에서 새창 페이지 안열리는 이슈 a 태그 속성 target&#x3D;”_blank” 이나 자바스크립트로 window.open 으로 새창 페이지 구현 시 동작 반응이 없음.1&lt;a href=&quot;https://m.naver.com&quot; target=&quot;_blank&quot;&gt;네이버&lt;/a&gt; 1window.open(&#x27;https://m.naver.com&#x27;); [해결]:네이티브 단에서 처리 해결! [참고 ios] WKWebView and window.open Why is WKWebView not opening links with target&#x3D;”_blank”? webView(_:createWebViewWith:for:windowFeatures:) | Apple Developer Documentation 네이티브에서는 새창이란 개념이 아래 2 가지 케이스가 있는거 같다. webview 위에 신규 webview 호출 webview 에서 콜백을 받아 서로 통신이나 제어가 필요 할 사용 webview 에서 외부 브라우저 호출 통신 없이 별도 독립적인 네이티브 OS 브라우저 기본 브라우저 필요할 경우 사용 아이폰은 safari, 안드로이드는 기본이 삼성 (크롬 추가 설치 되어 있으면 선택할 수있는 OS UI 노출)","categories":[{"name":"App","slug":"App","permalink":"https://woonyzzang.github.com/categories/App/"},{"name":"Hybrid","slug":"App/Hybrid","permalink":"https://woonyzzang.github.com/categories/App/Hybrid/"}],"tags":[{"name":"hybridApp","slug":"hybridApp","permalink":"https://woonyzzang.github.com/tags/hybridApp/"}]},{"title":"Hybrid App 로컬 환경 셋팅","slug":"hybrid-app-local-setting","date":"2024-02-24T07:44:57.000Z","updated":"2024-06-07T09:27:28.307Z","comments":true,"path":"2024/02/24/hybrid-app-local-setting/","permalink":"https://woonyzzang.github.com/2024/02/24/hybrid-app-local-setting/","excerpt":"","text":"[KSOP App] 하이브리드 앱 셋팅네이티브 앱 개발 Ios: Swift 웹뷰 Android: Kotlin 웹뷰 SSL 네이티브 &lt;-&gt; 자바스크립트 연동 커스텀 유저 에이전트 테스트 구현은 네이티브 웹뷰가 아닌 다른 언어의 크로스 플랫폼 프레임워크의 flutter 웹뷰와 연동하여 목업 테스트한 결과를 바탕으로 작성되었기에 네이티브단에서 제공하는 웹뷰와 다소 차이가 있을 수 있음. ![ 로컬환경 ] 개발 시 네이티브 개발 요청 체크 리스트 로컬서버 환경 셋팅 접속 가능한 아이폰, 안드로이드 환경 필요 플랫폼팀에서 url 입력 가능하게 입력 컨트롤 UI 노출 (입력 컨트롤 값으로 웹뷰 url 로드) 해서 전달해준다고 협의 아이폰&#x2F;안드로이드 디바이스 시뮬레이터에서 host 셋팅한 도메인 접근 확인 필요 (웹뷰 url 접근 시 hosts 정의한 도메인 붙을 수 있는지…) 아이폰 시뮬레이터 안드로이드 시뮬레이터 로컬 host 접근 가능 로컬 host 접근 불가 아이폰 시뮬레이터: 별도의 hosts 셋팅이 필요 없이 접근 가능. 안드로이드 시뮬레이터: 아래와 같이 별도의 hosts 셋팅 필요함. 참고: How to edit android emulator hosts file (안드로이드 에뮬레이터 호스트 파일 수정)123456789101112131. AndroidSDK 내에 tools 폴더로 이동 후 아래 커맨드 입력 (KSOP는 Avd 설정의 Adv Name) a. ./emulator -avd KSOP -writable-system2. platform-tools 폴더로 이동 후 ./adb devices 커맨드 입력 해 emulator 이름 확인 후 예) List of devices attached emulator-5554 offline emulator-5556 device3. ./adb -s emulator-5556 remount4. ./adb -s emulator-5556 pull ./system/etc/hosts pull 받을폴더위치 받은 hosts 수정 예) 127.0.0.1 localhost 10.0.2.2 tapp.ksop.net // 추가 (아이피 변경 x)5. ./adb -s emulator-5556 push C:\\Android\\hosts ./system/etc/hosts // 호스트 파일 push 네이티브단 제스처 활성화 시 웹뷰에서 띄어질 웹사이트 body 스크롤 인식 할 수 있는 별도 옵션이 별도로 있다면 해제 네이티브단 웹뷰 설정에 SSL 해제 옵션이 별도로 있는 경우 옵션 해제 (SSL 인증 무효화) 네이티브 웹뷰안에 띄어질 웹사이트는 보안 프로토콜 + 도메인 기반으로 셋팅 되어 있음. (https://tapp.ksop.net:3000 으로 접근) [ios] 경우 xcode &gt; 빌드 시 info.plist 옵션 활성화12345678&lt;dict&gt; ... &lt;key&gt;NSAppTransportSecurity&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt;&lt;/dict&gt; [ios] Swift 네이티브인 경우 SafeArea 설정 활성화 필요 UIDelegate 연동 활성화 필요 휴대폰 본인인증 페이지 경우 도메인이 PG4쪽 이기 때문에 이전페이지로 이동할 수 있는 기능이 없는 이슈 안드로이드는 물리 백버튼이 있어서 가능하나 아이폰은 물리 버튼이 없어 이동 불가 플랫폼팀에서 네이티브 제스처 기능으로 대체하기로 협의 단, 웹뷰 안에 웹사이트에서 스와이프 기능이 있을 시 네이티브단 제스처 기능과 충돌하는지 확인 필요. i. 1 번째 방안: 네이티브 웹뷰와 웹사이트에서 자바스크립트 연동 기능으로 네이티브단 제스처 충돌 방지 처리 ii. 2 번째 방안: 네이티브 제스처가 헤더 UI 노출 웹뷰 안에 웹사이트 백버튼 ui는 삭제 검토 iii. 3 번째 방안: (권장) 네이티브 헤더 UI 를 동적으로 PG4 도메인일 경우에만 판단해서 노출 확인결과 : 이슈없음 (네이티브단 제스처 기능 충돌 안함)123456// 웹뷰안에 웹사이트 페이지 이동 후 로드 완료 시점 이벤트 판단 후...if (url.toString().startsWith(&#x27;https://auth.mobilians.co.kr/&#x27;)) &#123; // 네이티브 헤더 UI 노출&#125; else &#123; // 네이티브 헤더 UI 숨김&#125; 네이티브쪽과 웹뷰안에 웹 사이트 페이지 자바스크립트 연동 API 가이드 문서 필요 유니티 웹뷰가 아니라 스위프트&#x2F;코틀린 네이티브 웹뷰라 제공받을 API 가 다름. 프론트단에서 디바이스 구분해서 분기처리 호출 해야함. (Adapter Layer 에서 처리) API 문서: 네이티브 앱 &lt;-&gt; 자바스크립트 연동 가이드 FCM 토큰 가져오기 API (아이폰의 경우 시뮬레이터환경에서는 확인 불가능) 프론트개발 시 실제 디바이스에서 웹뷰 진입 시점인 create 에서 바로 FCM 토큰 가져오기를 호출하면 값을 인식 못하는 이슈가 존재하므로 요청 시점을 mounted 시점에서 사용해야 한다. 네이티브쪽에서 웹뷰쪽에 유저에이전트 특정 커스텀 값 전달 필요 (모바일웹으로 들어온 유저인지 인앱 으로 들어온 유저인지 판별 및 기타 사용) 유저에이전트 커스텀 문자 안드로이드의 경우 웹뷰 개발 시 쿠키 동기화 셋팅 필수 안드로이드 웹뷰 CookieSyncManager 정확한 사용법 웹뷰에서 링크 target&#x3D;”_blank”, 자바스크립트 window.open 새창 열림 기능 사용하려면 네이티브단 활성화 필요 Swift 네이티브: Delegate 연동 활성화 필요 Kotlin 네이티브: 연동 활성화 필요 [FCM 토큰 갱신 케이스] 앱이 Instance ID 를 삭제할때 앱이 새 기기에서 복구될때 유저가 앱을 지우거나&#x2F;다시 설치할때 유저가 앱 데이터를 초기화할때 FCM 푸시는 아이폰, 안드로이드 둘 다 백그라운드 상태에서만 동작한다고 함.","categories":[{"name":"App","slug":"App","permalink":"https://woonyzzang.github.com/categories/App/"},{"name":"Hybrid","slug":"App/Hybrid","permalink":"https://woonyzzang.github.com/categories/App/Hybrid/"}],"tags":[{"name":"hybridApp","slug":"hybridApp","permalink":"https://woonyzzang.github.com/tags/hybridApp/"}]},{"title":"Git 브랜치 종류","slug":"git-branch-type","date":"2024-01-24T04:20:33.000Z","updated":"2024-06-10T04:53:59.545Z","comments":true,"path":"2024/01/24/git-branch-type/","permalink":"https://woonyzzang.github.com/2024/01/24/git-branch-type/","excerpt":"","text":"보통 사용되는 브랜치 master/main: 항상 최신의 안정적인 프로그램 develop: 베타 버전&#x2F;모든 개발 로그들이 쌓이는곳, 새로운 feature 기능들이 완성되고 머지되는 곳 feature: 기능을 추가 할 때마다 따는 브랜치 test: 테스트 hotfix: 급한 수정 release: 배포할때 쓰는 테스트용 브렌치 커밋 메시지 표기 [Breaking]: 속보 [Deprecation]: 지원 중단 [Feature]: 추가 [Improvement]: 개선","categories":[{"name":"Tools","slug":"Tools","permalink":"https://woonyzzang.github.com/categories/Tools/"},{"name":"Git","slug":"Tools/Git","permalink":"https://woonyzzang.github.com/categories/Tools/Git/"}],"tags":[{"name":"architecture","slug":"architecture","permalink":"https://woonyzzang.github.com/tags/architecture/"},{"name":"git","slug":"git","permalink":"https://woonyzzang.github.com/tags/git/"}]},{"title":"ISO Simulator 개발환경 앱 설치","slug":"ios-simulator-app-install","date":"2023-12-14T08:23:04.000Z","updated":"2024-06-07T09:27:28.313Z","comments":true,"path":"2023/12/14/ios-simulator-app-install/","permalink":"https://woonyzzang.github.com/2023/12/14/ios-simulator-app-install/","excerpt":"","text":"IOS 아이폰 시뮬레이터용 빌드파일 app 설치xcode 빌드 후 아래 경로 찾아가보면 xxx.app 파일 존재하는데 드래그앤 드롭해서 시뮬레이터에 넣으면 자동 설치 됨. app 파일 위치 경로 1/사용자/&#123;Users&#125;/Library/Developer/Xcode/DerivedData/&#123;프로젝트&#125;/Build/Products/Debug-iphonesimulator","categories":[{"name":"App","slug":"App","permalink":"https://woonyzzang.github.com/categories/App/"},{"name":"IOS","slug":"App/IOS","permalink":"https://woonyzzang.github.com/categories/App/IOS/"}],"tags":[{"name":"simulator","slug":"simulator","permalink":"https://woonyzzang.github.com/tags/simulator/"}]},{"title":"Git Commit 컨벤션","slug":"git-commit-convention","date":"2023-10-16T03:01:39.000Z","updated":"2024-06-10T04:53:59.547Z","comments":true,"path":"2023/10/16/git-commit-convention/","permalink":"https://woonyzzang.github.com/2023/10/16/git-commit-convention/","excerpt":"","text":"Git Commit 컨벤션 ex) feat (변경할 파일) : 변경 내용 (&#x2F;#issue number) 커밋 메시지 규칙 feat: 새로운 기능 구현 fix: 버그, 오류 해결 chore: src 또는 test 파일을 수정하지 않은 기타 변경 사항 (새로운 파일 생성, 파일 이동, 이름 변경 등) refactor: 버그 수정이나 기능 추가가 없는 코드 변경 (코드 구조 변경 등의 리팩토링) style: 코드의 의미에 영향을 미치지 않는 변경 사항 (코드 형식, 세미클론 추가: 비지니스 로직에 변경 없음) build: 빌드 시스템 또는 외부의 영향을 미치는 변경 사항 종속성 (라이브러리 추가 등) pref: 성능을 향상 시키기 위한 코드 변경 test: 테스트 추가 또는 이전 테스트 수정 docs: README 나 WIKI 등의 문서 개정 revert: 이전 커밋을 되돌리는 경우 ci: CI 구성 파일 및 스크립트 변경 Merge: 다른 브랜치를 merge 하는 경우 Init: Initial commit 을 하는 경우 Git hooks 의 prepare-commit-msg 활용해서 아래 npm 모듈 연동해서 메시지 자동화 가능 npm 의존성 모듈 라이브러리 husky commitizen","categories":[{"name":"Tools","slug":"Tools","permalink":"https://woonyzzang.github.com/categories/Tools/"},{"name":"Git","slug":"Tools/Git","permalink":"https://woonyzzang.github.com/categories/Tools/Git/"}],"tags":[{"name":"architecture","slug":"architecture","permalink":"https://woonyzzang.github.com/tags/architecture/"},{"name":"git","slug":"git","permalink":"https://woonyzzang.github.com/tags/git/"}]},{"title":"GitHub 커밋 메세지에 JIRA 이슈번호 자동 연동","slug":"git-commit-message-jira-connect","date":"2023-09-20T03:12:10.000Z","updated":"2024-06-10T04:53:59.548Z","comments":true,"path":"2023/09/20/git-commit-message-jira-connect/","permalink":"https://woonyzzang.github.com/2023/09/20/git-commit-message-jira-connect/","excerpt":"","text":"커밋 시 항상 앞에 이슈번호를 넣어주어야 하는 번거로움을 자동으로 넣어주도록 처리하는 방법 .git/hooks 디렉토리에 prepare-commit-msg 파일을 생성하면 사용자가 커밋 메시지를 입력하기 전 단계에서 내용을 변경할 수 있다. prepare-commit-msg 파일 수정 위치: .git &gt; hooks &gt; prepare-commit-msg.sample 기본으로 확장자가 .sample 로 처리되어 있으며 사용하고 싶은 파일에 스크립트를 작성한뒤에 뒤의 확장자 제거 123456789101112131415161718192021#!/bin/bashif [ -z &quot;$BRANCHES_TO_SKIP&quot; ]; then BRANCHES_TO_SKIP=(master develop qa release hotfix)fiBRANCH_NAME=$(git symbolic-ref --short HEAD)BRANCH_PREFIX=&quot;$&#123;BRANCH_NAME%%/*&#125;&quot;BRANCH_JIRA=&quot;$&#123;BRANCH_NAME##*/&#125;&quot;BRANCH_PREFIX_PATTERN=&quot;^(issue|feature)$&quot;if [[ &quot;$BRANCH_PREFIX&quot; =~ $BRANCH_PREFIX_PATTERN ]]; then JIRA_KEY=&quot;$&#123;BRANCH_JIRA%%-*&#125;&quot; JIRA_ID=$(echo $BRANCH_JIRA | egrep -o &quot;$&#123;JIRA_KEY&#125;-[0-9]+&quot;) BRANCH_EXCLUDED=$(printf &quot;%s\\n&quot; &quot;$&#123;BRANCHES_TO_SKIP[@]&#125;&quot; | grep -c &quot;^$BRANCH_JIRA&quot;) BRANCH_IN_COMMIT=$(grep -c &quot;$JIRA_ID&quot; $1) if [ -n &quot;$JIRA_ID&quot; ] &amp;&amp; ! [[ $BRANCH_EXCLUDED -eq 1 ]] &amp;&amp; ! [[ $BRANCH_IN_COMMIT -ge 1 ]]; then sed -i.bak -e &quot;s/^\\(.*\\)$/* #$JIRA_ID - \\1/&quot; $1 fifi 플로우 브랜치 네이밍이 issue/&#123;이슈티켓&#125;, feature/&#123;이슈티켓&#125; 으로 시작하는 특정 브랜치인 경우에만 적용a. master, develop, qa, release, hotfix 인 브랜치 경우에는 적용 안되게 스킵 브랜치 이름으로부터 Jira 이슈 번호 가져오기a. 예를 들어 feature&#x2F;ESFH-1234-xxxx-yyyy 인경우 ESFH-1234 추출 커밋 메세지에 이미 Jira 이슈번호를 기재했다면 적용 안되게 스킵 위의 경우를 다 검증한뒤, 커밋메세지 앞에 Jira 이슈번호를 추가 [테스트] 지라이슈 브랜치 생성 feature&#x2F;ESFH-1 커밋 명령어 실행:1$ git commit -m “Core 초기 개발” 메시지 커밋 결과1* #ESFH-1 - Core 초기 개발 Hook 레파지토리 연동 (공통화) 기존 저장소에 한 번에 적용할 수 있는 스크립트를 만들어 커스텀 hook 을 공통으로 적용하고 싶은 프로젝트에 아래 터미널 명령어를 사용 (프로젝트 root 에서 커맨드 입력) Linux 12$ curl -L -H &quot;Authorization: token &lt;TOKEN&gt;&quot; https://api.github.com/repos/&lt;저장소 URL&gt;/tarball/master | tar -xzv --strip-components=1 \\ &amp;&amp; bash setup.sh Windows 12345Invoke-WebRequest -Uri &#x27;https://api.github.com/repos/&lt;저장소 URL&gt;/zipball/master&#x27; -Headers @&#123;Authorization=&#x27;token &lt;TOKEN&gt;&#x27;&#125; -OutFile &#x27;master.zip&#x27;;` Expand-Archive &#x27;master.zip&#x27; -DestinationPath &#x27;extended&#x27; -Force;` Get-ChildItem -Path &#x27;.\\extended\\*\\*&#x27; | Move-Item -Destination &#x27;.&#x27;;` Remove-Item &#x27;master.zip&#x27;, &#x27;.\\extended&#x27; -Recurse;` .\\setup.ps1 참조 https://medium.com/prnd/github-%EC%BB%A4%EB%B0%8B-%EB%A9%94%EC%84%B8%EC%A7%80%EC%97%90-jira-%EC%9D%B4%EC%8A%88%EB%B2%88%ED%98%B8-%EC%9E%90%EB%8F%99%EC%9C%BC%EB%A1%9C-%EB%84%A3%EC%96%B4%EC%A3%BC%EA%B8%B0-779048784037","categories":[{"name":"Tools","slug":"Tools","permalink":"https://woonyzzang.github.com/categories/Tools/"},{"name":"Git","slug":"Tools/Git","permalink":"https://woonyzzang.github.com/categories/Tools/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://woonyzzang.github.com/tags/git/"},{"name":"jira","slug":"jira","permalink":"https://woonyzzang.github.com/tags/jira/"}]},{"title":"PR 코드 리뷰","slug":"pr-code-review","date":"2023-08-22T04:25:17.000Z","updated":"2024-06-14T10:41:36.583Z","comments":true,"path":"2023/08/22/pr-code-review/","permalink":"https://woonyzzang.github.com/2023/08/22/pr-code-review/","excerpt":"","text":"코드 리뷰의 포인트 작성자 리뷰어 빠르게 개발해서 배포하는게 목적… 코드 꼼꼼히 리뷰 해서 회사의 팀의 리스크를 줄이는 목적… 1차 리뷰어: 코드 담당자에게 할당2차 리뷰어: 신입 개발자에게 할당 - [작성자 Tip] 리뷰어의 좋은 의도를 생각해야 하며, 코드를 감정적으로 받아들면 안된다.a. 동료, 후임에게 지적 받는 것 같은 불편함과 자존심 상하는 마인드의 개발자는 성장하기 힘들다.. 동일한 코멘트를 받지 않도록 숙지하고 개선해서 앞으로 코드를 만들어 나간다. 경력에 상관없이 배울 점이 있다면 수긍하고 받아 들이는 마인드를 가져라. PR 사이즈를 최대한 작게해서 요청 (코드 변경을 작게…)a. 코드 크기가 크면 코드 리뷰도 느리고 피드백 반영도 느려진다.b. 가급적 PR에 400줄 이하로 요청하는것이 좋다.c. 버그 하나당 하나의 PR 요청 권장.d. 버전 업데이트 및 리팩토링은 별도의 PR 요청 권장.e. 규모가 큰 변경 사항은 의미 있는 작은 단위로 요청 권장. 리뷰어가 빠르게 이해할 수 있도록 맥락(Context)를 이해할 수 있도록 정보 제공한다. 즉, PR 설명란에 코드가 뭘 하는지 설명하기 보다는 왜 이런 선택을 했는지에 대한 내용을 기재하는 것이 좋다.a. (Why &gt; What) [맥락(Context)를 이해할 수 있도록 정보 제공 - PR 요청 시 설명란 샘플] What? - 이 PR 이 무엇인지? Why? - 어떤 티켓을 배수를 하는지? 왜 필요한지? How? - 어떻게 구현 했는지? Testing? - 어떻게 테스트 할 수 있는지? Screenshots (optional) - 이해하기 위한 스크린샷… Anything Else? - 어떻게 재현할 수 있는지? 빠른 시일 내에 리뷰를 받을 수 있도록 최선을 다한다.a. 리뷰어가 휴가가 있는지 일정이 바쁜지 체크 후 리뷰 요청을 언제까지 해달라고 요청… 리뷰어의 코멘트에 대한 부분에 확실한 답변을 기재한다.a. ex) 네, 반영 햇습니다. 접두사 축약어 의미 설명 ACK Acknowledge 인정한다.반영 완료 했다 [리뷰어 Tip] 꼼꼼하게 확인 (팀의 리스크를 줄이기)a. 누락된 기능 (케이스) 조기 발견b. 버그 및 실수 조기 발견c. 테스트 코드의 작성 여부d. 코드 컨벤션이 잘 지켜졌는지 확인e. 가독성과 확장성 및 유지보수 편의성f. 팀원들의 이해도 향상g. 코드 퀄리티 향상 컨벤션에 관한 리뷰는 자동화 한다.a. (테스트 커버리지, ESLint, Formatter, Team’s Convension)b. 기본적인 것들은 자동화 하고 리뷰어는 근본적인 코드 코어에 집중한다. 좋은 의도를 전제로, 친절하게 설명한다.a. 비판보다는 호기심을 가지고 작성자의 코드 의도를 파악 명확하고 구체적인 피드백 주기a. 이유와 다른 대안 &#x2F; 추천하는 방법을 제안 중요성에 따라 명확한 행동을 촉구 접두사 축약어 의미 설명 QQ Quick Question 질문 요청 NIT Nitpicking 마이너 요청 (옵션 사항) RC Request For Change 필수 수정 요청 리뷰 완료를 명확하게 작성자에게 알려라.a. 승인 | 반려 | 질문 등등…b. 리뷰 처리를 하면 자동으로 메일로 가겠지만 확실하게 메신저로 한번 더 정확히 알려주는게 좋다.","categories":[{"name":"Tools","slug":"Tools","permalink":"https://woonyzzang.github.com/categories/Tools/"},{"name":"Git","slug":"Tools/Git","permalink":"https://woonyzzang.github.com/categories/Tools/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://woonyzzang.github.com/tags/git/"},{"name":"pr","slug":"pr","permalink":"https://woonyzzang.github.com/tags/pr/"}]},{"title":"Docker 로컬 개발환경 테스트","slug":"docker-local-development-test","date":"2023-08-22T02:26:25.000Z","updated":"2024-06-10T04:53:59.544Z","comments":true,"path":"2023/08/22/docker-local-development-test/","permalink":"https://woonyzzang.github.com/2023/08/22/docker-local-development-test/","excerpt":"","text":"Service Development Team 기술 스펙 구성 도커를 활용해 기술 스펙 환경을 패키징 해서 로컬 환경에서 테스트 확인… SPA + API 조합 시 프론트 서버와 백엔드 서버가 분리 되어 있는 구조 이기에 서로 연동된 목업 구현이나 테스트 확인 필요 시 DevOps 를 통해 각자 배포 후 확인 해야 하는 프로세스 플로우를 간소화 할 수 있다. Docker 개발 환경 구성 프록시 서버: Nginx 프론트 서버: Nuxt2 API 서버: .Net6 Docker 시스템 구성도 [TODO] Docker + Docker Compose [v] Docker 환경 구성 셋팅 [v] 네트워크 구성 셋팅 [v] 고정 IP 할당 셋팅 [v] 볼륨 구성 셋팅 [v] 쉘 스크립트 구성 셋팅 [v] Windows 환경 [v] Linux 환경 [v] Docker Compose 환경 구성 셋팅 [v] 네트워크 연동 [v] 볼륨 마운트 연동 [v] 환경 변수 연동 [v] [Nginx] 프록시 서버 환경 구성 셋팅 [v] 포트 포워딩 셋팅 [v] SSL 인증서 셋팅 [v] 인증서 자동 갱신 셋팅 [v] [Nuxt2] 프론트 서버 환경 구성 셋팅 [v] Hot Reload 셋팅 [v] 기본 테스트 구조 환경 셋팅 [v] .Net 기본 템플릿 view (html, css, js) 적용 [v] [.Net6] API 서버 환경 구성 셋팅 [-] Hot Reload 셋팅 [-] 기본 테스트 구조 환경 셋팅 프론트, 백엔드 분리되어 있는 디펙토리에서 작업하고 저장소 레파지토리를 서로 공유한 방식의 도커를 활용할 수도 있지만, 페어 프로그래밍 기능을 사용하면 서로 분업화된 공유 방식이 아닌 동시 협업이 가능하게 활용 할 수 있다. 페어 프로그래밍 (동시 편집) Visual Studio Live Share: 실시간 코드 공동 작업 도구 IDE Session Link Share OS 호환 Intellij Intellij or 클라이언트 앱 다운로드&#x2F;설치 후 접속 가능 O Visual Studio Code VSC or 웹 선택 접속 가능 O Visual Studio VS or VSC or 웹 선택 접속 가능 △ (Mac OS 인 경우 VS 미지원) Session Link Share 모드 선택하면 이 후에도 자동으로 계속 해당 모드로 접속하게 되는데 초기화 하려면 브라우저 캐시 삭제 후 다시 접속하면 모드 선택 가능 Setting Guide Git Repository: 비공개 스캐폴딩 구조 1234|- [backend] # .Net6|- [frontend] # Nuxt2|- [proxy] # Nginx|- [scripts] # 쉘 스크립트 Rancher Desktop 오픈소스 앱 다운로드: Rancher Desktop 윈도우 OS 경우 사전에 WSL2 환경 구성 설치가 되어 있어야 한다. Rancher Desktop 설치 후 설정 패널에서 Cotainer Engine &gt; dockerd (moby) 로 적용해줘야 Docker 기본 커맨드 라인 API 를 사용 할 수 있음. Use Guide Rancher Desktop 앱 실행 host 파일 설정1127.0.0.1 zempotdocker.com 쉘 스크립트 실행 윈도우 OS 도커 시작: [scripts] &gt; [windows] &gt; start_server.bat 실행 도커 종료: [scripts] &gt; [windows] &gt; end_server.bat 실행 백엔드 리빌드: [scripts] &gt; [windows] &gt; backend_rebuild.bat 실행 리눅스 OS 도커 시작: [scripts] &gt; [linux] &gt; start_server.sh 실행 도커 종료: [scripts] &gt; [linux] &gt; end_server.sh 실행 백엔드 리빌드: [scripts] &gt; [linux] &gt; backend_rebuild.sh 실행 웹 브라우저 접속","categories":[{"name":"Server","slug":"Server","permalink":"https://woonyzzang.github.com/categories/Server/"},{"name":"Docker","slug":"Server/Docker","permalink":"https://woonyzzang.github.com/categories/Server/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://woonyzzang.github.com/tags/docker/"}]},{"title":"AES 암복호화","slug":"node-aes-encryption-decryption","date":"2023-04-05T01:41:03.000Z","updated":"2024-06-10T04:53:59.574Z","comments":true,"path":"2023/04/05/node-aes-encryption-decryption/","permalink":"https://woonyzzang.github.com/2023/04/05/node-aes-encryption-decryption/","excerpt":"","text":"대상 언어 플랫폼 Net, Java, Node, C++ 암복호화 기준AES BlockSize: 128 bits KeySize: 256 bits Key: PBKDF2 로 생성된 Key 암호화 시 IV: 랜덤 16바이트 복호화 시 IV: 암호화 된 문자열을 Base64로 인코딩한 바이트 시퀀스의 앞 16자리 Padding: PKCS7 작업모드: CBC 암호화 결과: IV(16바이트)에 암호화된 바이트 시퀀스가 합쳐진 값이 base-64로 디코딩 된 문자열 key 생성 알고리즘 PBKDF2 사용 PBKDF2 https://www.rfc-editor.org/rfc/rfc2898.txt Password : 지정된 암호 Salt : 암호를 UTF8로 인코딩한 바이트 시퀀스를 SHA256으로 해시한 바이트 시퀀스 Iteration Count : 1000 해시 알고리즘 : SHA1 SHA1은 보안상 위험하나 .Net std 2.0에서는 SHA1만 지원하기 때문에 SHA1을 사용 MS에서는 보안문제로 SHA1보다는 SHA256이상을 권고 .Net std 2.0 상위 버전에서는 SHA256 사용 가능 Node- 암호화 (ENCRYPT) 12345678910111213141516171819202122232425262728293031323334353637const crypto = require(&#x27;crypto&#x27;);const Rijndael = require(&#x27;rijndael-js&#x27;);const padder = require(&#x27;pkcs7-padding&#x27;);const plainText = &#x27;평문 문자열&#x27;;const password = &#x27;지정된 암호&#x27;;const salt = crypto.createHash(&#x27;sha256&#x27;).update(Buffer.from(password)).digest();const key = await new Promise((resolve) =&gt; &#123; crypto.pbkdf2(password, salt, 1000, 32, &#x27;sha1&#x27;, (err, derivedKey) =&gt; &#123; if (err) &#123; throw err; &#125; resolve(derivedKey); &#125;);&#125;);const shuffle = (arr) =&gt; &#123; let x, t, r = new Uint32Array(1); for (let i = 0, c = arr.length - 1, m = arr.length; i &lt; c; i++, m--) &#123; crypto.webcrypto.getRandomValues(r); x = Math.floor((r / 65536 / 65536) * m) + i; (t = arr[i]), (arr[i] = arr[x]), (arr[x] = t); &#125; return arr;&#125;;const iv = Buffer.from(shuffle([...plainText]).join(&#x27;&#x27;)).slice(0, 16);const rijndael = new Rijndael(key, &#x27;cbc&#x27;);const padded = padder.pad(plainText, 32);const encrypted = rijndael.encrypt(padded, &#x27;128&#x27;, iv);const ciphertext = Buffer.concat([iv, Buffer.from(encrypted)]).toString(&#x27;base64&#x27;);console.log(ciphertext); - 복호화 (DECRYPT) 123456789101112131415161718192021222324252627const crypto = require(&#x27;crypto&#x27;);const Rijndael = require(&#x27;rijndael-js&#x27;);const padder = require(&#x27;pkcs7-padding&#x27;);const cipherText = &#x27;암호화 된 문자열&#x27;;const password = &#x27;지정된 암호&#x27;;const salt = crypto.createHash(&#x27;sha256&#x27;).update(Buffer.from(password)).digest();const key = await new Promise((resolve) =&gt; &#123; crypto.pbkdf2(password, salt, 1000, 32, &#x27;sha1&#x27;, (err, derivedKey) =&gt; &#123; if (err) &#123; throw err; &#125; resolve(derivedKey); &#125;);&#125;);const ivAndEncrypted = Buffer.from(cipherText, &#x27;base64&#x27;);const iv = ivAndEncrypted.slice(0, 16);const encrypted = ivAndEncrypted.slice(16, ivAndEncrypted.byteLength);const rijndael = new Rijndael(key, &#x27;cbc&#x27;);const decrypted = rijndael.decrypt(encrypted, &#x27;128&#x27;, iv);const decryptedPadded = padder.unpad(decrypted, 32);const plaintext = Buffer.from(decryptedPadded.filter((buf) =&gt; buf &gt; 11)).toString(&#x27;utf8&#x27;);console.log(plaintext); 아래 제공된 비밀번호와 원본 문자열로 Node로 암호화 된 문자열을 다른 언어의 AES로 복호화가 되는지 검증 할 수 있다. 원본 문자열: 123Apple.456TENET@Node 암호: &#x50;&#x40;&#x73;&#115;&#119;&#x30;&#114;&#x64;&#46;&#x4e;&#x6f;&#100;&#101; 암호화 된 문자열: NVRONGwzRUUuQVQyZG9AZVawSBA0&#x2F;3VPmOnljnL+5HhOariKM5KGZwJbe3Zi48ca","categories":[{"name":"Backend","slug":"Backend","permalink":"https://woonyzzang.github.com/categories/Backend/"},{"name":"Node","slug":"Backend/Node","permalink":"https://woonyzzang.github.com/categories/Backend/Node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://woonyzzang.github.com/tags/node/"}]},{"title":"DevOps Azure VM 파이프라인 CI/CD 구성","slug":"devops-pipeline-azure-vm","date":"2023-01-12T02:15:19.000Z","updated":"2024-06-25T20:43:41.038Z","comments":true,"path":"2023/01/12/devops-pipeline-azure-vm/","permalink":"https://woonyzzang.github.com/2023/01/12/devops-pipeline-azure-vm/","excerpt":"","text":"1. Azure VM 에 대한 빌드 구성[DevOps CI] - azure-pipelines.yml 빌드 파이프라인에서는 nuxt build 시 생성되는 client와 server 리소스를 각각 분리하여 Artifact에 저장 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647## [CDN STATIC]- task: CopyFiles@2 inputs: Contents: &#x27;.nuxt/dist/client/**&#x27; TargetFolder: &#x27;$(Build.ArtifactStagingDirectory)&#x27; CleanTargetFolder: true displayName: &#x27;Copy Files to: $(Build.ArtifactStagingDirectory)&#x27;- task: ArchiveFiles@2 inputs: rootFolderOrFile: &#x27;$(Build.ArtifactStagingDirectory)/.nuxt/dist&#x27; includeRootFolder: false archiveFile: &#x27;$(Build.ArtifactStagingDirectory)/$(clientName).zip&#x27; replaceExistingArchive: true displayName: &#x27;Archive Files&#x27;- task: PublishBuildArtifacts@1 inputs: pathToPublish: &#x27;$(Build.ArtifactStagingDirectory)/$(clientName).zip&#x27; displayName: &#x27;Publish Artifact: drop&#x27;## [NODE SERVER]- task: CopyFiles@2 inputs: Contents: | .nuxt/dist/server/** server-middleware/** static/** node_modules/** nuxt.config.ts package.json TargetFolder: &#x27;$(Build.ArtifactStagingDirectory)&#x27; CleanTargetFolder: true displayName: &#x27;Copy Files to: $(Build.ArtifactStagingDirectory)&#x27;- task: ArchiveFiles@2 inputs: rootFolderOrFile: &#x27;$(Build.ArtifactStagingDirectory)&#x27; includeRootFolder: false archiveFile: &#x27;$(Build.ArtifactStagingDirectory)/$(serverName).zip&#x27; replaceExistingArchive: true displayName: &#x27;Archive Files&#x27;- task: PublishBuildArtifacts@1 inputs: pathToPublish: &#x27;$(Build.ArtifactStagingDirectory)/$(serverName).zip&#x27; displayName: &#x27;Publish Artifact: drop&#x27; 배포 파이프라인에서 client 리소스는 blob storage로 Azure Copy하고, server 리소스는 Azure Web App으로 배포하여 서비스 가능. [DevOps CD]","categories":[{"name":"Server","slug":"Server","permalink":"https://woonyzzang.github.com/categories/Server/"},{"name":"Azure","slug":"Server/Azure","permalink":"https://woonyzzang.github.com/categories/Server/Azure/"}],"tags":[{"name":"azure","slug":"azure","permalink":"https://woonyzzang.github.com/tags/azure/"},{"name":"devops","slug":"devops","permalink":"https://woonyzzang.github.com/tags/devops/"}]},{"title":"Teams 채널 커넥터 연동","slug":"teams-notify-connector","date":"2023-01-11T03:34:05.000Z","updated":"2024-06-10T04:53:59.575Z","comments":true,"path":"2023/01/11/teams-notify-connector/","permalink":"https://woonyzzang.github.com/2023/01/11/teams-notify-connector/","excerpt":"","text":"1. Git 팀즈 연동 설정GitHub Enterprise 커넥터 구성 생성 이름*: &lt;Git 저장소 URL&gt; Webhook URL 을 복사 후 저장소 웹훅 설정에 추가한다. 다음 GitHub Enterprise 이벤트에 대해 자동 알림 받을 수 있다. Issues Pull request Push Issue comment Commit comment Pull request review comment 저장소 설정GitHub Enterprise settings &gt; Hooks 메뉴의 들어가서 Add webhook 버튼을 클릭한다. Payload URL: ex) https://exsample.com/postreceive Content type: application&#x2F;json SSL verification: Disabled (not recommended)","categories":[{"name":"Tools","slug":"Tools","permalink":"https://woonyzzang.github.com/categories/Tools/"},{"name":"Teams","slug":"Tools/Teams","permalink":"https://woonyzzang.github.com/categories/Tools/Teams/"}],"tags":[{"name":"teams","slug":"teams","permalink":"https://woonyzzang.github.com/tags/teams/"}]},{"title":"Vim 명령어 요약","slug":"vim-command","date":"2023-01-05T06:33:32.000Z","updated":"2024-06-07T09:27:28.380Z","comments":true,"path":"2023/01/05/vim-command/","permalink":"https://woonyzzang.github.com/2023/01/05/vim-command/","excerpt":"","text":"[Vim] 명령어브램 물레나르(Bram Moolenaar)가 만든 명령어 라인 사용자 인터페이스(CUI) 기반의 vi 호환 텍스트 편집기다. 현재 윈도우, 리눅스, OS X를 비롯한 크로스 플랫폼 운영체제 환경을 지원하며 vi와 호환되면서 독자적으로 다양한 기능을 추가한 vi 의 개선형 버전이다.Vim 스크립트를 통해 자유롭게 사용환경을 변경하거나 확장된 정규표현 문법, 다국어 지원, 문법 검사와 강조 기능, 플러그인을 통한 확장성 등 사용자에게 편의를 제공한다. IDE 에디터 플러그인 IntelliJ IdeaVim 설치 VisualStudioCode Vim 설치 종료 옵션 :q - 그냥 종료 :q! - 강제 종료 :w - 저장 :w! - 강제 저장 :wq - 저장하고 종료 :wq! - 강제 저장하고 종료 명령어 모드 esc esc - 명령 모드로 변경 i - insert (커서 앞) a - append (커서 뒤) I - 문장 시작 A - 문장 끝 입력 모드 i esc - 명령 모드로 변경 i - insert (커서 앞) a - append (커서 뒤) I - 문장 시작 A - 문장 끝 네비게이션 ( 방향키 ): 명령어 모드에서 사용 h - 왼쪽 이동 j - 아래 이동 k - 위로 이동 l - 오른쪽 이동 H - 화면 위 M - 화면 중간 L - 화면 끝 0(숫자) - 문장 앞으로 이동 $ - 문장 뒤로 이동 w - word 단어 단위로 이동 (숫자)w - (숫자) 단어씩 이동 ex ) 3w - 3단어씩 이동 b - backword 단어 단위로 이동 gg - 파일 앞 (소스코드 최상위) 이동 G - 파일 끝 (소스코드 최하단) 이동 (숫자)G - (숫자) 번째 줄로 이동 ex) 20G - 20번째 줄로 이동 ctrl + u - 위로 스크롤링 ctrl + d - 아래로 스크롤링 &#123; - 문단 시작 이동 &#125; - 문단 끝 이동 명령어 모드에서 글자 편집 x - 커서 기준 다음 한글자 삭제 dd - 문장 삭제 yy - 문장 복사 p - 붙여넣기 *p - 클립보드 붙여넣기 (클립보드에 저장된 텍스트를 사용하려면 에디터 설정이 필요) VisualStudioCode &gt; settings.json “vim.useSystemClipboard”: true 설정 변경 . - 이전 명령 반복 u - 되감기 ctrl + R - 앞 감기 v - 텍스트 셀렉트 ctrl + v - 블럭 단위로 텍스트 셀렉트 (멀티 셀렉트) / - 검색 n - 매칭 된 다음 단어로 이동 ? - 검색 n - 매칭 된 이전 단어로 이동 Command + Object 조합Command (명령) d delete (cut) y yank (copy) c change … Object (무엇에게) 3w - 커서 기준 뒤에 3 단어 삭제 3b - 커서 기준 앞에 3 단어 삭제 aw - 단어 하나 삭제 at - 태그 전체 삭제 ap - 문단 전체 삭제 as - 한줄 삭제 it - 태그 안에 텍스트 삭제 … ex) d3j - 삭제 커서 기준 아래 3 줄 d3k - 삭제 커서 기준 위에 3 줄 di&#123; - 삭제 중괄호 안에 모든 텍스트 di( - 삭제 소괄호 안에 모든 텍스트 da( - 삭제 소괄호 포함한 안에 모든 텍스트 di&#39; - 삭제 싱글쿼터 안에 모든 텍스트 da&#39; - 삭제 싱글쿼터 포함한 안에 모든 텍스트 ci[ - 변경 대괄호 안에 텍스트 후 자동으로 입력모드로 변경 dt( - 삭제 커서 기준 다음의 소괄호 있는 부분까지의 텍스트 df( - 삭제 커서 기준 다음의 소괄호 포함 있는 부분까지의 텍스트 d/헬로 - 삭제 검색 단어 매칭된 ‘헬로’ 텍스트 vaw - 셀렉트 단어 하나 vim 튜토리얼 문서 확인1$ vimtutor","categories":[{"name":"OS","slug":"OS","permalink":"https://woonyzzang.github.com/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"https://woonyzzang.github.com/categories/OS/Linux/"},{"name":"Vim","slug":"OS/Linux/Vim","permalink":"https://woonyzzang.github.com/categories/OS/Linux/Vim/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://woonyzzang.github.com/tags/linux/"},{"name":"vim","slug":"vim","permalink":"https://woonyzzang.github.com/tags/vim/"}]},{"title":"nuxt2","slug":"nuxt2","date":"2023-01-04T01:28:41.000Z","updated":"2024-06-10T04:53:59.574Z","comments":true,"path":"2023/01/04/nuxt2/","permalink":"https://woonyzzang.github.com/2023/01/04/nuxt2/","excerpt":"","text":"Nuxt.js Nuxt configuration file SSR (Universal) vs SPA vs SSG - SSR SPA SSG 모드 (config) ssr: true (universal) ssr: fasle (spa) target: ‘static’ 서버 유&#x2F;무 포함 (node.js 필요) 포함 (node.js 필요) SEO 최적화 불가 최적화 빌드 생성 방식 npm run build npm run build npm run generate SSR (universal) 모드: ssr: true 로 설정하면 ssr 모드로 동작 페이지 첫 접근 시 SSR 렌더링 되고, 페이지 간 이동은 CSR 로 진행 된다. SEO 최적화 SPA 모드: ssr: false 로 설정하면 spa 모드로 동작 CSR 로 렌더링 SEO 불가 SSG 모드: target: ‘server’ 로 설정 하면 런타임 때 요청에 맞춰 정적 html 렌더링 target: ‘static’ 으로 설정 하면 사용자가 요청 하기 전 빌드 시점에 미리 정적 html 만들어 렌더링 SEO 최적화 동적 url 처리 등은 불가 하며 단순 정적 페이지 같은 경우에 적합 MPA + SSG 조합 hybrid 방식 개발 가능 Nuxt 도입을 고려해야 할 때 하나의 프레임워크로 SSR, SPA, SSG 선택 개발이 가능하다라고 접근해야지, 추후 모드만 변경한다고 해서 Nuxt 가 모든걸 알아서 SSR, SPA, SSG 빌드 처리를 완벽하게 지원 한다라고 생각하면 안된다. (단적인 예로 SSR 모드 기준으로 개발을 진행하다가 도중 SPA 모드로 변경 시 SSR에서만 사용되는 특정 라이프 사이클 메서드 부분에서 에러가 발생 될 수 있다.)","categories":[{"name":"Backend","slug":"Backend","permalink":"https://woonyzzang.github.com/categories/Backend/"},{"name":"Nuxt","slug":"Backend/Nuxt","permalink":"https://woonyzzang.github.com/categories/Backend/Nuxt/"}],"tags":[{"name":"spa","slug":"spa","permalink":"https://woonyzzang.github.com/tags/spa/"},{"name":"nuxt2","slug":"nuxt2","permalink":"https://woonyzzang.github.com/tags/nuxt2/"}]},{"title":"DevOps Azure Static Web App 파이프라인 CI/CD 구성","slug":"devops-pipeline-azure-static-web-app","date":"2023-01-03T12:30:06.000Z","updated":"2024-06-10T04:53:59.542Z","comments":true,"path":"2023/01/03/devops-pipeline-azure-static-web-app/","permalink":"https://woonyzzang.github.com/2023/01/03/devops-pipeline-azure-static-web-app/","excerpt":"","text":"1. Azure 정적 Web Apps 에 대한 빌드 구성 빠른 시작: 첫 번째 정적 웹앱 빌드 Azure Static Web Apps에 대한 빌드 구성 [DevOps CI] - azure-pipelines.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445# Starter pipeline# Start with a minimal pipeline that you can customize to build and deploy your code.# Add steps that build, run tests, deploy, and more:# https://aka.ms/yamltrigger:- masterpool: vmImage: ubuntu-lateststeps: - task: NodeTool@0 inputs: versionSpec: &#x27;16.x&#x27; displayName: &#x27;Install Node.js&#x27; - script: | npm install npm run build:local displayName: &#x27;npm install and build&#x27; - bash: | echo &quot;--------------------&quot; pwd ls -al echo &quot;--------------------&quot; displayName: &#x27;Bash Script&#x27; - task: ArchiveFiles@2 inputs: rootFolderOrFile: &#x27;.&#x27; includeRootFolder: false verbose: true displayName: &#x27;Archive Files&#x27; - task: PublishBuildArtifacts@1 displayName: &#x27;Publish Artifacts&#x27; #- task: AzureStaticWebApp@0 # inputs: # app_location: &#x27;/build&#x27; # #output_location: &#x27;/dist&#x27; # #api_location: &#x27;api&#x27; # azure_static_web_apps_api_token: $(deploy_token) [DevOps CD] - [TEST] StaticWebApp-Test 2. 폴백 라우터 설정SPA 브라우저 라우터 사용 시 hash 기반이 아닌 history 기반으로 설정하고 페이지 이동 후 새로고침을 하게되면 404 Not Found 페이지를 반환하게 된다. Configure Azure Static Web Apps 빌드되는 산출물에 Azure Static Web Apps 에서 정의되어 있는 staticwebapp.config.json 파일 생성 후 설정하는 코드를 추가한 후 배포해야 함. staticwebapp.config.json 12345&#123; &quot;navigationFallback&quot;: &#123; &quot;rewrite&quot;: &quot;/index.html&quot; &#125;&#125; 3. 빌드 산출물 사이즈 확인 Tips for using Azure Static Web Apps Azure Web Apps 은 관리자 사이트가 있는 반면에 Azure Static Web Apps 는 별도로 관리자 사이트 같은 부분은 제공하지는 않는거 같음. (로컬환경이나 데브옵스 로그에서 확인가능하긴 함.) 4.Rest API 연동 테스트 Azure Static Web Apps -&gt; Function App (MS 권고 방법 backend) Azure Static Web Apps -&gt; VM (현재 사용중인 backend 방법) 12// CORS 설정http://localhost:3202,http://localhost:8080,http://*.winjoygame.com,https://*.winjoygame.com,vue-azure-static-web-app","categories":[{"name":"Server","slug":"Server","permalink":"https://woonyzzang.github.com/categories/Server/"},{"name":"Azure","slug":"Server/Azure","permalink":"https://woonyzzang.github.com/categories/Server/Azure/"}],"tags":[{"name":"azure","slug":"azure","permalink":"https://woonyzzang.github.com/tags/azure/"},{"name":"devops","slug":"devops","permalink":"https://woonyzzang.github.com/tags/devops/"}]},{"title":"Azure Static Web App","slug":"azure-static-web-app","date":"2023-01-03T12:06:56.000Z","updated":"2024-06-10T04:53:59.529Z","comments":true,"path":"2023/01/03/azure-static-web-app/","permalink":"https://woonyzzang.github.com/2023/01/03/azure-static-web-app/","excerpt":"","text":"Azure Static Web App 서비스 Azure 에서 정적 컨텐츠 (js, css, images) 들을 호스팅 할 수 있는 Pass 서비스 서버 사이드 렌더링이 필요하지 않는 CSR 이 가능한 Angular, React, Svelte, Vue 또는 blazor 같은 라이브러리와 프레임워크를 사용하여 빌드 Azure Functions 를 통하여 API 를 제공 받을 수 있다. Azure Web App 과 같이 배포, 무료 SSL, CORS 및 보안 서비스 등을 Azure 에서 관리하는 형태로 제공한다. 주요 기능 HTML, CSS, JavaScript 및 이미지와 같은 정적 컨텐츠에 대한 호스팅 자동으로 갱신되는 무료 SSL 인증서 CORS 구성이 필요 없는 API 를 호출할 때 역방향 프록시를 사용하는 원할한 보안 모델 Github 및 Azure DevOps 와 통합되는 쉬운 배포 보안 배포 슬롯 (무중단 배포 및 테스트 환경 제공) Static Web Apps로 수행할 수 있는 작업 Azure Functions 백 엔드를 통해WebAssembly 애플리케이션을 만드는 Angular, React, Svelte, Vue, Blazor 같은 JavaScript 프레임워크와 라이브러리를 사용하여 최신 웹 애플리케이션을 빌드 한다. Gatsby, Hugo, VuePress 와 같은 프레임워크를 사용하여 정적 사이트를 게시 합니다. Next.js 및 Nuxt.js 와 같은 프레임워크를 사용하여 웹 애플리케이션 을 배포합니다. 웹 어플리케이션 배포란 서버렌더링 (SSR) 지원이 아닌 제너레이터 (SSG) 로 의해 빌드된 정적 파일들을 의미함. Azure Static Web Apps의 할당량 Azure Static Web Apps의 할당량 기능 무료 요금제 표준 계획 포함된 대역폭 구독당 월 100GB 구독당 월 100GB 초과분 대역폭 사용할 수 없음 GB당 $0.20 Azure 구독당 앱 10 제한 없음 앱 크기 250MB 500MB 계획 크기 단일 배포의 경우 최대 앱 크기 500MB, 모든 준비 및 프로덕션 환경의 경우 최대 0.50GB 단일 배포의 경우 최대 500MB의 앱 크기, 모든 준비 및 프로덕션 환경에서 결합하여 최대 2.00GB 사전 프로덕션 환경 3 10 사용자 지정 도메인 앱당 2 개 앱당 5 개 권한 부여(기본 제공 역할) 기본 제공 authenticated 역할로 인증할 수 있는 무제한 최종 사용자 기본 제공 authenticated 역할로 인증할 수 있는 무제한 최종 사용자 권한 부여(사용자 지정 역할) 초대를 통해 사용자 지정 역할에 속할 수 있는 최대 25 명의 최종 사용자 초대를 통해 사용자 지정 역할에 속할 수 있는 최대 25 명의 최종 사용자 또는 서버리스 함수를 통해 사용자 지정 역할을 할당할 수 있는 무제한 최종 사용자","categories":[{"name":"Server","slug":"Server","permalink":"https://woonyzzang.github.com/categories/Server/"},{"name":"Azure","slug":"Server/Azure","permalink":"https://woonyzzang.github.com/categories/Server/Azure/"}],"tags":[{"name":"azure","slug":"azure","permalink":"https://woonyzzang.github.com/tags/azure/"}]},{"title":"Zendesk 라이브 테마 코드 편집","slug":"zendesk-theme-live-edit","date":"2023-01-03T03:25:42.000Z","updated":"2024-06-10T04:53:59.576Z","comments":true,"path":"2023/01/03/zendesk-theme-live-edit/","permalink":"https://woonyzzang.github.com/2023/01/03/zendesk-theme-live-edit/","excerpt":"","text":"젠데스크 라이브 테마 코드 편집하기 Admin: 로그인 젠데스크 관리자 계정 접근 권한 필요. 1. 디자인 사용자 지정 메뉴 &gt; 사용자 지정 버튼 클릭 2. 디자인 사용자 지정 메뉴 &gt; 사용자 지정 버튼 클릭 &gt; 코드 편집 버튼 클릭 3.위지익 에디트 코드 편집 (게시버튼 클릭 시 라이브 반영)","categories":[{"name":"Backend","slug":"Backend","permalink":"https://woonyzzang.github.com/categories/Backend/"},{"name":"Zendesk","slug":"Backend/Zendesk","permalink":"https://woonyzzang.github.com/categories/Backend/Zendesk/"}],"tags":[{"name":"zendesk","slug":"zendesk","permalink":"https://woonyzzang.github.com/tags/zendesk/"}]},{"title":"Azure VM","slug":"azure-vm","date":"2023-01-03T01:51:44.000Z","updated":"2024-06-10T04:53:59.537Z","comments":true,"path":"2023/01/03/azure-vm/","permalink":"https://woonyzzang.github.com/2023/01/03/azure-vm/","excerpt":"","text":"Azure VM 초기 셋팅 VM: Linux - Centos7 환경 yum 엡데이트 1$ sudo yum update Node 설치1$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash bashrc 파일 수정 1$ vim ~/bashrc 코드 삽입 123export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot;[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/bash_completion&quot; bashrc 업데이트 갱신 1$ source ~/.bashrc NPM 설치 123$ nvm insatall --ltsor$ nvm install 16.15.1 NPM 버전 기본 셋팅 1$ nvm alias default 16.15.1 node 설치 확인 명령어 1$ $ node -v Dotnet Core 3.1.201 수동 설치 패키지 설치 필요 없는거 같음. libicu 패키지 설치 CentOS Linux에 .NET 설치 - .NET 인프라 요청 &gt; libicu 패키지 다운로드 허용 문서 요청 1$ sudo yum install libicu Azure DevOps &gt; Azagent (Registration script) 실행반드시 Azagent 리눅스용 Resistration script 실행 시 ‘libicu’ 의존성 패키지 설치가 되어 있어야 한다. [v] Personal Access Token 활성화 체크 Personal Access Token: Azagent 프로세스 구동 확인1$ ps -e 웹서버 루트 폴더 셋팅 경로: &#x2F;home&#x2F;service_dev_ptltest 1$ sudo chmod 755 wwwroot PM2 셋팅 경로: &#x2F;home&#x2F;service_dev_ptltest 1231 $ sudo chmod 755 .pm2 $ sudo chown service_dev_ptltest .pm3 $ sudo chgrp wheel .pm","categories":[{"name":"Server","slug":"Server","permalink":"https://woonyzzang.github.com/categories/Server/"},{"name":"Azure","slug":"Server/Azure","permalink":"https://woonyzzang.github.com/categories/Server/Azure/"}],"tags":[{"name":"azure","slug":"azure","permalink":"https://woonyzzang.github.com/tags/azure/"}]},{"title":"Azure Web App","slug":"azure-web-app","date":"2023-01-03T00:58:02.000Z","updated":"2024-06-10T04:53:59.538Z","comments":true,"path":"2023/01/03/azure-web-app/","permalink":"https://woonyzzang.github.com/2023/01/03/azure-web-app/","excerpt":"","text":"Azure Web App 서비스 Azure 에서 HTTP 기반 웹 어플리케이션 및 API 를 호스팅 할 수 있는 Pass 서비스 Azure VM 과 달리 배포, 스케일링, 보안, 관리 서비스 등을 Azure 에서 관리하는 형태로 제공한다. 주요 기능 여러 언어 및 프레임워크 지원 (ASP.NET, ASP.NET Core, Java, Ruby, Node, PHP, Python) OS 및 언어 프레임워크를 자동으로 패치하고 유지 관리 컨테이너화 및 Docker 서비스 지원 고가용성을 가진 글로벌 규모 조정 보안 및 규정 준수 서버리스 코드 배포 슬롯 (무중단 배포 및 테스트 환경 제공) MPA + SSG hybrid 장점: 정적 페이지에 국한 되는 부분이지만 프론트엔드와 서버사이드 별도 분리 개발이 가능하다. 단점: 페이지의 일정 부분이 아닌 하나의 전체 페이지이기 때문에 서버사이드간에 데이터를 주고 받을 수 없다. 동적 url 처리 불가 목업 구현 테스트 (Java + Nuxt) Reference: 현대자동차 - hyundai.com SPA 페이지의 특정 라우트 맵핑 경로가 ‘&#x2F;kr&#x2F;ko&#x2F;e&#x2F;’라고 가정 서버 사이드 설정 1234567891011121314151617181920212223// controller - HomeController.java@Controllerpublic class HomeController &#123; // MPA 라우트 @GetMapping(&#123;&quot;&quot;, &quot;/&quot;&#125;) public String index(Model model) &#123; model.addAttribute(&quot;data&quot;, &quot;hello!&quot;); return &quot;index&quot;; &#125; // SPA 라우트 @GetMapping(&#123;&quot;/kr&quot;, &quot;/kr/ko&quot;&#125;) public String nuxt_redirect() &#123; return &quot;redirect:/kr/ko/e&quot;; &#125; // SPA 라우트 @GetMapping(&quot;/kr/ko/e&quot;) public String nuxt() &#123; return &quot;/client/index&quot;; &#125;&#125; 1234567891011121314151617181920212223242526// config - WebConfig.java@Configurationpublic class WebConfig implements WebMvcConfigurer &#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); // SPA 새로고침 시 정상 작동 설정 @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry .addResourceHandler(&quot;/kr/ko/e/**&quot;) .addResourceLocations(&quot;classpath:/static/kr/ko/e/&quot;) .resourceChain(false) .addResolver(new PathResourceResolver() &#123; @Override protected Resource getResource(String resourcePath, Resource location) throws IOException &#123; Resource requestedResource = location.createRelative(resourcePath); // logger.info(&quot;requestedResource:: &quot; + requestedResource); return requestedResource.exists() &amp;&amp; requestedResource.isReadable() ? requestedResource : new ClassPathResource(&quot;/templates/client/index.html&quot;); &#125; &#125;); &#125;&#125;","categories":[{"name":"Server","slug":"Server","permalink":"https://woonyzzang.github.com/categories/Server/"},{"name":"Azure","slug":"Server/Azure","permalink":"https://woonyzzang.github.com/categories/Server/Azure/"}],"tags":[{"name":"azure","slug":"azure","permalink":"https://woonyzzang.github.com/tags/azure/"}]},{"title":"DevOps Azure Web App 파이프라인 CI/CD 구성","slug":"devops-pipeline-azure-web-app","date":"2023-01-03T00:33:18.000Z","updated":"2024-06-10T04:53:59.543Z","comments":true,"path":"2023/01/03/devops-pipeline-azure-web-app/","permalink":"https://woonyzzang.github.com/2023/01/03/devops-pipeline-azure-web-app/","excerpt":"","text":"1. Azure Web Apps 에 대한 빌드 구성[DevOps CI] - azure-pipelines.yml 12345678910111213141516171819202122232425262728293031323334353637# Starter pipeline# Start with a minimal pipeline that you can customize to build and deploy your code.# Add steps that build, run tests, deploy, and more:# https://aka.ms/yamltrigger :- masterpool : vmImage : ubuntu-lateststeps : - task : NodeTool@ inputs : versionSpec : &#x27;16.x&#x27; displayName : &#x27;Install Node.js&#x27; - script : | npm install --legacy-peer-deps npm run build displayName : &#x27;npm install and build&#x27; - bash : | echo &quot;--------------------&quot; pwd ls -al echo &quot;--------------------&quot; displayName : &#x27;Bash Script&#x27; - task : ArchiveFiles@ inputs : rootFolderOrFile : &#x27;.&#x27; includeRootFolder : false displayName : &#x27;Archive Files&#x27; - task : PublishBuildArtifacts@ displayName : &#x27;Publish Artifact: drop&#x27; [DevOps CI] - azure-pipelines.yml (CDN 별도 배포 프로세스 ) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# Starter pipeline# Start with a minimal pipeline that you can customize to build and deploy your code.# Add steps that build, run tests, deploy, and more:# https://aka.ms/yamltrigger :- master- develop#pool: &#x27;zempot-agent-linux&#x27;pool : vmImage : ubuntu-latestvariables : clientName : Nuxt.Client serverName : Nuxt.Serversteps :- task : NodeTool@ inputs : versionSpec : &#x27;16.x&#x27; displayName : &#x27;Install Node.js&#x27;- script : | npm install --legacy-peer-deps npm run build displayName : &#x27;npm install and build&#x27;## [COMBINE]- task : CopyFiles@ inputs : Contents : | .nuxt/dist/client/** .nuxt/dist/server/** environment/** node_modules/** static/** schemes/** .env index.d.ts nuxt.config.ts package.json TargetFolder : &#x27;$(Build.ArtifactStagingDirectory)&#x27; CleanTargetFolder : true displayName : &#x27;Copy Files to: $(Build.ArtifactStagingDirectory)&#x27;- task : ArchiveFiles@ inputs : rootFolderOrFile : &#x27;$(Build.ArtifactStagingDirectory)&#x27; includeRootFolder : false archiveFile : &#x27;$(Build.ArtifactStagingDirectory)/$(serverName).zip&#x27; replaceExistingArchive : true displayName : &#x27;Archive Files&#x27;- task : PublishBuildArtifacts@ inputs : pathToPublish : &#x27;$(Build.ArtifactStagingDirectory)/$(serverName).zip&#x27; displayName : &#x27;Publish Artifact: drop&#x27; [DevOps CD] - [TEST] WebAppFrontTest","categories":[{"name":"Server","slug":"Server","permalink":"https://woonyzzang.github.com/categories/Server/"},{"name":"Azure","slug":"Server/Azure","permalink":"https://woonyzzang.github.com/categories/Server/Azure/"}],"tags":[{"name":"azure","slug":"azure","permalink":"https://woonyzzang.github.com/tags/azure/"},{"name":"devops","slug":"devops","permalink":"https://woonyzzang.github.com/tags/devops/"}]},{"title":"Zendesk 뷰 템플릿","slug":"zendesk-template","date":"2022-06-16T02:48:02.000Z","updated":"2024-06-07T09:27:28.388Z","comments":true,"path":"2022/06/16/zendesk-template/","permalink":"https://woonyzzang.github.com/2022/06/16/zendesk-template/","excerpt":"","text":"Zendesk 뷰 템플릿Curlybars 뷰 템플릿 엔진 기본 서식 페이지 각 기본서식은 HTML 마크업과 Handlebars와 같은 표현식이 혼합되어 구성되어 있으며, 기본서식에서 이중 중괄호로 식별된다. (Handlebars는 디자인할 때가 아니라 렌더링할 때 페이지에서 콘텐츠를 삽입하거나 수정할 수 있는 간편한 기본서식 작성 엔진)헬프 센터에서 기본서식 작성 언어를 Curlybars 라고 하며 대규모 Handlebars 언어 하위 집합을 구현한다. hbs 뷰 템플릿 섹션 요소 article_page.hbs 문서 페이지 지식창고의 개별 문서 페이지 category_page.hbs 카테고리 페이지 시작 페이지 community_post_list_page.hbs 커뮤니티 게시물 목록 페이지 - community_post_page.hbs 커뮤니티 게시물 페이지 - community_topic_list_page.hbs 커뮤니티 주제 목록 페이지 - community_topic_page.hbs 커뮤니티 주제 페이지 - contributions_page.hbs 기여 페이지 최종 사용자의 게시물, 커뮤니티 댓글 및 문서 댓글 목록 document_head.hbs 문서 헤드 (공통) 문서의 head 태그 error_page.hbs 오류 페이지 사용자가 존재하지 않는 페이지에 도착할 때 표시되는 메시지 footer.hbs 바닥글 (공통) 모든 헬프 센터 페이지 맨 아래에 표시 되는 것 header.hbs 머리글 (공통) 모든 헬프 센터 페이지 맨 위에 표시되는 것 home_page.hbs 홈 페이지 헬프 센터의 최상위 시작 페이지 new_community_post_page.hbs 새 커뮤니티 게시물 페이지 - new_request_page.hbs 새 요청 페이지 지원 요청 또는 티켓 제출 양식 request_page.hbs 요청 페이지 개별 지원 요청 또는 티켓 페이지 requests_page.hbs 요청 목록 페이지 사용자에게 배정되었거나 사용자가 참조에 포함된 지원 요청이나 티켓의 목록 search_results.hbs 검색 결과 검색 결과 표시 형식 section_page.hbs 섹션 페이지 시작 페이지 subscriptions_page.hbs 팔로잉 페이지 사용자가 팔로우하는 카테고리, 섹션 및 문서 목록 user_profile_page.hbs 사용자 프로필 페이지 - 커스텀 테마 업로드 시 주의사항모든 기본 hbs 뷰 템플릿이 반드시 존재해야만 업로드가 가능.","categories":[{"name":"Backend","slug":"Backend","permalink":"https://woonyzzang.github.com/categories/Backend/"},{"name":"Zendesk","slug":"Backend/Zendesk","permalink":"https://woonyzzang.github.com/categories/Backend/Zendesk/"}],"tags":[{"name":"zendesk","slug":"zendesk","permalink":"https://woonyzzang.github.com/tags/zendesk/"}]},{"title":"Zendesk 테마","slug":"zendesk-theme","date":"2022-06-16T02:47:36.000Z","updated":"2024-06-07T09:27:28.388Z","comments":true,"path":"2022/06/16/zendesk-theme/","permalink":"https://woonyzzang.github.com/2022/06/16/zendesk-theme/","excerpt":"","text":"Zendesk 테마 테마 &gt; 스캐폴딩 기본 구조a. https://zenplates.co/framework/getting-started/theme-structure 테마 &gt; 템플릿 기본 구조a. 헬프 센터 테마 사용자 지정하기 테마 &gt; manifest.json 셋팅 | 사용자 옵션a. 테마의 설정 창 사용자 지정하기 테마 &gt; 이미지 연동a. https://zenplates.co/framework/guides/change-images-and-icons 테마 &gt; 파일 업로드a. 티켓에서 첨부 파일 사용 설정하기","categories":[{"name":"Backend","slug":"Backend","permalink":"https://woonyzzang.github.com/categories/Backend/"},{"name":"Zendesk","slug":"Backend/Zendesk","permalink":"https://woonyzzang.github.com/categories/Backend/Zendesk/"}],"tags":[{"name":"zendesk","slug":"zendesk","permalink":"https://woonyzzang.github.com/tags/zendesk/"}]},{"title":"Zendesk","slug":"zendesk","date":"2022-06-16T02:46:42.000Z","updated":"2024-06-07T09:27:28.389Z","comments":true,"path":"2022/06/16/zendesk/","permalink":"https://woonyzzang.github.com/2022/06/16/zendesk/","excerpt":"","text":"Zendesk 란?Zendesk는 이메일, 트윗, 전화통화, 채팅, 헬프 센터, 검색 질문, 각종 SNS 등등 문의를 한 화면에서 처리하는 고객 서비스를 위한 소프트웨어 이다.고객, 상담원, 관리자 각 입장에서 젠데스크를 이용함으로써 효율을 높일 수 있다. API 테마 사용 및 헬프 센터 사용자 지정하기 – Zendesk 도움말 Help Center 헬프 센터 기본서식 작성 쿡북 헬프 센터 기본서식 작성 언어 사용하기(Guide Professional 및 Enterprise) Advanced customization of Web Widget (Classic) Offering end users multiple contact options Settings reference","categories":[{"name":"Backend","slug":"Backend","permalink":"https://woonyzzang.github.com/categories/Backend/"},{"name":"Zendesk","slug":"Backend/Zendesk","permalink":"https://woonyzzang.github.com/categories/Backend/Zendesk/"}],"tags":[{"name":"zendesk","slug":"zendesk","permalink":"https://woonyzzang.github.com/tags/zendesk/"}]},{"title":"PyScript","slug":"pyscript","date":"2022-06-10T06:14:48.000Z","updated":"2024-06-07T09:27:28.346Z","comments":true,"path":"2022/06/10/pyscript/","permalink":"https://woonyzzang.github.com/2022/06/10/pyscript/","excerpt":"","text":"PyScript 이란?python 코드를 클라이언트단인 웹브라우저에서 동작시킬 수 있고, PyScript에서 Javascript 라이브러리를 호출하고, python 으로 모든 웹 개발이 가능하다고 한다. PyScript CPython 과 WebAssembly &#x2F;Emscripten은 포팅해주는 Pyodide 으로 제작 PyScript는 추후 다른 언어들까지의 지원을 제공할 예정 Get Started 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Pyscript&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://pyscript.net/alpha/pyscript.css&quot;&gt;&lt;script defer src=&quot;https://pyscript.net/alpha/pyscript.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;py-script&gt; print(&#x27;Hello World!&#x27;)&lt;/py-script&gt;&lt;py-script&gt; import random for i in range(3): rNumber = random.randrange(1, 20) print(&#x27;random number: &#x27; + str(rNumber)) print(&quot;closed...&quot;)&lt;/py-script&gt;&lt;/body&gt;&lt;/html&gt; 파이썬 코드에서 동작하기 위해 필요한 파이썬 패키지 정의 12345678&lt;py-env&gt; - bokeh - matplotlib - pandas - scikit-learn - path: - ./my-custom-py-module.py&lt;/py-env&gt; 파이썬 표준 라이브러리나 써드파티 OSS 패키지들과 함께 사용하기 위해서는 py-env 태그에 dependency 명시 웹 페이지에서 실행될 파이썬 코드를 작성 123&lt;py-script&gt; print(&#x27;Hello, World!&#x27;)&lt;/py-script&gt; py 파일 import 로드 1&lt;py-script src=&quot;./python_file.py&quot;&gt;&lt;/py-script&gt; 코드 유저가 입력하고 확인할 수 있는 REPL (read-eval-prin loop) 컴포넌트를 생성 12345&lt;py-repl&gt; import numpy as np print(np.random.randn(10))&lt;/py-repl&gt; 데이터 시각화 샘플 예제123456789101112131415161718192021222324252627282930// index.html&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://pyscript.net/alpha/pyscript.css&quot;&gt; &lt;script defer src=&quot;https://pyscript.net/alpha/pyscript.js&quot;&gt;&lt;/script&gt; &lt;py-env&gt; - matplotlib - numpy - paths: - ./data.py &lt;/py-env&gt;&lt;/head&gt;&lt;body&gt;&lt;py-script&gt;print(&#x27;Hello world!&#x27;)&lt;/py-script&gt;&lt;h1&gt;Let&#x27;s plot random numbers&lt;/h1&gt;&lt;div id=&quot;plot&quot;&gt;&lt;/div&gt;&lt;py-script output=&quot;plot&quot;&gt; import matplotlib.pyplot as plt from data import make_x_and_y x, y = make_x_and_y(n=1000) fig, ax = plt.subplots() ax.scatter(x, y) fig&lt;/py-script&gt;&lt;/body&gt;&lt;/html&gt; 12345678// data.pyimport numpy as npdef make_x_and_y(n): x = np.random.randn(n) y = np.random.randn(n) return x, y PyScript는 현재 alpha 단계에 있고, 많은 알려진 이슈들이 있으며 (로딩 시간 등) PyScript를 활용해 다양한 것을 시도해보기를 권하지만 아직은 production 단계에서 사용하는 것을 권장하지 않는다고 한다. 참조 https://pyscript.net/ https://www.youtube.com/watch?v=3DuyJf_XPtM","categories":[{"name":"Backend","slug":"Backend","permalink":"https://woonyzzang.github.com/categories/Backend/"},{"name":"Python","slug":"Backend/Python","permalink":"https://woonyzzang.github.com/categories/Backend/Python/"},{"name":"PyScript","slug":"Backend/Python/PyScript","permalink":"https://woonyzzang.github.com/categories/Backend/Python/PyScript/"}],"tags":[{"name":"wasm","slug":"wasm","permalink":"https://woonyzzang.github.com/tags/wasm/"}]},{"title":"DevOps Azure Web App 배포 퍼포먼스 최적화","slug":"devops-azure-web-app-deploy-performance","date":"2022-06-09T05:02:53.000Z","updated":"2024-06-10T04:53:59.539Z","comments":true,"path":"2022/06/09/devops-azure-web-app-deploy-performance/","permalink":"https://woonyzzang.github.com/2022/06/09/devops-azure-web-app-deploy-performance/","excerpt":"","text":"[DevOps] Azure Web Apps CD Deploy 퍼포먼스 이슈Azure App Service 셋팅 환경 App Service Type Web App on Linux Runtime Stack 16 LTS (NODE|16-lts) Linux OS 환경에 Node 기반에서 Nuxt.js CI&#x2F;CD 자동화 배포 연동 후 Releases(CD) deploy 로그를 살펴보면 ‘9분 45 초’ 로 로그가 나오는데 수십번 배포 테스트 확인 결과 대략 평균 ‘8 ~ 14분’ 정도 정도 걸리는 듯 하다. DevOps 가 기본적으로 처리연산이 저렇게 나오기에 내부에서 사용하고 있는 기존 서버사이드로 사용하고 있는 VM 앱 서비스도 보통 배포 시간이 이런줄 알았는데 확인 결과 VM 쪽은 5 분? 정도 내외로 CD 배포가 이뤄지고 있다는 것을 확인 하였다. 팀내 인프라 로그 분석 도움을 주셨는데, 검토 결과 zip 파일 압축해제 과정에서 node_modules 폴더 용량이 크기 때문에 이 부분에서 시간이 오래 걸리는거 같다는 의견 이였다.해당 폴더는 배포 시 반드시 존재해야 의존성 패키지 모듈이기에 제외할 수 없고.. 다른 방법이 존재 하는지 찾아보아야 했다. 결론적으론 WEBSITE_RUN_FROM_PACKAGE 옵션 추가 후 값을 1 로 설정하면 배포 시간을 크게 단축 시킬 수 있었다.문서상으로는 zip 파일 상태로 배포하는 옵션인거 같은데 ssh &gt; 터미널에서 파일을 확인해보면 수정 파일이 최신화 되어 있는걸 볼 수 있다..(정확한 옵션 기능이 뭔지….) WEBSITE_RUN_FROM_PACKAGE 옵션을 추가 후 확인해 보면 1분대 내외로 배포되는 과정의 로그를 확인 할 수 있다. 옵션 추가 방법 DevOps &gt; App settings 에 추가 Azure 포탈 &gt; 관리자단 에서 추가 1) DevOps &gt; App settings 에 추가 -WEBSITE_RUN_FROM_PACKAGE 1 DevOps 옵션 주입 시 반영구적으로 반영되어 설정 셋팅이 유지 된다. 첫번째 방법으로 옵션을 추가하고 테스트 해봤는데 확인결과 Azure Web App Deploy 단계에서는 크게 배포 시간이 단축 되었지만 반대로 Download Artifacts 단계에서 ‘6분 52 초’ 시간이 걸렸다…;; 로그를 살펴보면 무언가 재귀하면서 반복 실행 되는 듯 하다. 암튼 해당 이유는 Task Version을 1 로 했을 시 일어나는 현상이었고 4 버전대로 가면 해당 이슈는 없을 것이다. 2) Azure 포탈 &gt; 관리자단 에서 추가 WEBSITE_RUN_FROM_PACKAGE 1","categories":[{"name":"Server","slug":"Server","permalink":"https://woonyzzang.github.com/categories/Server/"},{"name":"Azure","slug":"Server/Azure","permalink":"https://woonyzzang.github.com/categories/Server/Azure/"}],"tags":[{"name":"azure","slug":"azure","permalink":"https://woonyzzang.github.com/tags/azure/"},{"name":"devops","slug":"devops","permalink":"https://woonyzzang.github.com/tags/devops/"}]},{"title":".Net Core Blazor","slug":"dotnet-core-blazor","date":"2022-03-10T00:53:44.000Z","updated":"2024-06-10T04:53:59.545Z","comments":true,"path":"2022/03/10/dotnet-core-blazor/","permalink":"https://woonyzzang.github.com/2022/03/10/dotnet-core-blazor/","excerpt":"","text":"Blazor 란?Microsoft가 2018년 2월에 발표한 Blazor는 C#과 Razor(ASP.NET에서 사용하는 뷰 엔진), HTML을 사용해 웹 UI를 만들 수 있는 .NET 웹 프레임워크 기술 집합 이다. Blazor 종류 Blazor WebAssembly CSR (Client Side Rendering) 방식 Blazor Server SSR (Server Side Rendering) 방식 Blazor 이점 JavaScript가 아닌 생산성 높은 C#으로 개발할 수 있음 .NET 라이브러리를 사용할 수 있음 .NET의 수준높은 보안, 안정성, 성능을 제공 서버와 클라이언트의 로직을 공유할 수 있음 Windows, Linux, macOS에서 VisualStudio를 사용하여 개발 가능 초기 셋팅 관련은 클라이언트 환경에 비해 진입 러닝커브가 많이 낮음 프레젠테이션 컴포넌트화 부분 공통화 재사용이 가능 코드단에서 Controller와 View를 역할 분리 가능 css를 컴포넌트 별도 격리화 가능 트리쉐이킹 가능 ‘.Net Core MVC 구조 + 부분 Blazor 조합 가능’ | | ‘Blazor 구조 + 부분 .Net Core MVC 조합 가능’ ASP.NET Core Razor 구성 요소 미리 렌더링 및 통합 Blazor 단점 MS 공식문서를 제외한 다양한 Best Practices 참고 검색 자료 아직은 다소 부족함 Blazor WebAssembly 특징 장점 .NET 서버의 의존성 없음 클라이언트 리소스 및 기능을 완벽하게 활용 가능 서버의 부담을 클라이언트로 전담 PWA 지원 단점 SEO 불가 아직 미성숙한 퍼포먼스 성능 (추후 성능 퍼포먼스는 지속적으로 최적화되고 개선될 부분임) 브라우저에서 Blazor를 실행하려면 애플리케이션의 .wasm 및 .NET 라이브러리를 브라우저로 다운로드해야 할뿐만 아니라 Blazor가실행되는 .NET 런타임인 Mono.wasm도 다운로드해야 한다. Mono.wasm은 캐시될 수 있지만 이러한 자산을 처음 다운로드를 하면 애플리케이션의 시작이 지연되는데 테스트 결과 현재 시점에서 CSR 방식은 초기 로딩 성능이 많이 느림 DOM 요소를 직접 조작할 수 없다. 경우에 따라 클라이언트 앱은 HTML 요소를 많이 제어하는데, Blazor는 이 기능을 자체적으로 제공하지 않기 때문에 이 간격을 메우려면 JavaScript Interop 을 사용해야 하는데 대부분 현재 JavaScript로 처리하는 것 보다는 성능이느림 .NET 툴링 미지원 (예 : .NET 표준 지원 및 디버깅의 제한 사항) 모든 브라우저에서 지원범위 주의 필요 ASP.NET Core Blazor 지원 플랫폼 Blazor Server 특징 장점 RenderMode 선택 가능 RenderMode 열거형 (Microsoft.AspNetCore.Mvc.Rendering) ASP.NET Core Razor 구성 요소 미리 렌더링 및 통합 클라이언트 측 앱보다 앱 크기가 훨씬 적으므로 훨씬 빠르게 로드되어 동작 .NET Core 호환 API 사용을 포함하여 서버 기능을 최대한 활용 가능 서버의 .NET 코어에서 실행되므로 디버깅과 같은 기존 .NET 도구 작동 씬 클라이언트와 함께 작동 (WebAssembly 및 자원이 제한된 장치를 지원하지 않는 브라우저에서 작동함.) 앱의 구성 요소 코드를 포함한 .NET &#x2F; C # 코드 기반은 클라이언트에 제공되지 않음 단점 ASP.NET 코어 서버가 필요. 서버가없는 배포 (예 : CDN)는 불가능 Blazor Server 와 Blazor WebAssembly Application 의 차이점 구분 Blazor WebAssembly Blazor Server 서비스 등록 Program.cs Startup.cs 엔트리 파일 index.html _Host.cshtml 웹 API 호출 (built-in) 미리 구성된 HttpClient 서비스를 사용하여 웹 API를 호출 IHttpClientFactory 를 사용하여 만드는 HttpClient 인스턴스를 사용하여 웹 API를 호출 index.html, _Host.cshtmla. wwwroot 폴더를 보면 Blazor WebAssembly App은 index.html 파일이 없고, Blazor 서버 앱은 없다.b. index.html파일은 blazor.webassembly.js 파일을 참조하고, application의 모든 파일을 다운로드 한다.c. 이와 비슷한 일은 Blazor 서버 앱 Page&#x2F;_Host.cshtml 파일에서 발생한다. 이 파일에서 참조하는 blazor.server.js 파일은 client WebSocketconnection을 담당한다.d. 그 외 Counter, Index, FetchData 파일이 동일하게 들어가 있으며, 이것은 component files를 재사용 할 수 있다는 뜻이다. settinga. Blazor 서버 앱은 Startup.cs, appsettings.json 파일이 있고, Blazor WebAssembly App에는 없다.b. Blazor WebAssembly App에서 서비스를 등록하기 위해서는 Program.cs 파일을 사용해야 한다.","categories":[{"name":"Backend","slug":"Backend","permalink":"https://woonyzzang.github.com/categories/Backend/"},{"name":".Net Core","slug":"Backend/Net-Core","permalink":"https://woonyzzang.github.com/categories/Backend/Net-Core/"}],"tags":[{"name":"blazor","slug":"blazor","permalink":"https://woonyzzang.github.com/tags/blazor/"},{"name":"spa","slug":"spa","permalink":"https://woonyzzang.github.com/tags/spa/"}]},{"title":"DevOps > Github 커넥터 연동","slug":"devops-connect-github","date":"2022-02-24T04:54:18.000Z","updated":"2024-06-10T04:53:59.793Z","comments":true,"path":"2022/02/24/devops-connect-github/","permalink":"https://woonyzzang.github.com/2022/02/24/devops-connect-github/","excerpt":"","text":"파이프라인 커넥터 레파지토리 연동1. 커넥터를 통한 GitHub Enterprise Server 레파지토리 연동 Pipelines &gt; [New pipeline] 버튼 클릭 &gt; 레파지토리 설정에서 Personal access token 생성 후 연동 2. CI&#x2F;CD 파이프라인 플로우 빌드 때 별도 서버에서 빌드 함.","categories":[{"name":"Server","slug":"Server","permalink":"https://woonyzzang.github.com/categories/Server/"},{"name":"Azure","slug":"Server/Azure","permalink":"https://woonyzzang.github.com/categories/Server/Azure/"}],"tags":[{"name":"azure","slug":"azure","permalink":"https://woonyzzang.github.com/tags/azure/"},{"name":"devops","slug":"devops","permalink":"https://woonyzzang.github.com/tags/devops/"}]},{"title":"DevOps CI 단계 Import Component NotFound 에러","slug":"devops-ci-import-component-not-found-error","date":"2022-02-11T05:25:16.000Z","updated":"2024-06-10T04:53:59.540Z","comments":true,"path":"2022/02/11/devops-ci-import-component-not-found-error/","permalink":"https://woonyzzang.github.com/2022/02/11/devops-ci-import-component-not-found-error/","excerpt":"","text":"[DevOps] SPA 빌드 시 import 컴포넌트 not found 에러에러: 자동화 파이프라인을 통해 빌드 CI 스크립트 npm 빌드 시 ##[error]Bash exited with code ‘1’. 에러가 발생함. azure-pipelines.yml 123456789101112131415161718192021222324252627282930313233trigger:- masterpool: vmImage: ubuntu-lateststeps:- task: NodeTool@ inputs: versionSpec: &#x27;16.x&#x27; displayName: &#x27;Install Node.js&#x27;- script: | npm install npm run build displayName: &#x27;npm install and build&#x27;- task: ArchiveFiles@ displayName: &#x27;Archive dist Directory&#x27; inputs: rootFolderOrFile: dist includeRootFolder: false archiveType: &#x27;zip&#x27; archiveFile: &#x27;$(Build.ArtifactStagingDirectory)/$(Build.BuildId).zip&#x27; replaceExistingArchive: true verbose: true- task: PublishBuildArtifacts@ displayName: &#x27;Publish Artifacts&#x27; inputs: PathtoPublish: &#x27;$(Build.ArtifactStagingDirectory)&#x27; ArtifactName: &#x27;drop&#x27; publishLocation: &#x27;Container&#x27; 에러 로그를 살펴보면 아래와 같은데 12345678...These dependencies were not found:* @/components/MenuList/Link.component.vue in ./node_modules/cache-loader/dist/cjs.js??ref--13-0!....* @/components/MenuList/Unlink.component.vue in ./node_modules/cache-loader/dist/cjs.js??ref--13-0!...... 대략 요점은 스크립트 import 구문에서 의존성 컴포넌트 path를 제대로 인식못해서 발생하는 것 같은데… 로컬에서 빌드해보면 이상없이 잘 되는데 희한하게 DevOps 파이프라인에서만 빌드 시 계속 에러가 발생했다. 그래서 원인을 알아내려 대략 아래와 같이 수정해서 테스트 확인해 보았다.. 원인 모를 node_modules 캐시 에러를 대응하느라 검색 하면서도 이것저것 테스트 해봤는데 대략 머리에 기억에 남는게 아래 정도 있었던거 같다.. alias 부분을 직접적인 상대경로도 변경 파일명 대소문자 변경 vue.config 파일 설정 변경 동적 컴포넌트 부분을 수동으로 변경 파이프라인 스크립트 node 캐시 삭제 추가 파이프라인 스크립트 npm 버전 업데이트 추가 파이프라인 스크립트 cli 관련 패키지 글로벌 설치 기타… 해결: [components] &gt; [MenuList] 디렉토리 삭제 후 배포 (빌드 성공) @/components/Link.component.vue @/components/Unlink.component.vue 다시 원래의 [MenuList] 디렉토리 생성 후 배포 (빌드 성공) @/components/MenuList/Link.component.vue @/components/MenuList/Unlink.component.vue 처음 MenuList 디렉토리를 지우고 파이프라인을 돌려보니 정상적으로 빌드 되었다. 그래서 다시 원래 MenuList 디렉토리를 만들어 다시 파이프라인를 돌려봤는데 정상적으로 빌드 되었다.;; 원인은 잊고 있었는데 아마 이전에 menuList → MenuList 로 디렉토리를 변경했던 부분이 아마도 Git이 대소문자를 구분하지 못해서 저장소에 변경된 폴더 내 캐싱된 파일이 남아 있었고 이번에 DevOps 파이프라인 연동해보면서..윈도우 계열은 대소문자를 구분 못하니 이슈가 없었을꺼 같은데 리눅스 계열 (우분투도 마찮가지일테고..) 은 대소문자를 구분하기에 Git 캐싱이 node_modules 캐시 로더 관련 부분과 맞물려서 해당 에러를 발생시켯던 것 같다.Git 대소문자 구분 설정을 추가하던가 캐시를 지우고 커밋하면 아마 디렉토리를 굳이 지우고 다시 추가하지 않아도 해결 될 것이다. 결국 애초부터 코드단이나 설정부분에 아무런 이상 없는 에러였던 것… (이런게 원인 찾고 해결하기 정말 애매하고 힘들다…) 정말 허망하고 어이가 없긴하지만… 같이 협업하는 사람이 있었으면 같은 에러가 발생해서 Git 캐싱 이슈를 금방 알수 있었을텐데.. 혼자 하다보니 이부분을 미처 예상치 못하고 에러로그처럼 vue.js 나 node_modules 관련 이슈 인줄 알고 한참을 고생한거 같다…..;;","categories":[{"name":"Server","slug":"Server","permalink":"https://woonyzzang.github.com/categories/Server/"},{"name":"Azure","slug":"Server/Azure","permalink":"https://woonyzzang.github.com/categories/Server/Azure/"}],"tags":[{"name":"azure","slug":"azure","permalink":"https://woonyzzang.github.com/tags/azure/"},{"name":"devops","slug":"devops","permalink":"https://woonyzzang.github.com/tags/devops/"}]},{"title":"DevOps 신규 프로젝트 배포 시 job 에러 해결","slug":"devops-project-deploy-job-error","date":"2022-02-11T04:31:52.000Z","updated":"2024-06-07T09:27:28.296Z","comments":true,"path":"2022/02/11/devops-project-deploy-job-error/","permalink":"https://woonyzzang.github.com/2022/02/11/devops-project-deploy-job-error/","excerpt":"","text":"신규 프로젝트 생성 후 파이프라인 가동 시 job 에러12에러내용: &quot;No hosted parallelism has been purchased or granted. To request a free parallelism grant, please fillout the following form https://aka.ms/azpipelines-parallelism-request&quot; 해결 https://aka.ms/azpipelines-parallelism-request 접속 후 양식 작성 (나는 누구고 어느 프로젝트에 대해 limit 을 해제해 달라고 요청) 하면 2~3일 소요 후 처리 완료 메일이 온다.검색해 보니 얼마전까지만 해도 이런게 없었는데 이 job을 코인 채굴에 사용하는 사람들이 있어서 MS 정책이 바뀌었다고 하는거 같다.","categories":[{"name":"Server","slug":"Server","permalink":"https://woonyzzang.github.com/categories/Server/"},{"name":"Azure","slug":"Server/Azure","permalink":"https://woonyzzang.github.com/categories/Server/Azure/"}],"tags":[{"name":"azure","slug":"azure","permalink":"https://woonyzzang.github.com/tags/azure/"},{"name":"devops","slug":"devops","permalink":"https://woonyzzang.github.com/tags/devops/"}]},{"title":"JWT Token Flow","slug":"jwt-token-flow","date":"2022-02-11T03:55:08.000Z","updated":"2024-06-07T09:27:28.340Z","comments":true,"path":"2022/02/11/jwt-token-flow/","permalink":"https://woonyzzang.github.com/2022/02/11/jwt-token-flow/","excerpt":"","text":"[SPA] JWT Token Flow JWT의 구체적인 구현 방법에 대해서는 정해진 정답이란 정석은 없다.AccessToken이나 RefreshToken 의 만료 기간이라든가, refresh 할 때 AccessToken을 같이 보낼 것인지 정보를 재사용할것인지, RefreshToken의 payload에 무엇을 담아야 하는지.. 등등.. 서비스에 따라 구현하기 나름 쿠키만으로 인증하는 서비스의 취약점을 이용하는 XSRF(CSRF) 공격을 대응하기 위해 인증 정보를 쿠키 대신 토큰을 사용하여 헤더로 보내는 방식을 권장하나 쿠키로 인증하는 서비스들도 많이 있음. AccessToken 단독 사용 시 토큰 탈취 방지를 위해 AccessToken 만료 기간은 짧게 설정, RefreshToken 만료 기간을 길게 설정 후 2 개의 토큰을 같이 발급해서 AccessToken 갱신 (AccessToken 단독 사용 보다는 그나마 조금이라도 보안 강화) 1) 클라이언트 JWT Token 인증 + Refresh Token 처리 Refresh Token 이슈 Local Storage 자바스크립트로 RefreshToken 값에 접근이 쉽게 되기에 XSS 공격에 취약하고 보안상 문제 소지가 많다. Cookie 동일 호스트 조건으로 HTTPOnly 와 Secure 옵션을 사용하여 자바스크립트로 접근을 차단할 수 있지만 이 또한 보안에는 불안한 요소가 남아있어 보안상 문제의 소지가 될 수 있다. Server RefreshToken 값을 서버 DB에 저장하기에 보안이 가장 안전하다. 2) 서버 JWT Token 인증 + Refresh Token 처리 클라이언트에게 제공되는 RefreshToken에 대한 보안 및 안전성은 늘 문제로 제기 되고 있다. RefreshToken 을 서버단에서 처리는예를 들어 DB에 실제 RefreshToken 값을 저장하고 이때 Index 값을 hash값을 생성해 클라이언트에 전달해서 Cookie, Storage에 저장하는 방법이다.이렇게 하면 hash 값을 생성한 값을 RefreshToken 으로 저장하기에 클라이언트단에 노출된 RefreshToken 값은 실제 발급된 RefreshToken 값과 무관하므로 노출되어도 알 수 있는 방법이 없으므로 보안상 좀 더 안전하게 저장할 수 있다. 최근 네이버, 카카오 등등 RefreshToken 도 노출하지 않고 REST API 로만 처리할 수 있는 방식으로 정책이 바뀌고 있는 것을 확인할 수 있다. Kakao Developers 발취 refresh_token, refresh_token_expires_in JavaScript SDK의 보안 강화를 위해 리프레시 토큰을 취급하지 않도록 수정되었습니다.Kakao.Auth.login 및 Kakao.Auth.createLoginButton 함수를 사용한 로그인 시 발급되는 리프레시 토큰 정보(refresh_token, refresh_token_expires_in)는 2020 년 7 월 27 일 응답에서 제외되었습니다. github, foursquare는 RefreshToken 을 사용하지 않는다고 한다.","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"SPA","slug":"Frontend/SPA","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/"},{"name":"JWT","slug":"Frontend/SPA/JWT","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/JWT/"}],"tags":[{"name":"jwt","slug":"jwt","permalink":"https://woonyzzang.github.com/tags/jwt/"}]},{"title":"WebAssembly (웹 어셈블리)","slug":"wasm","date":"2022-02-11T02:36:08.000Z","updated":"2024-06-07T09:27:28.381Z","comments":true,"path":"2022/02/11/wasm/","permalink":"https://woonyzzang.github.com/2022/02/11/wasm/","excerpt":"","text":"WebAssemblyWebAssembly(WASM)는 최신 웹 브라우저에서 실행할 수 있는 새로운 유형의 코드이며, 새로운 기능과 성능 면에서 큰 이점을 제공한다. 직접코드를 작성하는 것이 아니라 C, C ++, RUST 등의 저급 소스 언어를 효과적으로 컴파일하도록 고안되었다. 이전에 불가능했던 웹에서 실행되는 클라이언트 응용 프로그램을 사용하여 웹에서 여러 언어로 작성된 코드를 네이티브에 가까운 속도로 실행 하는 길을 제공한다.(실제로 native code 에 비해 20% 밖에 느리지 않다는 결과가 있음) 단점 추가적인 언어의 학습 제한된 지원 범위 비교적 적은 참고 자료 웹 어셈블리 향후 전망 웹 어셈블리는 목적 자체가 자바스크립트 언어를 대체할 목적으로 만들어진 언어가 아니며, 자바스크립트로 하던 프론트엔드 영역을 대체 하는 것이 아니기에 새로운 영역으로 추후 웹 어셈블리를 전문적으로 다루는 직군의 포지션이 생길 것으로 보고 있다고 함. 웹 어셈블리는 향후 차세대 웹 플랫폼으로 긍정적으로 평가되어 서서히 대두 되고 있지만 실제 웹 플랫폼 개발 환경에서 사용할 가능성은 거의 없어 보이며, 실제 웹 어셈블리가 적용되는 개발 환경은 웹을 위한것이 아닌 다음과 같은 환경의 작업을 수행하는 경우 사용 될 것으로 내다보고 있음. 영상 편집 게임 개발 AR &#x2F; VR 라이브 애플리케이션 음악 편집 및 스트리밍 플랫폼 에뮬레이션 암호화 VPN 이미지 인식 참조 https://developer.mozilla.org/ko/docs/WebAssembly/Concepts","categories":[{"name":"Backend","slug":"Backend","permalink":"https://woonyzzang.github.com/categories/Backend/"},{"name":"Wasm","slug":"Backend/Wasm","permalink":"https://woonyzzang.github.com/categories/Backend/Wasm/"}],"tags":[{"name":"wasm","slug":"wasm","permalink":"https://woonyzzang.github.com/tags/wasm/"}]},{"title":"React.js Storybook Typescript Design System Utilization","slug":"reactjs-storybook-typescript-design-system-utilization","date":"2020-03-16T15:27:55.000Z","updated":"2024-06-07T09:27:28.367Z","comments":true,"path":"2020/03/17/reactjs-storybook-typescript-design-system-utilization/","permalink":"https://woonyzzang.github.com/2020/03/17/reactjs-storybook-typescript-design-system-utilization/","excerpt":"","text":"Storybook을 활용하여 본격적으로 디자인 시스템 구축하기 스토리북을 쓰는 방법을 어느정도 배웠으니, 이제 Hello 컴포넌트 말고 정말 디자인 시스템에 있어서 유의미한 컴포넌트들을 만들어봅시다. 그런데, 어떤 컴포넌트를 만들어야 할까요? 사실 가장 이상적인것은 프로젝트를 만드는 과정에서 처음부터 디자인 시스템을 구축하고 재사용이 자주 될 것 같은 컴포넌트를 만들게 될 때마다 디자인 시스템에 컴포넌트를 하나씩 추가해가면서 문서화하는 방향입니다. 하지만, 현실세계에선 체계가 처음부터 잘 잡혀있는 조직에서, 어떠한 프로젝트를 처음부터 만들게 되지 않는 이상 이렇게 작업하기가 쉽지 않습니다. 대부분의 경우엔 이미 존재하는 프로젝트가 있고, 나중에 가서 디자인 시스템의 필요성을 느껴 이를 도입하는 흐름이 꽤나 일반적입니다. 디자인 시스템을 만들어서 기존 프로젝트에 적용하고, 이를 관찰 후 디자인 시스템을 개선하고, 또 반영하고. 이런 흐름으로 진행되는 것이죠. 이러한 상황에서 먼저 해야 하는 것은, UI 인벤토리입니다 (UI Auditing 이라고도 불립니다) 프로젝트에서 사용되는 UI 들의 스크린샷을 찍어서 종류별로 나열하는것이죠. 이렇게 UI 인벤토리를 작업을 하면, 어떤 UI 들이 일관성 없게 사용되고 있는지 쉽게 조사 할 수 있습니다. 그리고, 재사용성을 높인 컴포넌트를 만들게 될 때 어떤 옵션들을 줘야 할 지 결정을 해야 할 때도 큰 도움이 됩니다. UI 인벤토리를 할때는 대충 Keynote, Powerpoint, Photoshop, Figma, Sketchapp 등 아무거나 사용하셔도 됩니다. 그 다음엔 우선순위를 정하세요. 우선순위를 정할 땐 정해진 방식은 없지만 제가 개인적으로 권장하는 방식은 다음 요소들을 고려해보는 것 입니다: 많이 사용 되는가? 만들기 쉬운가? 4-1. Button 만들기일반적으로, Button 부터 시작하면 좋습니다. Button이 없는 서비스는 사실상 찾기 힘들죠. 그런데, Button. 쉬울 것 같지만 사실 생각보다 어렵습니다. 고려할 게 생각보다 많거든요. 다른 성공적인 디자인 시스템을 보고 배워봅시다. https://www.carbondesignsystem.com/components/button/code https://polaris.shopify.com/components/actions/button#navigation https://designsystem.digital.gov/components/button/ https://primer.style/components/Buttons https://zeit.co/design/button https://sproutsocial.com/seeds/components/button https://storybook.grommet.io/?path=/story/button--basic https://atlassian.design/guidelines/product/components/buttons 1. 버튼의 상태 마우스 커서, 포커스, 비활성화에 따라 다르게 보여지는 버튼의 상태. 참 중요한 요소죠. 2. 버튼의 theme (또는 variations) 3. 버튼의 사이즈 4. 아이콘과 함께 사용될 때 고려해야 할 것들 정말 많죠? 디자인 시스템에서 사용 할 컴포넌트를 만들 때는 다음과 같이 어떤 버튼들을 만들 지 Sketchapp 또는 Figma로 계획을 하고 진행을 하는 것이 좋습니다. 특정 조직 내에서 디자인 시스템을 만든다면 위와 같은 작업을 디자이너가 해주시겠지요. 하지만 이 강의에서 디자인 도구를 사용하는 것 까지 모두 다룰 수는 없으니, 우리는 바로 코드를 작성하여 컴포넌트를 만들어주도록 하겠습니다. 자, 본격적으로 Button 컴포넌트를 개발해봅시다. 이젠 우리가 기존에 만들었던 Hello 컴포넌트와 Bye 컴포넌트는 더 이상 필요하지 않으므로 해당 디렉터리를 제거하셔도 됩니다. src 디렉터리에 Button 디렉터리를 만들고, 그 안에 Button.tsx 파일을 다음과 같이 작성해보세요. src&#x2F;Button&#x2F;Button.tsx 1234567891011import React from &#x27;react&#x27;;export type ButtonProps = &#123; children: React.ReactNode;&#125;;function Button(&#123;children&#125;: ButtonProps) &#123; return &lt;button&gt;&#123;children&#125;&lt;/button&gt;;&#125;export default Button; TypeScript 에 익숙하지 않은 분들을 위해 설명을 드리자면, React.ReactNode 는 children 을 위한 타입을 지정 할 때 사용하는 타입입니다. 1234567type ReactNode = | ReactChild | ReactFragment | ReactPortal | boolean | null | undefined; 이 타입은 children 으로 들어올 수 있는 모든 값을 허용해줍니다. emotion을 사용하여 컴포넌트 스타일링하기컴포넌트를 스타일링하기 위하여 일반 css 파일을 작성하셔도 되긴 하지만, 저는 그 대신에 emotion 이라는 CSS-in-JS 라이브러리를 사용하는 것을 권장합니다. 그 이유는, 나중에 라이브러리를 배포하게 될 때 css-loader 쪽에 대해서 신경 쓸 필요 없고, 라이브러리를 사용하게 될 때에도 css 를 불러오는 것에 대해서 신경쓰지 않아도 되기 때문입니다. 대체제로 styled-components 가 사용 될 수 있지만, 라이브러리 용도로는 emotion 을 사용하는 것을 권장드립니다. 3가지 이유가 있는데요. 1. 파일 사이즈가 더 작다 2. 인기도 또한 지난 8월에 추월 물론, 다운로드 수 &#x3D; 인기도 라고 볼 수는 없습니다. emotion이 추월한 것은 인기도라기 보다는, UI 라이브러리에서 많이 사용 되다 보니 이로 인한 영향이 있을것이라는 것을 감안해야 합니다. 실제로는, 국내 인지도는 매우 낮습니다. 3. 서버사이드 렌더링 시 styled-components 는 서버쪽에서 해줘야 할 작업이있음. emotion 은 신경 안써도 됨. styled-compnents는 서버사이드 렌더링을 할 경우에 ServerStyleSheet 라는 것을 사용하여 별도의 작업을 진행해주어야 합니다. 반면 emotion은 별도의 작업 없이 바로 서버사이드 렌더링이 문제없이 작동합니다. 물론, styled-components 도 굉장히 훌륭한 라이브러리이기 때문에 그게 좋으면 쓰셔도 전혀 상관없습니다! 다만 emotion을 써보신적이 없으시다면 오늘은 이번 기회에 한번 emotion 사용을 해보면 어떨까요? emotion을 설치해봅시다! 12$ yarn add --peer @emotion/core# 또는 npm install --save @emotion/core 우리는 나중에 이 프로젝트를 라이브러리로 만들어서 npm 등록할 것이며, 나중에 이 라이브러리를 설치할 때 @emotion&#x2F;core를 자동으로 설치하지 않고 사용하는 프로젝트에서 별개로 원하는 버전을 설치하여 사용할 수 있게 해 줄 것입니다. 그렇게 하기 위해서는 peerDependency로 패키지를 설치해주어야 합니다. yarn을 사용하지 않고 npm을 사용하고 계신다면 peerDependency로 바로 설치 할 수는 없습니다(CLI 해당 옵션이 존재하지 않습니다). 따라서, npm을 사용하시는 분들은 나중에 package.json에서 dependencies를 peerDependencies로 바꿔주는 작업을 해야합니다. 이는 npm패키지를 등록하는 과정에서 다뤄볼 예정이니 지금은 그냥 --save 옵션으로 설치해주세요. 이제, 우리가 만든 버튼을 스타일링 해봅시다. 나중에 시간 날 때 공식 문서를 읽어보시는 것을 권장드립니다. 지금은 그냥 따라해보시면서 저런식으로 사용하는구나! 하고 이해하시면 충분합니다. emotion을 설치하셨으면, 버튼을 스타일링해봅시다. onClick 함수도 파라미터로 받아와주도록 하겠습니다. src&#x2F;Button&#x2F;Button.tsx 12345678910111213141516171819202122232425262728293031323334353637383940414243/** @jsx jsx */import &#123; jsx, css &#125; from &#x27;@emotion/core&#x27;;type ButtonProps = &#123; /** 버튼 안의 내용 */ children: React.ReactNode; /** 클릭했을 때 호출할 함수 */ onClick?: (e?: React.MouseEvent&lt;HTMLButtonElement&gt;) =&gt; void;&#125;;/** `Button` 컴포넌트는 어떠한 작업을 트리거 할 때 사용합니다. */const Button = (&#123;children, onClick&#125;: ButtonProps) =&gt; &#123; return ( &lt;button css=&#123;style&#125; onClick=&#123;onClick&#125;&gt; &#123;children&#125; &lt;/button&gt; );&#125;;const style = css` outline: none; border: none; box-sizing: border-box; height: 2rem; font-size: 0.875rem; padding: 0.5rem 1rem; background: #20c997; color: white; border-radius: 0.25rem; line-height: 1; font-weight: 600; &amp;:focus &#123; box-shadow: 0px 0px 8px rgba(0, 0, 0, 0.2); &#125; &amp;:hover &#123; background: #38d9a9; &#125; &amp;:active &#123; background: #12b886; &#125;`;export default Button; emotion 에서는 css props 를 사용하기 위해서 상단에 /** @jsx jsx */ 라는 JSX Pragma 를 설정하고, jsx 를 emotion 에서 불러와야 합니다. 이 Pragma 는 babel 이 JSX 를 변환 할 때 React.createElement 대신에 emotion의 jsx 함수를 사용하게 해줍니다. 이렇게 JSX Pragma를 사용하게 되면, 컴포넌트 코드에서 상단에 import React from &#39;react&#39;;를 생략해도 됩니다. 버튼에서 사용된 색상은 open-color 에서 가져왔습니다. 나중에 디자인 시스템에서 사용 할 색상에 대한 문서도 mdx 형태로 작성하시면 좋습니다. 이제 버튼을 위한 스토리를 작성해봅시다! src&#x2F;Button&#x2F;Button.stories.tsx 12345678910111213141516171819import React from &#x27;react&#x27;;import Button from &#x27;./Button&#x27;;export default &#123; title: &#x27;components|Button&#x27;, component: Button&#125;;export const button = () =&gt; &#123; return &lt;Button&gt;BUTTON&lt;/Button&gt;;&#125;;button.story = &#123; name: &#x27;Default&#x27;&#125;;export const primaryButton = () =&gt; &#123; return &lt;Button&gt;PRIMARY&lt;/Button&gt;;&#125;; 다음과 같은 결과가 나타났나요? 버튼의 theme 만들기우리는 버튼에 총 세가지 theme 을 만들어보도록 하겠습니다. primary secondary tertiary (3번째, 라는 의미를 가지고 있습니다) 우리는 Button 컴포넌트에 theme 이라는 props 를 받아오도록 설정을 해줄건데요, 여기서 theme 의 타입은 다음과 같이 설정하세요. 12/** 버튼의 생김새를 설정합니다. */theme: &#x27;primary&#x27; | &#x27;secondary&#x27; | &#x27;tertiary&#x27;; 각기 다른 theme 을 위하여 스타일을 작성 할 때에는 다음과 같이 스타일을 작성하고 12345const themes = &#123; primary: css``, secondary: css``, tertiary: css``&#125;; 컴포넌트쪽에서 사용 할 땐 다음과 같이 props 에서 받아온 theme 값을 사용하여 필요한 스타일을 뽑아쓰면 됩니다. 1css=&#123;[style, themes[theme]]&#125; css props 를 사용하면, 위 코드와 같이 배열 안에 여러가지 스타일을 넣으면 나중에 하나의 className 으로 조합해주어 스타일을 적용해줍니다. Button 컴포넌트의 theme 기능을 다음과 같이 구현해보세요. src&#x2F;Button&#x2F;Button.tsx 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** @jsx jsx */import &#123; jsx, css &#125; from &#x27;@emotion/core&#x27;;type ButtonProps = &#123; /** 버튼 안의 내용 */ children: React.ReactNode; /** 클릭했을 때 호출할 함수 */ onClick?: (e?: React.MouseEvent&lt;HTMLButtonElement&gt;) =&gt; void; /** 버튼의 생김새를 설정합니다. */ theme: &#x27;primary&#x27; | &#x27;secondary&#x27; | &#x27;tertiary&#x27;;&#125;;/** `Button` 컴포넌트는 어떠한 작업을 트리거 할 때 사용합니다. */const Button = (&#123; children, theme, onClick &#125;: ButtonProps) =&gt; &#123; return ( &lt;button css=&#123;[style, themes[theme]]&#125; onClick=&#123;onClick&#125;&gt; &#123;children&#125; &lt;/button&gt; );&#125;;Button.defaultProps = &#123; theme: &#x27;primary&#x27;&#125;;const style = css` outline: none; border: none; box-sizing: border-box; height: 2rem; font-size: 0.875rem; padding: 0 1rem; border-radius: 0.25rem; line-height: 1; font-weight: 600; display: inline-flex; align-items: center; justify-content: center; &amp;:focus &#123; box-shadow: 0px 0px 8px rgba(0, 0, 0, 0.2); &#125;`;const themes = &#123; primary: css` background: #20c997; color: white; &amp;:hover &#123; background: #38d9a9; &#125; &amp;:active &#123; background: #12b886; &#125; `, secondary: css` background: #e9ecef; color: #343a40; &amp;:hover &#123; background: #f1f3f5; &#125; &amp;:active &#123; background: #dee2e6; &#125; `, tertiary: css` background: none; color: #20c997; &amp;:hover &#123; background: #e6fcf5; &#125; &amp;:active &#123; background: #c3fae8; &#125; `&#125;;export default Button; 다 작성하셨으면, 스토리들도 새로 정의를 해주세요. src&#x2F;Button&#x2F;Button.stories.tsx 123456789101112131415161718192021222324252627import React from &#x27;react&#x27;;import Button from &#x27;./Button&#x27;;export default &#123; title: &#x27;components|Button&#x27;, component: Button&#125;;export const button = () =&gt; &#123; return &lt;Button&gt;BUTTON&lt;/Button&gt;;&#125;;button.story = &#123; name: &#x27;Default&#x27;&#125;;export const primaryButton = () =&gt; &#123; return &lt;Button&gt;PRIMARY&lt;/Button&gt;;&#125;;export const secondaryButton = () =&gt; &#123; return &lt;Button theme=&quot;secondary&quot;&gt;SECONDARY&lt;/Button&gt;;&#125;;export const tertiaryButton = () =&gt; &#123; return &lt;Button theme=&quot;tertiary&quot;&gt;TERTIARY&lt;/Button&gt;;&#125;; 스토리를 다 만들고나면 다음과 같이 여러 theme을 가진 버튼들이 보여질 것입니다. 버튼을 여러가지 크기로 보여주기이번엔 작은 버튼과 큰 버튼들을 만들 수 있게 해주는 size props 를 구현해보겠습니다. 방식은 우리가 기존에 theme props 를 구현한 방법과 매우 비슷합니다. 우리가 구현 할 사이즈는 small, medium, big 이며 기본 값을 medium으로 해주도록 하겠습니다. 다음과 같이 다양한 크기로 버튼을 보여주는 기능을 구현해보세요. src&#x2F;Button&#x2F;Button.tsx 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** @jsx jsx */import &#123; jsx, css &#125; from &#x27;@emotion/core&#x27;;type ButtonProps = &#123; /** 버튼 안의 내용 */ children: React.ReactNode; /** 클릭했을 때 호출할 함수 */ onClick?: (e?: React.MouseEvent&lt;HTMLButtonElement&gt;) =&gt; void; /** 버튼의 생김새를 설정합니다. */ theme: &#x27;primary&#x27; | &#x27;secondary&#x27; | &#x27;tertiary&#x27;; /** 버튼의 크기를 설정합니다 */ size: &#x27;small&#x27; | &#x27;medium&#x27; | &#x27;big&#x27;;&#125;;/** `Button` 컴포넌트는 어떠한 작업을 트리거 할 때 사용합니다. */const Button = (&#123;children, theme, size, onClick&#125;: ButtonProps) =&gt; &#123; return ( &lt;button css=&#123;[style, themes[theme], sizes[size]]&#125; onClick=&#123;onClick&#125;&gt; &#123;children&#125; &lt;/button&gt; );&#125;;Button.defaultProps = &#123; theme: &#x27;primary&#x27;, size: &#x27;medium&#x27;&#125;;const style = css` outline: none; border: none; box-sizing: border-box; height: 2rem; font-size: 0.875rem; padding: 0 1rem; border-radius: 0.25rem; line-height: 1; font-weight: 600; display: inline-flex; align-items: center; justify-content: center; &amp;:focus &#123; box-shadow: 0px 0px 8px rgba(0, 0, 0, 0.2); &#125;`;const themes = &#123; primary: css` background: #20c997; color: white; &amp;:hover &#123; background: #38d9a9; &#125; &amp;:active &#123; background: #12b886; &#125; `, secondary: css` background: #e9ecef; color: #343a40; &amp;:hover &#123; background: #f1f3f5; &#125; &amp;:active &#123; background: #dee2e6; &#125; `, tertiary: css` background: none; color: #20c997; &amp;:hover &#123; background: #e6fcf5; &#125; &amp;:active &#123; background: #c3fae8; &#125; `&#125;;const sizes = &#123; small: css` height: 1.75rem; font-size: 0.75rem; padding: 0 0.875rem; `, medium: css` height: 2.5rem; font-size: 1rem; padding: 0 1rem; `, big: css` height: 3rem; font-size: 1.125rem; padding: 0 1.5rem; `&#125;;export default Button; 이제 각 버튼 사이즈를 보여주는 스토리를 만들건데요, 그냥 크기별로 모두 무작정 나열만 하면 버튼이 붙어있는 상태로 나오기 때문에 보기 좋지 않으니까, 스토리에서도 emotion 으로 간단하게 스타일링을 해보세요. src&#x2F;Button&#x2F;Button.stories.tsx 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** @jsx jsx */import Button from &#x27;./Button&#x27;;import &#123; jsx, css &#125; from &#x27;@emotion/core&#x27;;export default &#123; title: &#x27;components|Button&#x27;, component: Button&#125;;export const button = () =&gt; &#123; return &lt;Button&gt;BUTTON&lt;/Button&gt;;&#125;;button.story = &#123; name: &#x27;Default&#x27;&#125;;export const primaryButton = () =&gt; &#123; return &lt;Button&gt;PRIMARY&lt;/Button&gt;;&#125;;export const secondaryButton = () =&gt; &#123; return &lt;Button theme=&quot;secondary&quot;&gt;SECONDARY&lt;/Button&gt;;&#125;;export const tertiaryButton = () =&gt; &#123; return &lt;Button theme=&quot;tertiary&quot;&gt;TERTIARY&lt;/Button&gt;;&#125;;const buttonWrapper = css` .description &#123; margin-bottom: 0.5rem; &#125; &amp; &gt; div + div &#123; margin-top: 2rem; &#125;`;export const sizes = () =&gt; &#123; return ( &lt;div css=&#123;buttonWrapper&#125;&gt; &lt;div&gt; &lt;div className=&quot;description&quot;&gt;Small&lt;/div&gt; &lt;Button size=&quot;small&quot;&gt;BUTTON&lt;/Button&gt; &lt;/div&gt; &lt;div&gt; &lt;div className=&quot;description&quot;&gt;Medium&lt;/div&gt; &lt;Button size=&quot;medium&quot;&gt;BUTTON&lt;/Button&gt; &lt;/div&gt; &lt;div&gt; &lt;div className=&quot;description&quot;&gt;Big&lt;/div&gt; &lt;Button size=&quot;big&quot;&gt;BUTTON&lt;/Button&gt; &lt;/div&gt; &lt;/div&gt; );&#125;; 이런 스토리가 잘 만들어졌나요? 비활성화된 버튼 고려하기이번에는 버튼이 비활성화됐을 때 다른 스타일을 주도록 컴포넌트를 수정해보겠습니다. 버튼을 비활성화하기 위해서 사용 할 disabled 라는 props 를 구현해보세요. 비활성화된 버튼을 스타일링 할 때에는 :disabled CSS Selector 를 사용하면 됩니다. 그리고 비활성화 됐을 땐 마우스를 올렸을 때 색상이 변하지 않도록 기존 :hover 를 :hover:enabled 로 변경하셔야합니다. src&#x2F;Button&#x2F;Button.tsx 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** @jsx jsx */import &#123; jsx, css &#125; from &#x27;@emotion/core&#x27;;type ButtonProps = &#123; /** 버튼 안의 내용 */ children: React.ReactNode; /** 클릭했을 때 호출할 함수 */ onClick?: (e?: React.MouseEvent&lt;HTMLButtonElement&gt;) =&gt; void; /** 버튼의 생김새를 설정합니다. */ theme: &#x27;primary&#x27; | &#x27;secondary&#x27; | &#x27;tertiary&#x27;; /** 버튼의 크기를 설정합니다 */ size: &#x27;small&#x27; | &#x27;medium&#x27; | &#x27;big&#x27;; /** 버튼을 비활성화 시킵니다. */ disabled?: boolean;&#125;;/** `Button` 컴포넌트는 어떠한 작업을 트리거 할 때 사용합니다. */const Button = (&#123; children, theme, size, disabled, onClick &#125;: ButtonProps) =&gt; &#123; return ( &lt;button css=&#123;[style, themes[theme], sizes[size]]&#125; disabled=&#123;disabled&#125; onClick=&#123;onClick&#125; &gt; &#123;children&#125; &lt;/button&gt; );&#125;;Button.defaultProps = &#123; theme: &#x27;primary&#x27;, size: &#x27;medium&#x27;&#125;;const style = css` ... &amp;:focus &#123; box-shadow: 0px 0px 8px rgba(0, 0, 0, 0.2); &#125; &amp;:disabled &#123; cursor: not-allowed; &#125;`;const themes = &#123; primary: css` background: #20c997; color: white; &amp;:hover:enabled &#123; background: #38d9a9; &#125; &amp;:active:enabled &#123; background: #12b886; &#125; &amp;:disabled &#123; background: #aed9cc; &#125; `, secondary: css` background: #e9ecef; color: #343a40; &amp;:hover:enabled &#123; background: #f1f3f5; &#125; &amp;:active:enabled &#123; background: #dee2e6; &#125; &amp;:disabled &#123; color: #c6d3e1; &#125; `, tertiary: css` background: none; color: #20c997; &amp;:hover:enabled &#123; background: #e6fcf5; &#125; &amp;:active:enabled &#123; background: #c3fae8; &#125; &amp;:disabled &#123; color: #bcd9d0; &#125; `&#125;;const sizes = &#123; ...&#125;;export default Button; … 은 생략된 코드를 의미합니다. disabled props를 구현하셨으면 버튼의 새로운 스토리도 구현을 해봅시다. src&#x2F;Button&#x2F;Button.stories.tsx 123456789101112131415export const disabled = () =&gt; &#123; return ( &lt;div css=&#123;buttonWrapper&#125;&gt; &lt;div&gt; &lt;Button disabled&gt;PRIMARY&lt;/Button&gt; &lt;/div&gt; &lt;div&gt; &lt;Button disabled theme=&quot;secondary&quot;&gt;SECONDARY&lt;/Button&gt; &lt;/div&gt; &lt;div&gt; &lt;Button disabled theme=&quot;tertiary&quot;&gt;TERTIARY&lt;/Button&gt; &lt;/div&gt; &lt;/div&gt; );&#125;; 비활성화된 버튼의 스토리도 한번 잘 만들어졌나 볼까요? width 구현하기마지막으로, width props를 구현해보겠습니다. 이 값을 통하여 버튼의 너비를 고정시킬 수 있습니다. 예를 들어서 텍스트 길이가 다른 두 버튼을 같은 너비로 보여주고 싶다던지, 또는 버튼이 전체영역을 차지하고 싶게 한다던지 할 때에는 버튼의 너비를 직접 정할 수 있어야 합니다. src&#x2F;Button&#x2F;Button.tsx 12345678910111213141516171819202122232425262728293031323334353637/** @jsx jsx */import &#123; jsx, css &#125; from &#x27;@emotion/core&#x27;;type ButtonProps = &#123; /** 버튼 안의 내용 */ children: React.ReactNode; /** 클릭했을 때 호출할 함수 */ onClick?: (e?: React.MouseEvent&lt;HTMLButtonElement&gt;) =&gt; void; /** 버튼의 생김새를 설정합니다. */ theme: &#x27;primary&#x27; | &#x27;secondary&#x27; | &#x27;tertiary&#x27;; /** 버튼의 크기를 설정합니다 */ size: &#x27;small&#x27; | &#x27;medium&#x27; | &#x27;big&#x27;; /** 버튼을 비활성화 시킵니다. */ disabled?: boolean; /** 버튼의 너비를 임의로 설정합니다. */ width?: string | number;&#125;;/** `Button` 컴포넌트는 어떠한 작업을 트리거 할 때 사용합니다. */const Button = (&#123; children, theme, size, disabled, width, onClick&#125;: ButtonProps) =&gt; &#123; return ( &lt;button css=&#123;[style, themes[theme], sizes[size], &#123; width &#125;]&#125; disabled=&#123;disabled&#125; onClick=&#123;onClick&#125; &gt; &#123;children&#125; &lt;/button&gt; );&#125;; emotion을 사용하면 { width }와 같이 객체 형태의 스타일도 css props 에 넣을 수 있습니다. width props도 구현이 끝났으면 커스텀 너비를 지정 한 스토리를 새로 만들어주세요. src&#x2F;Button&#x2F;Button.stories.tsx 123456789101112export const customSized = () =&gt; &#123; return ( &lt;div css=&#123;buttonWrapper&#125;&gt; &lt;div&gt; &lt;Button width=&quot;20rem&quot;&gt;CUSTOM WIDTH&lt;/Button&gt; &lt;/div&gt; &lt;div&gt; &lt;Button width=&quot;100%&quot;&gt;FULL WIDTH&lt;/Button&gt; &lt;/div&gt; &lt;/div&gt; );&#125;; 이제 Button 컴포넌트는 여기서 마무리하겠습니다! 디자인 시스템을 개발하기 시작 할 때, 너무 나중 일을 생각하면서 확장성을 과도하게 고려하는건 별로 일 수 있습니다. 시간이 너무 많이 들어가기 때문이거든요. 사람의 의지에 따라 다르긴 하겠지만 시작부터 너무 어렵고 시간이 많이 소비되면 지쳐버려서 디자인 시스템을 만든다는 의지 자체가 흐지부지하게 꺾여버릴 수 있습니다. 사용하지도 않을 스타일 때문에 시간이 허비되는건 좋지 않죠. 실제로 사용되는 스타일들을 위주로 컴포넌트를 최대한 간단하게 만들고 나중에 계속해서 개선해 나가는 방식이 더 좋습니다. 마무리 작업으로 Knobs 와 Actions 애드온을 사용해보세요. src&#x2F;Button&#x2F;Button.stories.tsx 123456789101112131415161718192021222324252627282930313233343536373839/** @jsx jsx */import Button from &#x27;./Button&#x27;;import &#123; jsx, css &#125; from &#x27;@emotion/core&#x27;;import &#123; withKnobs, text, boolean, select &#125; from &#x27;@storybook/addon-knobs&#x27;;import &#123; action &#125; from &#x27;@storybook/addon-actions&#x27;;export default &#123; title: &#x27;components|Button&#x27;, component: Button, decorators: [withKnobs]&#125;;export const button = () =&gt; &#123; const label = text(&#x27;children&#x27;, &#x27;BUTTON&#x27;); const size = select(&#x27;size&#x27;, [&#x27;small&#x27;, &#x27;medium&#x27;, &#x27;big&#x27;], &#x27;medium&#x27;); const theme = select( &#x27;theme&#x27;, [&#x27;primary&#x27;, &#x27;secondary&#x27;, &#x27;tertiary&#x27;], &#x27;primary&#x27; ); const disabled = boolean(&#x27;disabled&#x27;, false); const width = text(&#x27;width&#x27;, &#x27;&#x27;); return ( &lt;Button size=&#123;size&#125; theme=&#123;theme&#125; disabled=&#123;disabled&#125; width=&#123;width&#125; onClick=&#123;action(&#x27;onClick&#x27;)&#125; &gt; &#123;label&#125; &lt;/Button&gt; );&#125;;button.story = &#123; name: &#x27;Default&#x27;&#125;; Knobs 적용이 끝났으면 다음과 같이 Storybook 화면에서 버튼의 바로 속성을 커스터마이징하고 잘 리렌더링되는지 확인해보세요. 추가적으로, 버튼을 클릭했을 때 onClick 액션이 발생하는지도 확인해보세요. 수고하셨습니다! 버튼 컴포넌트의 개발이 끝났습니다. 어떤가요? 간단할 것 같은 버튼도 결코 쉽지 않죠? 버튼 컴포넌트의 경우 모양새가 다양하기 때문에 난이도가 꽤나 높습니다. 하지만, 이렇게 한번 해보고 나면, 나중에 다른 컴포넌트들에 배리에이션(variation)을 주는 작업을 수월하게 할 수 있게 될 것입니다. 4-2. ButtonGroup 만들기이 컴포넌트는 여러가지 Button 들을 함께 사용 할 때 레이아웃하는 작업을 도와줄 컴포넌트입니다. 이 강의에서는 강의 문서 작성 편의상 ButtonGroup 컴포넌트의 기능을 한꺼번에 구현하고, 그 다음에 스토리 파일을 작성합니다. 하지만 사실 실무에서는 컴포넌트를 보면서 작업하지 않고 한꺼번에 UI 관련 코드를 한번에 왕창 작성한 다음에 모든 기능이 성공적으로 이루어지는 일은 드뭅니다. 실제로 작업을 할 때에는 다음과 같은 프로세스로 개발을 하면 편합니다. 컴포넌트 파일 생성 props 정의 스토리 파일 생성 구현하고자 하는 기능을 스토리로 작성 컴포넌트에서 기능 구현 Storybook에서 잘 작동하는지 확인 그리고, 모든 기능이 구현 될 때 까지 4~6번을 반복하시면 됩니다. 그리고 Knobs를 적용하는 것은 모든 스토리 작성이 끝나고나서 하셔도 됩니다. src 안에 ButtonGroup 디렉터리를 만드시고, ButtonGroup.tsx 를 생성하여 다음과 같이 코드를 작성해보세요. src&#x2F;ButtonGroup&#x2F;ButtonGroup.tsx 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** @jsx jsx */import &#123; css, jsx &#125; from &#x27;@emotion/core&#x27;;export type ButtonGroupProps = &#123; /** 버튼을 보여줄 방향 */ direction: &#x27;row&#x27; | &#x27;column&#x27;; /** 버튼을 우측에 보여줍니다. */ rightAlign?: boolean; /** 버튼과 버튼사이의 간격을 설정합니다. */ gap: number | string; /** 버튼 그룹에서 보여줄 버튼들 */ children: React.ReactNode; /* 스타일 커스터마이징 하고싶을 때 사용 */ className?: string;&#125;;/** * 여러개의 `Button` 컴포넌트를 보여주고 싶거나, 버튼을 우측에 정렬하고 싶을 땐 `ButtonGroup` 컴포넌트를 사용하세요. */const ButtonGroup = (&#123; direction, rightAlign, children, gap, className&#125;: ButtonGroupProps) =&gt; &#123; return ( &lt;div css=&#123;[ &#123; display: &#x27;flex&#x27;, flexDirection: direction &#125;, gapStyle(direction, gap), rightAlign &amp;&amp; rightAlignStyle ]&#125; className=&#123;className&#125; &gt; &#123;children&#125; &lt;/div&gt; );&#125;;ButtonGroup.defaultProps = &#123; direction: &#x27;row&#x27;, gap: &#x27;0.5rem&#x27;&#125;;// direction 에 따라 margin-left 또는 margin-top 설정const gapStyle = (direction: &#x27;row&#x27; | &#x27;column&#x27;, gap: number | string) =&gt; &#123; const marginType = direction === &#x27;row&#x27; ? &#x27;marginLeft&#x27; : &#x27;marginTop&#x27;; return css(&#123; &#x27;button + button&#x27;: &#123; [marginType]: gap &#125; &#125;);&#125;;const rightAlignStyle = css` justify-content: flex-end;`;export default ButtonGroup; 그 다음에는, 이 컴포넌트를 위한 스토리 파일도 작성해봅시다. src&#x2F;ButtonGroup&#x2F;ButtonGroup.stories.tsx 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import React from &#x27;react&#x27;;import ButtonGroup from &#x27;./ButtonGroup&#x27;;import Button from &#x27;../Button/Button&#x27;;import &#123; withKnobs, text, radios, boolean &#125; from &#x27;@storybook/addon-knobs&#x27;;export default &#123; title: &#x27;components|ButtonGroup&#x27;, component: ButtonGroup, decorators: [withKnobs]&#125;;export const buttonGroup = () =&gt; &#123; const direction = radios( &#x27;direction&#x27;, &#123; Row: &#x27;row&#x27;, Column: &#x27;column&#x27; &#125;, &#x27;row&#x27; ); const rightAlign = boolean(&#x27;rightAlign&#x27;, false); const gap = text(&#x27;gap&#x27;, &#x27;0.5rem&#x27;); return ( &lt;ButtonGroup direction=&#123;direction&#125; rightAlign=&#123;rightAlign&#125; gap=&#123;gap&#125;&gt; &lt;Button theme=&quot;tertiary&quot;&gt;취소&lt;/Button&gt; &lt;Button&gt;확인&lt;/Button&gt; &lt;/ButtonGroup&gt; );&#125;;buttonGroup.story = &#123; name: &#x27;Default&#x27;&#125;;export const rightAlign = () =&gt; &#123; return ( &lt;ButtonGroup rightAlign&gt; &lt;Button theme=&quot;tertiary&quot;&gt;취소&lt;/Button&gt; &lt;Button&gt;확인&lt;/Button&gt; &lt;/ButtonGroup&gt; );&#125;;export const column = () =&gt; &#123; return ( &lt;ButtonGroup direction=&quot;column&quot;&gt; &lt;Button&gt;CLICK ME&lt;/Button&gt; &lt;Button&gt;CLICK ME&lt;/Button&gt; &lt;/ButtonGroup&gt; );&#125;;export const customGap = () =&gt; &#123; return ( &lt;ButtonGroup gap=&quot;1rem&quot;&gt; &lt;Button theme=&quot;tertiary&quot;&gt;취소&lt;/Button&gt; &lt;Button&gt;확인&lt;/Button&gt; &lt;/ButtonGroup&gt; );&#125;;export const customGapColumn = () =&gt; &#123; return ( &lt;ButtonGroup direction=&quot;column&quot; gap=&quot;1rem&quot;&gt; &lt;Button&gt;CLICK ME&lt;/Button&gt; &lt;Button&gt;CLICK ME&lt;/Button&gt; &lt;/ButtonGroup&gt; );&#125;; 스토리가 잘 만들어졌나요? 4-3. Icon 만들기이번에는 Icon이라는 컴포넌트를 만들어서 디자인 시스템 내에서 사용되는 아이콘을 관리하는 방법을 다뤄보겠습니다. 이번에 우리가 배울 아이콘 방식은 지금처럼 라이브러리를 만드는게 목적이 아니더라 하더라도, 일반 리액트 프로젝트에서도 이번에 배우는 방식대로 진행을 하시면 매우 유용합니다. 일반적으로, Icon 의 경우엔 디자이너가 만들어서 svg로 전달을 해주거나, iconmonstr 같은 웹서비스에서 검색하여 svg를 다운로드 받아서 사용 할 것입니다. 이 강의가 디자이너를 위한 강의는 아니니, 아이콘을 직접 그리진 않고 다운로드해서 이를 컴포넌트형태로 사용하는 방법을 다뤄보겠습니다. 다음 3가지 아이콘들을 다운로드 받으세요. 파일 이름을 우측에 괄호로 적혀있는 이름으로 저장하세요. https://iconmonstr.com/pencil-10-svg/ (pencil.svg) https://iconmonstr.com/x-mark-1-svg/ (exit.svg) https://iconmonstr.com/favorite-7-svg/ (heart.svg) 그 다음엔, src&#x2F;Icon&#x2F;svg 경로를 만들고, 방금 다운로드 받은 3가지 아이콘들을 그 안에 넣어주세요. 이제 컴포넌트에서 svg를 불러와서 사용할건데요, 우리는 img 태그를 사용하지 않고, svg 를 jsx 형태로 바로 렌더링 할 것입니다. 이렇게 하기 위해선 babel-plugin-named-asset-import 라는 babel 플러그인을 사용해야 합니다. create-react-app 을 사용해보신 분들이라면 SVG 를 컴포넌트 타입으로 불러올 수 있다는 것을 알고 계실 것입니다. 우리가 적용할 플러그인이 이와 동일한 플러그인입니다. 우선, 이 패키지를 설치하세요. 12$ yarn add --dev babel-plugin-named-asset-import# 또는 npm --save-dev babel-plugin-named-asset-import 그 다음에는 웹팩 설정의 babel-loader 부분에 방금 설치한 플러그인을 적용해주어야 합니다. .storybook 경로에 잇는 webpack.config.js를 열어서 다음과 같이 수정하세요. .storybook&#x2F;webpack.config.js 12345678910111213141516171819202122232425262728module.exports = (&#123; config, mode &#125;) =&gt; &#123; config.module.rules.push(&#123; test: /\\.(ts|tsx)$/, use: [ &#123; loader: require.resolve(&#x27;babel-loader&#x27;), options: &#123; presets: [[&#x27;react-app&#x27;, &#123; flow: false, typescript: true &#125;]], plugins: [ [ require.resolve(&#x27;babel-plugin-named-asset-import&#x27;), &#123; loaderMap: &#123; svg: &#123; ReactComponent: &#x27;@svgr/webpack?-svgo,+titleProp,+ref![path]&#x27; &#125; &#125; &#125; ] ] &#125; &#125;, require.resolve(&#x27;react-docgen-typescript-loader&#x27;) ] &#125;); config.resolve.extensions.push(&#x27;.ts&#x27;, &#x27;.tsx&#x27;); return config;&#125;; 위 코드는 CRA 의 webpack.config.js 에서 그대로 복사해온 코드입니다. 코드를 수정하셨으면, src&#x2F;typings.d.ts 파일을 열어서 &quot;.svg&quot; 에 대한 타입을 설정하세요. 이 설정을 통하여 TypeScript파일에서 svg를 불러올 때 컴포넌트 타입으로 인식 할 수 있습니다. src&#x2F;typing.d.ts 123456789101112declare module &#x27;*.mdx&#x27;;declare module &#x27;*.svg&#x27; &#123; import * as React from &#x27;react&#x27;; export const ReactComponent: React.FunctionComponent&lt;React.SVGProps&lt; SVGSVGElement &gt;&gt;; const src: string; export default src;&#125; svg를 불러와서 사용 할 준비가 끝났습니다. 여기까지 수정을 다 하셨으면 Storybook 서버를 한번 재시작해주세요. 그 다음에는 src&#x2F;Icon&#x2F;svg 경로에 index.ts 파일을 생성하시고 다음과 같이 코드를 작성해주세요. src&#x2F;Icon&#x2F;svg&#x2F;index.ts 123export &#123; ReactComponent as exit &#125; from &#x27;./exit.svg&#x27;;export &#123; ReactComponent as heart &#125; from &#x27;./heart.svg&#x27;;export &#123; ReactComponent as pencil &#125; from &#x27;./pencil.svg&#x27;; 코드를 위와 같이 작성하면, svg 를 컴포넌트 타입으로 불러와서 우리가 정해준 이름으로 바로 내보내줍니다. 이렇게 아이콘을 내보내주셨으면, src&#x2F;Icon&#x2F;Icon.tsx 파일을 만들어서 컴포넌트를 다음과 같이 작성해보세요. src&#x2F;Icon&#x2F;Icon.tsx 1234567891011121314151617181920212223242526272829303132333435/** @jsx jsx */import &#123; jsx &#125; from &#x27;@emotion/core&#x27;;import * as icons from &#x27;./svg&#x27;;type IconType = keyof typeof icons;export const iconTypes: IconType[] = Object.keys(icons) as any[]; // 스토리에서 불러오기 위함export type IconProps = &#123; /** 사용 할 아이콘 타입 */ icon: IconType; /** 아이콘 색상 */ color?: string; /** 아이콘 크기 */ size?: string | number; className?: string;&#125;;/** 아이콘을 보여주고 싶을 땐 `Icon` 컴포넌트를 사용하세요. * * 이 컴포넌트는 svg 형태로 아이콘을 보여주며, props 또는 스타일을 사용하여 아이콘의 색상과 크기를 정의 할 수 있습니다. * * 스타일로 모양새를 설정 할 때에는 `color`로 색상을 설정하고 `width`로 크기를 설정하세요. */const Icon = (&#123; icon, color, size, className &#125;: IconProps) =&gt; &#123; const SVGIcon = icons[icon]; return ( &lt;SVGIcon css=&#123;&#123; fill: color || &#x27;currentColor&#x27;, width: size, height: &#x27;auto&#x27; &#125;&#125; className=&#123;className&#125; /&gt; );&#125;;export default Icon; 아이콘들을 불러올 때, import * as icons from &#39;./svg&#39;; 라고 작성하여 svg&#x2F;index.ts 파일에서 내보내고 있는 모든 아이콘들을 icons 라는 하나의 객체로 불러왔습니다. 그리고 IconProps 를 설정하는 부분에서 IconType 이라는 타입을 만들어서 사용했는데요, keyof typeof icons의 의미는 icons 객체가 가지고 있는 key 들을 추출하여 타입으로 사용하겠다는 것 입니다. 그러면 해당 타입의 결과는 &quot;exit&quot; | &quot;heart&quot; | &quot;pencil&quot; 이 됩니다. 이제 이 컴포넌트를 위하여 스토리를 작성해봅시다. src&#x2F;Icon&#x2F;Icon.stories.tsx 123456789101112131415161718192021/** @jsx jsx */import &#123; jsx &#125; from &#x27;@emotion/core&#x27;;import Icon from &#x27;./Icon&#x27;;export default &#123; component: Icon, title: &#x27;components|Icon&#x27;&#125;;export const icon = () =&gt; &lt;Icon icon=&quot;heart&quot; /&gt;;icon.story = &#123; name: &#x27;Default&#x27;&#125;;export const customSize = () =&gt; &lt;Icon icon=&quot;heart&quot; size=&quot;4rem&quot; /&gt;;export const customColor = () =&gt; &lt;Icon icon=&quot;heart&quot; color=&quot;red&quot; /&gt;;export const customizedWithStyle = () =&gt; ( &lt;Icon icon=&quot;heart&quot; css=&#123;&#123; color: &#x27;red&#x27;, width: &#x27;4rem&#x27; &#125;&#125; /&gt;); 스토리가 잘 만들어졌나요? 이제 우리가 준비한 3가지 아이콘들을 모두 나열해보겠습니다. src&#x2F;Icon&#x2F;Icon.stories.tsx 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** @jsx jsx */import &#123; jsx, css &#125; from &#x27;@emotion/core&#x27;;import Icon, &#123; iconTypes &#125; from &#x27;./Icon&#x27;;export default &#123; component: Icon, title: &#x27;components|Icon&#x27;&#125;;export const icon = () =&gt; &lt;Icon icon=&quot;heart&quot; /&gt;;icon.story = &#123; name: &#x27;Default&#x27;&#125;;export const customSize = () =&gt; &lt;Icon icon=&quot;heart&quot; size=&quot;4rem&quot; /&gt;;export const customColor = () =&gt; &lt;Icon icon=&quot;heart&quot; color=&quot;red&quot; /&gt;;export const customizedWithStyle = () =&gt; ( &lt;Icon icon=&quot;heart&quot; css=&#123;&#123; color: &#x27;red&#x27;, width: &#x27;4rem&#x27; &#125;&#125; /&gt;);export const listOfIcons = () =&gt; &#123; return ( &lt;ul css=&#123;iconListStyle&#125;&gt; &#123;iconTypes.map(icon =&gt; ( &lt;li key=&#123;icon&#125;&gt; &lt;Icon icon=&#123;icon&#125; /&gt; &#123;icon&#125; &lt;/li&gt; ))&#125; &lt;/ul&gt; );&#125;;const iconListStyle = css` list-style: none; display: flex; flex-wrap: wrap; li &#123; box-sizing: border-box; width: 25%; padding: 1rem; display: flex; align-items: center; svg &#123; margin-right: 1rem; &#125; &#125;`; 이렇게 코드를 작성해주고 나면, 우리가 추가한 아이콘들이 모두 리스팅 될 것입니다. 만약 아이콘이 더 많아지게 된다면 다음과 같이 보여지게 되겠죠. Button에서 아이콘 고려하기이제 Button 컴포넌트에서 아이콘을 사용하는 상황을 고려해봅시다. 첫번째로 할 것은 아이콘과 텍스트가 함께 사용 될 때를 고려하는 것 입니다. svg 의 크기가 폰트사이즈와 동일하도록 width 를 1em 으로 설정해야합니다. svg 의 margin-right 를 1em 으로 설정해야 합니다. themes 부분에서 svg 의 fill 를 설정해야 합니다. Button 컴포넌트를 다음과 같이 수정해주세요. src&#x2F;Button&#x2F;Button.tsx 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** @jsx jsx */import &#123; jsx, css &#125; from &#x27;@emotion/core&#x27;;...const style = css` ... svg &#123; width: 1em; margin-right: 1em; &#125;`;const themes = &#123; primary: css` background: #20c997; color: white; svg &#123; fill: white; &#125; &amp;:hover:enabled &#123; background: #38d9a9; &#125; &amp;:active:enabled &#123; background: #12b886; &#125; &amp;:disabled &#123; background: #aed9cc; &#125; `, secondary: css` background: #e9ecef; color: #343a40; svg &#123; fill: #343a40; &#125; &amp;:hover:enabled &#123; background: #f1f3f5; &#125; &amp;:active:enabled &#123; background: #dee2e6; &#125; &amp;:disabled &#123; color: #c6d3e1; svg &#123; fill: #c6d3e1; &#125; &#125; `, tertiary: css` background: none; color: #20c997; svg &#123; fill: #20c997; &#125; &amp;:hover:enabled &#123; background: #e6fcf5; &#125; &amp;:active:enabled &#123; background: #c3fae8; &#125; &amp;:disabled &#123; color: #bcd9d0; svg &#123; fill: #bcd9d0; &#125; &#125; `&#125;;... 코드를 모두 수정하셨으면, Button의 스토리 파일에 withIcon 이라는 스토리를 만들어보세요. src&#x2F;Button&#x2F;Button.stories.tsx 123456789101112131415161718192021222324252627/** @jsx jsx */import Button from &#x27;./Button&#x27;;import &#123; jsx, css &#125; from &#x27;@emotion/core&#x27;;import &#123; withKnobs, text, boolean, select &#125; from &#x27;@storybook/addon-knobs&#x27;;import &#123; action &#125; from &#x27;@storybook/addon-actions&#x27;;import ButtonGroup from &#x27;../ButtonGroup/ButtonGroup&#x27;;import Icon from &#x27;../Icon/Icon&#x27;;...export const withIcon = () =&gt; &#123; return ( &lt;div&gt; &lt;ButtonGroup&gt; &lt;Button size=&quot;small&quot;&gt; &lt;Icon icon=&quot;heart&quot; /&gt; LIKE &lt;/Button&gt; &lt;Button&gt; &lt;Icon icon=&quot;heart&quot; /&gt; LIKE &lt;/Button&gt; &lt;Button size=&quot;big&quot;&gt; &lt;Icon icon=&quot;heart&quot; /&gt; LIKE &lt;/Button&gt; &lt;/ButtonGroup&gt; &lt;/div&gt; );&#125;; 버튼들을 보여주는 과정에서 우리가 이전에 만들었던 ButtonGroup 컴포넌트를 활용했습니다. 두번째로 할 것은, 아이콘만 보여주는 버튼을 만들 때를 고려하는 것 입니다. iconOnly 라는 props 를 설정하여 이 값이 true 가 되면 버튼의 모양을 원으로 만들어주도록 하겠습니다. src&#x2F;Button&#x2F;Button.tsx 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** @jsx jsx */import &#123; jsx, css &#125; from &#x27;@emotion/core&#x27;;type ButtonProps = &#123; /** 버튼 안의 내용 */ children: React.ReactNode; /** 클릭했을 때 호출할 함수 */ onClick?: (e?: React.MouseEvent&lt;HTMLButtonElement&gt;) =&gt; void; /** 버튼의 생김새를 설정합니다. */ theme: &#x27;primary&#x27; | &#x27;secondary&#x27; | &#x27;tertiary&#x27;; /** 버튼의 크기를 설정합니다. */ size: &#x27;small&#x27; | &#x27;medium&#x27; | &#x27;big&#x27;; /** 버튼을 비활성화 시킵니다. */ disabled?: boolean; /** 버튼의 너비를 임의로 설정합니다. */ width?: string | number; /** 버튼에서 아이콘만 보여줄 때 이 값을 `true`로 설정하세요. */ iconOnly?: boolean;&#125;;/** `Button` 컴포넌트는 어떠한 작업을 트리거 할 때 사용합니다. */const Button = (&#123; children, theme, size, disabled, width, iconOnly, onClick&#125;: ButtonProps) =&gt; &#123; return ( &lt;button css=&#123;[ style, themes[theme], sizes[size], &#123; width &#125;, iconOnly &amp;&amp; [iconOnlyStyle, iconOnlySizes[size]] ]&#125; disabled=&#123;disabled&#125; onClick=&#123;onClick&#125; &gt; &#123;children&#125; &lt;/button&gt; );&#125;;...const iconOnlyStyle = css` padding: 0; border-radius: 50%; svg &#123; margin: 0; &#125;`;const iconOnlySizes = &#123; small: css` width: 1.75rem; `, medium: css` width: 2.5rem; `, big: css` width: 3rem; `&#125;;export default Button; 수정을 다 하셨으면 아이콘만 보여주는 버튼들을 보여주는 스토리도 만들어보세요. src&#x2F;Button&#x2F;Button.stories.tsx 12345678910111213141516171819...export const iconOnly = () =&gt; &#123; return ( &lt;div&gt; &lt;ButtonGroup&gt; &lt;Button iconOnly size=&quot;small&quot;&gt; &lt;Icon icon=&quot;heart&quot; /&gt; &lt;/Button&gt; &lt;Button iconOnly&gt; &lt;Icon icon=&quot;heart&quot; /&gt; &lt;/Button&gt; &lt;Button iconOnly size=&quot;big&quot;&gt; &lt;Icon icon=&quot;heart&quot; /&gt; &lt;/Button&gt; &lt;/ButtonGroup&gt; &lt;/div&gt; );&#125;; 스토리가 잘 보여지고 있나요? 이제 Icon 을 위한 작업은 모두 끝났습니다! 4-4. Dialog 만들기Dialog 컴포넌트는 다음과 같이 어두운 레이어로 기존 화면을 가리고 흰색 박스를 중앙에 띄워서 원하는 정보를 보여주는 컴포넌트입니다. 이 컴포넌트는 우리가 이 강의에서 마지막으로 만들어볼 컴포넌트입니다. 우선, Dialog 의 틀부터 잡아줍시다. src&#x2F;Dialog 디렉터리를 만들고, Dialog.tsx 파일을 다음과 같이 작성해보세요. src&#x2F;Dialog&#x2F;Dialog.tsx 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** @jsx jsx */import &#123; Fragment &#125; from &#x27;react&#x27;;import &#123; css, jsx &#125; from &#x27;@emotion/core&#x27;;import ButtonGroup from &#x27;../ButtonGroup/ButtonGroup&#x27;;import Button from &#x27;../Button/Button&#x27;;export type DialogProps = &#123;&#125;;const Dialog = (props: DialogProps) =&gt; &#123; return ( &lt;Fragment&gt; &lt;div css=&#123;[fullscreen, darkLayer]&#125;&gt;&lt;/div&gt; &lt;div css=&#123;[fullscreen, whiteBoxWrapper]&#125;&gt; &lt;div css=&#123;whiteBox&#125;&gt; &lt;h3&gt;포스트 삭제&lt;/h3&gt; &lt;p&gt;포스트를 정말로 삭제하시겠습니까?&lt;/p&gt; &lt;ButtonGroup css=&#123;&#123; marginTop: &#x27;3rem&#x27; &#125;&#125; rightAlign&gt; &lt;Button theme=&quot;tertiary&quot;&gt;취소&lt;/Button&gt; &lt;Button&gt;삭제&lt;/Button&gt; &lt;/ButtonGroup&gt; &lt;/div&gt; &lt;/div&gt; &lt;/Fragment&gt; );&#125;;const fullscreen = css` position: fixed; top: 0; left: 0; width: 100%; height: 100%;`;const darkLayer = css` z-index: 10; background: rgba(0, 0, 0, 0.5);`;const whiteBoxWrapper = css` z-index: 15; display: flex; align-items: center; justify-content: center;`;const whiteBox = css` box-sizing: border-box; border-radius: 4px; width: 25rem; background: white; box-shadow: 0px 4px 8px 8px rgba(0, 0, 0, 0.05); padding: 2rem; h3 &#123; font-size: 1.5rem; color: #343a40; margin-top: 0; margin-bottom: 1rem; &#125; p &#123; font-size: 1.125rem; margin: 0; color: #868e96; &#125;`;export default Dialog; 이렇게 지금은 props 는 신경쓰지 않고 UI만 준비해주세요. 그 다음에는 이 컴포넌트를 위한 스토리 파일을 작성하세요. src&#x2F;Dialog&#x2F;Dialog.stories.tsx 123456789101112131415import React from &#x27;react&#x27;;import Dialog from &#x27;./Dialog&#x27;;export default &#123; title: &#x27;components|Dialog&#x27;, component: Dialog&#125;;export const dialog = () =&gt; &#123; return &lt;Dialog /&gt;;&#125;;dialog.story = &#123; name: &#x27;Default&#x27;&#125;; 이렇게 하고 나면 문제점이 한가지 있습니다. Docs 를 열었을 때 Docs 화면 자체를 다 가려버린다는 것 입니다. 이를 방지하기 위해선 docs 의 inlineStories 라는 파라미터를 false 로 설정하면 됩니다. src&#x2F;Dialog&#x2F;Dialog.stories.tsx 1234567891011121314151617181920import React from &#x27;react&#x27;;import Dialog from &#x27;./Dialog&#x27;;export default &#123; title: &#x27;components|Dialog&#x27;, component: Dialog, parameters: &#123; docs: &#123; inlineStories: false &#125; &#125;&#125;;export const dialog = () =&gt; &#123; return &lt;Dialog /&gt;;&#125;;dialog.story = &#123; name: &#x27;Default&#x27;&#125;; 수정하시면 Docs 부분에서 스토리를 보여줄 때 iframe 을 사용하게 되면서 컴포넌트가 영역 밖에 렌더링 되는 이슈가 해결 됩니다. 이제, 이 컴포넌트의 props 를 설정해봅시다. 우리는 Dialog 안에 보여지는 모든 UI 를 숨길 수 있도록 Dialog 를 설계 할 것입니다. 그리고 필요할 경우엔 Dialog 내부에서 보여지는 내용을 커스터마이징 할 수 있도록 children 이 존재한다면 이를 렌더링하도록 구현해보세요., 추가적으로, 버튼의 텍스트도 커스터마이징 할 수 있어야 하고, 필요할 땐 버튼을 하나만 보여주기도 해야 합니다. src&#x2F;Dialog&#x2F;Dialog.tsx 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** @jsx jsx */import &#123; Fragment &#125; from &#x27;react&#x27;;import &#123; css, jsx &#125; from &#x27;@emotion/core&#x27;;import ButtonGroup from &#x27;../ButtonGroup/ButtonGroup&#x27;;import Button from &#x27;../Button/Button&#x27;;export type DialogProps = &#123; visible: boolean; title?: string; description?: string; children?: React.ReactNode; hideButtons?: boolean; cancellable?: boolean; cancelText: string; confirmText: string; onCancel?: () =&gt; void; onConfirm?: () =&gt; void;&#125;;const Dialog = (&#123; visible, title, description, hideButtons, cancellable, cancelText, confirmText, children, onCancel, onConfirm&#125;: DialogProps) =&gt; &#123; if (!visible) return null; return ( &lt;Fragment&gt; &lt;div css=&#123;[fullscreen, darkLayer]&#125;&gt;&lt;/div&gt; &lt;div css=&#123;[fullscreen, whiteBoxWrapper]&#125;&gt; &lt;div css=&#123;whiteBox&#125;&gt; &#123;title &amp;&amp; &lt;h3&gt;&#123;title&#125;&lt;/h3&gt;&#125; &#123;description &amp;&amp; &lt;p&gt;&#123;description&#125;&lt;/p&gt;&#125; &#123;children&#125; &#123;!hideButtons &amp;&amp; ( &lt;ButtonGroup css=&#123;&#123; marginTop: &#x27;3rem&#x27; &#125;&#125; rightAlign&gt; &#123;cancellable &amp;&amp; ( &lt;Button theme=&quot;tertiary&quot; onClick=&#123;onCancel&#125;&gt; &#123;cancelText&#125; &lt;/Button&gt; )&#125; &lt;Button onClick=&#123;onConfirm&#125;&gt;&#123;confirmText&#125;&lt;/Button&gt; &lt;/ButtonGroup&gt; )&#125; &lt;/div&gt; &lt;/div&gt; &lt;/Fragment&gt; );&#125;;Dialog.defaultProps = &#123; cancelText: &#x27;취소&#x27;, confirmText: &#x27;확인&#x27;&#125;; 이제 이에 맞춰 새로운 스토리들도 작성하고, Knobs 설정도 해주세요. src&#x2F;Dialog&#x2F;Dialog.stories.tsx 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import React from &#x27;react&#x27;;import Dialog from &#x27;./Dialog&#x27;;import &#123; withKnobs, text, boolean &#125; from &#x27;@storybook/addon-knobs&#x27;;export default &#123; title: &#x27;components|Dialog&#x27;, component: Dialog, parameters: &#123; docs: &#123; inlineStories: false &#125; &#125;, decorators: [withKnobs]&#125;;export const dialog = () =&gt; &#123; const title = text(&#x27;title&#x27;, &#x27;결제 성공&#x27;); const description = text(&#x27;description&#x27;, &#x27;결제가 성공적으로 이루어졌습니다.&#x27;); const visible = boolean(&#x27;visible&#x27;, true); const confirmText = text(&#x27;confirmText&#x27;, &#x27;확인&#x27;); const cancelText = text(&#x27;cancelText&#x27;, &#x27;취소&#x27;); const cancellable = boolean(&#x27;cancellable&#x27;, false); return ( &lt;Dialog title=&#123;title&#125; description=&#123;description&#125; visible=&#123;visible&#125; confirmText=&#123;confirmText&#125; cancelText=&#123;cancelText&#125; cancellable=&#123;cancellable&#125; /&gt; );&#125;;dialog.story = &#123; name: &#x27;Default&#x27;&#125;;export const cancellable = () =&gt; &#123; return ( &lt;Dialog title=&quot;포스트 삭제&quot; description=&quot;포스트를 정말로 삭제하시겠습니까?&quot; visible=&#123;true&#125; confirmText=&quot;삭제&quot; cancellable /&gt; );&#125;;export const customContent = () =&gt; &#123; return ( &lt;Dialog visible=&#123;true&#125; hideButtons&gt; Custom Content &lt;/Dialog&gt; );&#125;; react-spring으로 트랜지션 구현하기이번에는 우리가 만든 Dialog 컴포넌트에 트랜지션 애니메이션을 구현해보겠습니다. 트랜지션 애니메이션을 구현하기 위하여, 그냥 css 의 transition 속성을 사용하거나, keyframe 을 사용하거나, 또는 react-transition-group이라는 라이브러리를 쓰셔도 됩니다. 여러분이 나중에 실제로 여러분의 컴포넌트를 만드실땐 무엇을 쓰시던지 상관 없는데, 이 튜토리얼에서는 react-spring 을 사용해보겠습니다. 이 라이브러리를 사용하면 Hooks 를 기반으로 더욱 수준 높은 애니메이션을 쉽게 구현 할 수 있습니다. react-spring 은 대부분의 상황엔 좋은 성능을 보여주지만, 스마트 TV 및 처럼 하드웨어 성능이 그렇게 좋지 못한 디바이스에서는 버벅임을 유발하기도 하니 이 점 주의하시길 바랍니다. 이 라이브러리를 우선 설치해주세요. 12$ yarn add --peer react-spring# 또는 npm install --save react-spring 이 라이브러리는 자체적으로 TypeScript 지원을 하주기 때문에 별도로 타입 설치를 하실 필요가 없습니다. 우리는, useTransition을 사용할 것입니다. 단순 애니메이션을 구현 할 때에는 useSpring을 사용하면 되지만, 애니메이션이 끝나고 화면에서 DOM을 아예 없애야 하는 상황엔 useTransition 을 씁니다. 이 라이브러리를 사용하기 위해선 useTransition 과 animated 를 Dialog 컴포넌트 에서 import 해주세요. 1import &#123; useTransition, animated &#125; from &#x27;react-spring&#x27;; 그 다음엔 컴포넌트에서 기존의 if (!visible) return null 을 지우시고, 다음과 같이 useTransition hook 을 사용해보세요. 1234567891011121314151617181920const fadeTransition = useTransition(visible, null, &#123; from: &#123; opacity: 0 &#125;, enter: &#123; opacity: 1 &#125;, leave: &#123; opacity: 0 &#125;&#125;);const slideUpTransition = useTransition(visible, null, &#123; from: &#123; transform: `translateY(200px) scale(0.8)`, opacity: 0 &#125;, enter: &#123; transform: `translateY(0px) scale(1)`, opacity: 1 &#125;, leave: &#123; transform: `translateY(200px) scale(0.8)`, opacity: 0 &#125;&#125;); 여기서 첫번째 파라미터는 배열일수도 있고, boolean일 수도 있습니다. useTransition으로 단순히 가시성을 설정 할 때에는 boolean 을 넣고, 배열의 변화함에 따라 트랜지션을 주며 추가&#x2F;제거를 하고 싶을 때는 배열을 넣습니다. 두번째 파라미터는 배열을 넣을 경우 다음과 같이 key 를 설정해주는 함수인데, 지금은 배열을 다루는게 아니니까 그냥 null 이라고 입력하시면 됩니다. 세번째 파라미터에서는 트랜지션을 설정하는데요, from은 시작할때, enter는 들어왔을 때, leave는 떠날 때 스타일을 설정합니다. 그 다음엔 컴포넌트에서 리턴하는 JSX 부분을 다음과 같이 고쳐보세요. 123456789101112131415161718192021222324252627282930313233343536373839return ( &lt;Fragment&gt; &#123;fadeTransition.map((&#123; item, key, props &#125;) =&gt; item ? ( &lt;animated.div css=&#123;[fullscreen, darkLayer]&#125; key=&#123;key&#125; style=&#123;props&#125; &gt;&lt;/animated.div&gt; ) : null )&#125; &#123;slideUpTransition.map((&#123; item, key, props &#125;) =&gt; item ? ( &lt;animated.div css=&#123;[fullscreen, whiteBoxWrapper]&#125; style=&#123;props&#125; key=&#123;key&#125; &gt; &lt;div css=&#123;whiteBox&#125;&gt; &#123;title &amp;&amp; &lt;h3&gt;&#123;title&#125;&lt;/h3&gt;&#125; &#123;description &amp;&amp; &lt;p&gt;&#123;description&#125;&lt;/p&gt;&#125; &#123;children&#125; &#123;!hideButtons &amp;&amp; ( &lt;ButtonGroup css=&#123;&#123; marginTop: &#x27;3rem&#x27; &#125;&#125; rightAlign&gt; &#123;cancellable &amp;&amp; ( &lt;Button theme=&quot;tertiary&quot; onClick=&#123;onCancel&#125;&gt; &#123;cancelText&#125; &lt;/Button&gt; )&#125; &lt;Button onClick=&#123;onConfirm&#125;&gt;&#123;confirmText&#125;&lt;/Button&gt; &lt;/ButtonGroup&gt; )&#125; &lt;/div&gt; &lt;/animated.div&gt; ) : null )&#125; &lt;/Fragment&gt;); 이제 트랜지션 구현이 끝났습니다! 저장을 하고 나면 다음과 같이 트랜지션이 보여질것입니다. react-spring 을 사용하면 configs를 조정하여 애니메이션을 세부적으로 설정 할 수 있습니다. configs 링크를 눌러 mass, tesnsion, friction 을 조정해보고 어떤 변화가 나타나는지 확인해보세요. 한번, slideUpTransition의 tension 을 조금 더 올리고, friction 을 낮춰보겠습니다. 123456789101112131415161718const slideUpTransition = useTransition(visible, null, &#123; from: &#123; transform: `translateY(200px) scale(0.8)`, opacity: 0 &#125;, enter: &#123; transform: `translateY(0px) scale(1)`, opacity: 1 &#125;, leave: &#123; transform: `translateY(200px) scale(0.8)`, opacity: 0 &#125;, config: &#123; tension: 200, friction: 15 &#125;&#125;); 트랜지션에 조금 더 통통 튀는듯한 느낌이 적용됐습니다. 최종 코드는 다음과 같습니다. 혹시 위 코드 조각으로 구현이 제대로 안됐다면 다음 코드를 확인하고 어떤 부분이 잘못됐는지 확인해보세요. src&#x2F;Dialog&#x2F;Dialog.tsx 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146/** @jsx jsx */import &#123; Fragment &#125; from &#x27;react&#x27;;import &#123; css, jsx &#125; from &#x27;@emotion/core&#x27;;import ButtonGroup from &#x27;../ButtonGroup/ButtonGroup&#x27;;import Button from &#x27;../Button/Button&#x27;;import &#123; useTransition, animated &#125; from &#x27;react-spring&#x27;;export type DialogProps = &#123; visible: boolean; title?: string; description?: string; children?: React.ReactNode; hideButtons?: boolean; cancellable?: boolean; cancelText: string; confirmText: string; onCancel?: () =&gt; void; onConfirm?: () =&gt; void;&#125;;const Dialog = (&#123; visible, title, description, hideButtons, cancellable, cancelText, confirmText, children, onCancel, onConfirm&#125;: DialogProps) =&gt; &#123; const fadeTransition = useTransition(visible, null, &#123; from: &#123; opacity: 0 &#125;, enter: &#123; opacity: 1 &#125;, leave: &#123; opacity: 0 &#125; &#125;); const slideUpTransition = useTransition(visible, null, &#123; from: &#123; transform: `translateY(200px) scale(0.8)`, opacity: 0 &#125;, enter: &#123; transform: `translateY(0px) scale(1)`, opacity: 1 &#125;, leave: &#123; transform: `translateY(200px) scale(0.8)`, opacity: 0 &#125;, config: &#123; tension: 200, friction: 15 &#125; &#125;); return ( &lt;Fragment&gt; &#123;fadeTransition.map((&#123; item, key, props &#125;) =&gt; item ? ( &lt;animated.div css=&#123;[fullscreen, darkLayer]&#125; key=&#123;key&#125; style=&#123;props&#125; &gt;&lt;/animated.div&gt; ) : null )&#125; &#123;slideUpTransition.map((&#123; item, key, props &#125;) =&gt; item ? ( &lt;animated.div css=&#123;[fullscreen, whiteBoxWrapper]&#125; style=&#123;props&#125; key=&#123;key&#125; &gt; &lt;div css=&#123;whiteBox&#125;&gt; &#123;title &amp;&amp; &lt;h3&gt;&#123;title&#125;&lt;/h3&gt;&#125; &#123;description &amp;&amp; &lt;p&gt;&#123;description&#125;&lt;/p&gt;&#125; &#123;children&#125; &#123;!hideButtons &amp;&amp; ( &lt;ButtonGroup css=&#123;&#123; marginTop: &#x27;3rem&#x27; &#125;&#125; rightAlign&gt; &#123;cancellable &amp;&amp; ( &lt;Button theme=&quot;tertiary&quot; onClick=&#123;onCancel&#125;&gt; &#123;cancelText&#125; &lt;/Button&gt; )&#125; &lt;Button onClick=&#123;onConfirm&#125;&gt;&#123;confirmText&#125;&lt;/Button&gt; &lt;/ButtonGroup&gt; )&#125; &lt;/div&gt; &lt;/animated.div&gt; ) : null )&#125; &lt;/Fragment&gt; );&#125;;Dialog.defaultProps = &#123; cancelText: &#x27;취소&#x27;, confirmText: &#x27;확인&#x27;&#125;;const fullscreen = css` position: fixed; top: 0; left: 0; width: 100%; height: 100%;`;const darkLayer = css` z-index: 10; background: rgba(0, 0, 0, 0.5);`;const whiteBoxWrapper = css` z-index: 15; display: flex; align-items: center; justify-content: center;`;const whiteBox = css` box-sizing: border-box; border-radius: 4px; width: 25rem; background: white; box-shadow: 0px 4px 8px 8px rgba(0, 0, 0, 0.05); padding: 2rem; h3 &#123; font-size: 1.5rem; color: #343a40; margin-top: 0; margin-bottom: 1rem; &#125; p &#123; font-size: 1.125rem; margin: 0; color: #868e96; &#125;`;export default Dialog; 이제 우리 디자인 시스템의 컴포넌트 개발이 끝났습니다! 물론 이것으로 디자인 시스템이 완성된다는 것은 아닙니다. 당연히, Typography 또는 Color 에 대한 문서도 MDX로 작성을 해주고, 더 댜앙한 컴포넌트를 만들어주어야 하겠죠. 우리가 이렇게 컴포넌트를 만든 것 처럼 하나씩 하나씩 채워가면 멋진 시스템이 구축 될 것입니다. 가장 중요한건 미루지 않고, 꾸준히 준비해나가는 것 입니다. 이제 우리가 만든 컴포넌트들을 다른 프로젝트에서 설치하여 불러와서 사용 할 수 있도록 npm에 등록하는 방법을 배워보도록 하겠습니다! 참조 https://velog.io/@velopert/create-your-own-design-system-with-storybook","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"SPA","slug":"Frontend/SPA","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/"},{"name":"React.js","slug":"Frontend/SPA/React-js","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/React-js/"}],"tags":[{"name":"spa","slug":"spa","permalink":"https://woonyzzang.github.com/tags/spa/"},{"name":"test","slug":"test","permalink":"https://woonyzzang.github.com/tags/test/"},{"name":"storybook","slug":"storybook","permalink":"https://woonyzzang.github.com/tags/storybook/"}]},{"title":"React.js Storybook Typescript Component Props","slug":"reactjs-storybook-typescript-component-props","date":"2020-03-16T15:11:58.000Z","updated":"2024-06-07T09:27:28.362Z","comments":true,"path":"2020/03/17/reactjs-storybook-typescript-component-props/","permalink":"https://woonyzzang.github.com/2020/03/17/reactjs-storybook-typescript-component-props/","excerpt":"","text":"Storybook 프로젝트에서 TypeScript로 컴포넌트의 props 문서화 편하게 하기TypeScript 를 사용하면 JavaScript의 불편함을 해결해줄 수 있고, IDE를 더욱 적극적으로 활용 할 수 있게 해줍니다. 특히, 리액트 컴포넌트를 TypeScript 로 작성하면, PropTypes 를 완전히 대체 할 수 있고 훨씬 유용하고 편합니다. 아직 TypeScript 를 사용해본적이 없다면, 타입스크립트 기초 연습 블로그 포스트를 한번 훑어보는 것을 권장드립니다. TypeScript를 완벽하게 숙지하고 있지 않아도, 이 강의를 진행하는 것에는 큰 지장은 없습니다. 한번 그냥 따라해보세요. 사실 TypeScript 별거 없습니다. TypeScript 환경 설정자, 우리가 만든 Storybook 프로젝트에 TypeScript 환경 설정을 해봅시다! 우선 다음 패키지들을 설치해주세요. 12yarn add --dev babel-preset-react-app react-docgen-typescript-loader typescript# 또는 npm install --save-dev babel-preset-react-app react-docgen-typescript-loader typescript babel-preset-react-app는 create-react-app 에서 사용하는 babel preset 과 동일합니다. TypeScript를 적용 할 때 우리는 babel-loader 를 사용 할 것입니다. 참고로 babel-loader는 Storybook 프로젝트에 이미 설치가 되어있습니다. react-docgen-typescript-loader는 컴포넌트의 props 에서 사용된 TypeScript 타입들을 추출하여 문서로 만들어주는 도구입니다. 우리가 이전에 PropTypes 를 작성하여 DocsPage 에서 보여줬었던 것 처럼 말이지요. typescript는 프로젝트에서 TypeScript를 사용하기 위하여 필수적으로 설치해야하는 패키지입니다. 설치하고 나서 프로젝트 루트 디렉터리에 tsconfig.json 파일을 작성해주세요. tsconfig.json 12345678910111213141516171819&#123; &quot;compilerOptions&quot;: &#123; &quot;target&quot;: &quot;es5&quot;, &quot;lib&quot;: [&quot;dom&quot;, &quot;dom.iterable&quot;, &quot;esnext&quot;], &quot;allowJs&quot;: true, &quot;skipLibCheck&quot;: true, &quot;esModuleInterop&quot;: true, &quot;allowSyntheticDefaultImports&quot;: true, &quot;strict&quot;: true, &quot;forceConsistentCasingInFileNames&quot;: true, &quot;module&quot;: &quot;esnext&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;resolveJsonModule&quot;: true, &quot;isolatedModules&quot;: true, &quot;noEmit&quot;: true, &quot;jsx&quot;: &quot;react&quot; &#125;, &quot;include&quot;: [&quot;src&quot;]&#125; tsconfig.json은 TypeScript 컴파일러의 환경설정을 정의하는 파일입니다. 위 설정은 CRA의 TypeScript 템플릿으로 새 프로젝트를 만들었을 때 사용하는 tsconfig.json 와 동일합니다. 이제 webpack 설정을 커스터마이징 해 주어야 합니다. .storybook 경로에 webpack.config.js 파일을 생성하면 Storybook의 기본 webpack 설정을 커스터마이징하여 사용 할 수 있습니다. (참고 링크) .storybook 경로에 webpack.config.js 파일을 만들어서 다음과 같이 코드를 작성해주세요. .storybook&#x2F;webpack.config.js 12345678910111213141516module.exports = (&#123;config, mode&#125;) =&gt; &#123; config.module.rules.push(&#123; test: /\\.(ts|tsx)$/, use: [ &#123; loader: require.resolve(&#x27;babel-loader&#x27;), options: &#123; presets: [[&#x27;react-app&#x27;, &#123; flow: false, typescript: true &#125;]] &#125; &#125;, require.resolve(&#x27;react-docgen-typescript-loader&#x27;) ] &#125;); config.resolve.extensions.push(&#x27;.ts&#x27;, &#x27;.tsx&#x27;); return config;&#125;; ts 및 tsx 확장자에 대하여 babel-loader 와 react-docgen-typescript-loader 를 사용하도록 설정해주었습니다. 그 다음에는 .storybook&#x2F;config.js 파일을 열어서 tsx 파일도 Storybook에서 처리하도록 코드를 수정해주세요. .storybook&#x2F;config.js 123import &#123; configure &#125; from &#x27;@storybook/react&#x27;;configure(require.context(&#x27;../src&#x27;, true, /\\.stories\\.(js|mdx|tsx)$/), module); 마지막으로, src 디렉터리에 typings.d.ts 파일을 만들어서 다음과 같이 입력을 해주세요. src&#x2F;typings.d.ts 1declare module &#x27;*.mdx&#x27;; 이 파일의 용도는 우리가 추후 ts 파일에서 mdx 확장자로 이루어진 파일을 불러오게 될 때 모듈이 없다는 에러를 방지하는 것 입니다. 이제 TypeScript 환경 설정이 끝났습니다. @storybook&#x2F;preset-typescript 를 사용하면 이 작업을 더욱 간소화 할 수도 있습니다. 하지만, babel-loader를 사용하고자 한다면 preset 기능을 쓸 수는 없습니다. 우리는 나중에 아이콘을 리액트 컴포넌트 형태로 사용하기 위하여 babel을 사용 할 것이므로, 직접 TypeScript환경을 직접 설정하는 방식으로 진행하겠습니다. TypeScript로 컴포넌트 작성하기이제, 기존에 작성했던 Hello.js 컴포넌트의 파일이름을 Hello.tsx 로 변경해주세요. TypeScript를 사용하는 리액트 컴포넌트의 확장자는 .tsx 입니다. 그리고 나서 컴포넌트 파일에서 PropTypes 를 제거하고 TypeScript 로 props 의 타입을 명시해주겠습니다. src&#x2F;Hello&#x2F;Hello.tsx 123456789101112131415161718192021222324252627282930313233343536import React from &#x27;react&#x27;;type HelloProps = &#123; /** 보여주고 싶은 이름 */ name: string; /** 이 값을 `true` 로 설정하면 h1 태그로 렌더링합니다. */ big?: boolean; /** Hello 버튼 누를 때 호출 할 함수 */ onHello?: () =&gt; void; /** Bye 버튼 누를 때 호출 할 함수 */ onBye?: () =&gt; void;&#125;;/** * 안녕하세요 라고 보여주고 싶을 땐 `Hello` 컴포넌트를 사용하세요. * * - `big` 값을 `true`로 설정하면 **크게** 나타납니다. * - `onHello` 와 `onBye` props로 설정하여 버튼이 클릭했을 때 호출 할 함수를 지정 할 수 있습니다. */const Hello = (&#123;name, big, onHello, onBye&#125;: HelloProps) =&gt; &#123; return ( &lt;div&gt; &#123;(big) ? &lt;h1&gt;안녕하세요, &#123;name&#125;!&lt;/h1&gt; : &lt;p&gt;안녕하세요, &#123;name&#125;!&lt;/p&gt;&#125; &lt;div&gt; &lt;button onClick=&#123;onHello&#125;&gt;Hello&lt;/button&gt; &lt;button onClick=&#123;onBye&#125;&gt;Bye&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; );&#125;;Hello.defaultProps = &#123; big: false&#125;;export default Hello; TypeScript를 사용하여 컴포넌트의 props 의 타입을 선언 할 때에는 Type Alias 또는 Interface 를 사용합니다. props 의 타입을 명시 할 때 둘 중 아무거나 써도 상관 없습니다. 여기서 ? 표시는 해당 props 는 생략을 해도 된다는 것을 의미합니다. 타입을 선언하고 나서는 props 가 해당 타입이란것을 명시하기 위하여 파라미터쪽에 다음과 같이 입력하면 됩니다. 123const Hello = (&#123; name, big, onHello, onBye &#125;: HelloProps) =&gt; &#123; ...&#125;; 그 다음엔, Hello.stories.js 파일의 이름을 Hello.stories.tsx 로 변경해주세요. 파일 내용은 바꿀 필요 없습니다. 이제, Storybook을 종료 후 다시 켜주세요. Storybook 서버가 구동 될 때 오류가 나지 않았고, Storybook 페이지가 제대로 보여지는 것을 확인해보세요. 여기까지 잘 따라오셨으면, 이제 여러분들은 Storybook을 활용하는 기본적인 방법을 모두 숙지하신 겁니다. 이제 디자인 시스템을 만들어볼 준비가 끝났습니다. 다음 강의, 확인해주세요~ 참조 https://velog.io/@velopert/storybook-typescript-props-documentation","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"SPA","slug":"Frontend/SPA","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/"},{"name":"React.js","slug":"Frontend/SPA/React-js","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/React-js/"}],"tags":[{"name":"spa","slug":"spa","permalink":"https://woonyzzang.github.com/tags/spa/"},{"name":"test","slug":"test","permalink":"https://woonyzzang.github.com/tags/test/"},{"name":"storybook","slug":"storybook","permalink":"https://woonyzzang.github.com/tags/storybook/"}]},{"title":"React.js Storybook Addon","slug":"reactjs-storybook-addon","date":"2020-03-16T14:59:46.000Z","updated":"2024-06-07T09:27:28.360Z","comments":true,"path":"2020/03/16/reactjs-storybook-addon/","permalink":"https://woonyzzang.github.com/2020/03/16/reactjs-storybook-addon/","excerpt":"","text":"Storybook을 다양한 Addon과 함께 활용해보면서 사용법 정복하기 storybook addon actions addon knobs addon docs 2. 스토리북, 시작하기.Storybook을 사용할 때 create-react-app으로 만든 프로젝트에서 Storybook 설정을 하여 사용할 수도 있고 아예 새로운 Storybook 전용 프로젝트를 만들어서 사용할 수도 있습니다. 우리는 먼저 Storybook 전용 프로젝트를 만드는 방법을 배우고 나중에 CRA로 만든 프로젝트에 Storybook을 사용하는 방법도 알아보겠습니다. 이 프로젝트에서 사용중인 코드는 이 링크에서 확인할 수 있습니다. 프로젝트를 생성하기 위하여 다음 명령어를 입력해주세요. 12345$ mkdir storybook-tutorial$ cd storybook-tutorial$ yarn init -y # 또는 npm init -y$ npx -p @storybook/cli sb init --type react 이 강의에서는 주로 yarn을 사용하며, 이를 사용하는 것을 권장드립니다. 설치되어 있지 않다면 이 링크를 참고하여 설치를 하세요. (npm만 사용해도 큰 지장은 없습니다. ) npx는 글로벌 패키지 설치 없이 특정 명령어를 바로 실행 할 수 있게 해주는 도구이며 npm 5.2.0 이상 버전에서 사용할 수 있습니다. 작동하지 않는다면 npm -v 명령어를 입력하여 버전을 확인해보시고 새 버전으로 업데이트 해주세요. 명령어를 실행하시고 난 다음에는 yarn storybook 또는 npm run storybook 명령어를 실행하시고 나면 Storybook 서버가 가동됩니다. 스토리 경로 바꾸기현재 디렉터리 구조가 다음과 같이 구성이 되어있습니다.(v5.3 에서는 기본적으로 stories 디렉토리가 생성되지 않습니다.) 한번 이 구조를 좀 변경해보도록 하겠습니다. 우리는 src 라는 디렉터리를 만들어서 그 안에서 컴포넌트 코드 및 스토리들의 코드를 관리할 것입니다. .storybook 디렉토리를 열으시면 main.js 라는 파일에 다음과 같이 적혀있습니다. .storybook&#x2F;main.js 1234module.exports = &#123; stories: [&#x27;../stories/**/*.stories.js&#x27;], addons: [&#x27;@storybook/addon-actions&#x27;, &#x27;@storybook/addon-links&#x27;]&#125;; 여기서, ../stories 부분이 어디서부터 스토리들을 불러올 지 알려주는 경로인데요, 이 경로를 ../src 로 변경해보세요. 1234module.exports = &#123; stories: [&#x27;../src/**/*.stories.js&#x27;], addons: [&#x27;@storybook/addon-actions&#x27;, &#x27;@storybook/addon-links&#x27;]&#125;; 이제 Storybook 서버를 종료 (터미널에서 Ctrl + C) 후 다시 시작해주세요. 첫번째 컴포넌트와 첫번째 스토리 만들기자, 우리의 첫번째 컴포넌트 Hello를 만들어보겠습니다. src 경로에 Hello 디렉터리를 만들고, 그 안에 Hello.js 파일을 다음과 같이 작성해보세요. 참고로, 우리는 먼저 JavaScript만을 사용하여 스토리북을 활용해보고 나중에 TypeScript를 적용해서 쓰는 방법도 다뤄보도록 하겠습니다. src&#x2F;Hello&#x2F;Hello.js 1234567891011import React from &#x27;react&#x27;;const Hello = (&#123;name, big&#125;) =&gt; &#123; if (big) &#123; return &lt;h1&gt;안녕하세요, &#123;name&#125;!&lt;/h1&gt;; &#125; return &lt;p&gt;안녕하세요, &#123;name&#125;!&lt;/p&gt;;&#125;;export default Hello; big 이라는 props 가 true 로 주어지면 h1 태그를 렌더링하고 그렇지 않으면 p 태그를 렌더링하는 컴포넌트를 만들어보았습니다. 이제, 스토리를 만들어봅시다. 스토리를 작성 할 때에는 .stories.js 확장자로 작성하시면 됩니다. Storybook v5.2 부터는 Component Story Format (CSF) 형식을 사용하여 문서를 작성합니다. (현재 기준 최신 버전 v5.2.3) 옛날에 스토리북을 사용해보셨거나, 또는 구글에 검색해보면 많은 가이드들이 storiesOf 라는 API 를 사용합니다. 예시 코드를 잠깐 확인해볼까요? 1234567891011121314import React from &#x27;react&#x27;;import &#123; storiesOf &#125; from &#x27;@storybook/react&#x27;;import &#123; action &#125; from &#x27;@storybook/addon-actions&#x27;;import Button from &#x27;../components/Button&#x27;;storiesOf(&#x27;Button&#x27;, module) .add(&#x27;with text&#x27;, () =&gt; ( &lt;Button onClick=&#123;action(&#x27;clicked&#x27;)&#125;&gt;Hello Button&lt;/Button&gt; )) .add(&#x27;with some emoji&#x27;, () =&gt; ( &lt;Button onClick=&#123;action(&#x27;clicked&#x27;)&#125;&gt; &lt;span role=&quot;img&quot; aria-label=&quot;so cool&quot;&gt;😀 😎 👍 💯&lt;/span&gt; &lt;/Button&gt; )); 이 방식이 아직도 작동하고있기 때문에 이 방식이 deprecated 된 것은 아닙니다. 다만, 최신버전의 Storybook에서는 이 API 말고 CSF 형식으로 작성되는 것이 권장됩니다. 왜냐구요? 그냥 훨씬 깔끔하고 편합니다! CSF를 사용할 땐 export default &#123; &#125; 코드를 사용하여 어떤 컴포넌트의 문서인지, 그리고 또 어떤 설정을 적용 할 건지 정의합니다. 그리고 export const storyName = ... 코드를 사용하여 새로운 스토리를 만듭니다. src&#x2F;Hello 경로에 Hello.stories.js 파일을 생성하여 다음과 같이 코드를 작성해보세요. src&#x2F;Hello&#x2F;Hello.stories.js 12345678910import React from &#x27;react&#x27;;import Hello from &#x27;./Hello&#x27;;export default &#123; title: &#x27;components|basic/Hello&#x27;, // 스토리북에서 보여질 그룹과 경로를 명시 component: Hello // 어떤 컴포넌트를 문서화 할지 명시&#125;;export const standard = () =&gt; &lt;Hello name=&quot;Storybook&quot; /&gt;;export const big = () =&gt; &lt;Hello name=&quot;Storybook&quot; big /&gt;; 그러면, Storybook에 다음과 같이 스토리가 보여질 것입니다. export default 를 통하여 객체를 내보낼 때, title 값은 스토리북에서 보여지는 그룹과 경로를 명시합니다. 위 Hello 컴포넌트의 경우 그룹은 COMPONENTS 가 되어있고, 경로는 basic으로 설정되었죠. 이렇게 스토리를 만들고, 각 스토리를 브라우저 상에서 확인 하는 것은 StoryBook의 가장 기본적인 기능입니다. 여기에 Storybook의 애드온(Addon)들을 적용하면 더욱 다양하고 편리한 기능들을 붙여줄 수 있습니다. 2-1. Knobs 애드온 적용하기우리가 첫번째로 다뤄볼 애드온은 Knobs 입니다. Knobs 애드온은 컴포넌트의 props 를 스토리북 화면에서 바꿔서 바로 반영시켜줄 수 있는 애드온입니다. 먼저 애드온을 설치해주세요. 12$ yarn add --dev @storybook/addon-knobs# 또는 npm install --save-dev @storybook/addon-knobs 그 다음에는, .storybook 경로에 있는 main.js 파일을 열어서 다음 코드를 추가해주세요. .storybook&#x2F;main.js 1234module.exports = &#123; stories: [&#x27;../src/**/*.stories.js&#x27;], addons: [&#x27;@storybook/addon-actions&#x27;, &#x27;@storybook/addon-links&#x27;, &#x27;@storybook/addon-knobs/register&#x27;]&#125;; 이제 우리가 만들었던 Hello 스토리에 withKnobs라는 함수를 사용하여 해당 애드온을 적용하면 됩니다. Knobs 공식 문서에서는 다음과 같이 사용 하라고 안내하고 있습니다. 12345678import &#123; storiesOf &#125; from &#x27;@storybook/react&#x27;;import &#123; withKnobs, text, boolean, number &#125; from &#x27;@storybook/addon-knobs&#x27;;const stories = storiesOf(&#x27;Storybook Knobs&#x27;, module);// Add the `withKnobs` decorator to add knobs support to your stories.// You can also configure `withKnobs` as a global decorator.stories.addDecorator(withKnobs); 애드온으로 사용하는 withKnob과 같은 함수는 데코레이터(decorator) 라고 부릅니다. 위 코드 포맷은 예전의 방식인 storiesOf API 를 사용하는 형태입니다. 만약에 CSF를 사용한다면 addDecorator를 사용하는 대신에 export default로 내보내는 객체 안에 decorators 라는 배열을 만들어서 그 안에 withKnobs 를 넣어주시면 됩니다. 다음과 같이 말이죠! src&#x2F;Hello&#x2F;Hello.stories.js 123456789101112import React from &#x27;react&#x27;;import Hello from &#x27;./Hello&#x27;;import &#123; withKnobs &#125; from &#x27;@storybook/addon-knobs&#x27;;export default &#123; title: &#x27;components|basic/Hello&#x27;, // 스토리북에서 보여질 그룹과 경로를 명시 component: Hello, // 어떤 컴포넌트를 문서화 할지 명시 decorators: [withKnobs] // 애드온 적용&#125;;export const standard = () =&gt; &lt;Hello name=&quot;Storybook&quot; /&gt;;export const big = () =&gt; &lt;Hello name=&quot;Storybook&quot; big /&gt;; 그 다음에는, default 라는 이름으로 Knobs 를 사용하는 새로운 스토리를 만들어보겠습니다. 기본적으로는, 스토리를 만들 때 export const를 사용하여 default 라는 이름으로 내보낼 수 없습니다. 키워드가 충돌되기 때문이죠. 그 대신에, 스토리를 만들고, 해당 스토리의 멤버 변수로 story 객체를 설정하면 이름을 변경 할 수 있습니다. src&#x2F;Hello&#x2F;Hello.stories.js 12345678910111213141516171819202122232425import React from &#x27;react&#x27;;import &#123; withKnobs, text, boolean &#125; from &#x27;@storybook/addon-knobs&#x27;;import Hello from &#x27;./Hello&#x27;;export const hello = () =&gt; &#123; // knobs 만들기 const big = boolean(&#x27;big&#x27;, false); const name = text(&#x27;name&#x27;, &#x27;Storybook&#x27;); return &lt;Hello name=&#123;name&#125; big=&#123;big&#125; /&gt;;&#125;;hello.story = &#123; name: &#x27;Default&#x27;&#125;;export const standard = () =&gt; &lt;Hello name=&quot;Storybook&quot; /&gt;;export const big = () =&gt; &lt;Hello name=&quot;Storybook&quot; big /&gt;;export default &#123; title: &#x27;components|basic/Hello&#x27;, // 스토리북에서 보여질 그룹과 경로를 명시 component: Hello, // 어떤 컴포넌트를 문서화 할지 명시 decorators: [withKnobs] // 애드온 적용&#125;; 참고: export const default 가 아닌 export const Default 라고 하면 작동하기는 합니다. Default 스토리에서 우리는 두개의 Knobs를 만들었습니다. 사용할 수 있는 Knobs 의 종류는 다음과 같습니다. text: 텍스트를 입력 할 수 있습니다. boolean: true&#x2F;false 값을 체크박스로 설정 할 수 있습니다. number: 숫자를 입력 할 수 있습니다. 1~10과 같이 간격을 설정 할 수도 있습니다. color: 컬러 팔레트를 통해 색상을 설정 할 수 있습니다. object: JSON 형태로 객체 또는 배열을 설정 할 수 있습니다. array: 쉼표로 구분된 텍스트 형태로 배열을 설정 할 수 있습니다. select: 셀렉트 박스를 통하여 여러가지 옵션 중에 하나를 선택 할 수 있습니다. radios: Radio 버튼을 통하여 여러가지 옵션 중에 하나를 선택 할 수 있습니다. options: 여러가지 옵션을 선택 하는 UI 를 커스터마이징 할 수 있습니다 (radio, inline-radio, check, inline-check, select, multi-select) files: 파일을 선택 할 수 있습니다. date: 날짜를 선택 할 수 있습니다. button: 특정 함수를 실행하게 하는 버튼을 만들 수 있습니다. 위 Knobs 들의 자세한 스펙은 https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;@storybook&#x2F;addon-knobs#available-knobs 에서 확인 할 수 있습니다. Knobs 를 사용 할 때 넣어주어야 하는 주요 인자로는 Knobs 의 이름, 기본값 그리고 GROUP ID 가 있습니다. GROUP ID 의 경우 생략해도 됩니다. 만약 다음과 같이 그룹을 설정하게 된다면 1const big = boolean(&#x27;big&#x27;, false, &#x27;Group 1&#x27;); 화면에서는 다음과 같이 그룹이 분류되어 나타나게 된답니다. props 에 따라 어떤 결과물을 보여주는지 바로바로 확인하고 싶을 때, 이렇게 Knobs 를 사용하면 매우 유용합니다! 2-2. Actions 애드온 적용하기이번에 배워볼 애드온은 Actions 애드온입니다. 이 애드온은 컴포넌트를 통하여 특정 함수가 호출됐을 때 어떤 함수가 호출됐는지, 그리고 함수에 어떤 파라미터를 넣어서 호출했는지에 대한 정보를 확인 할 수 있게 해줍니다. 간단한 함수 호출부터 시작해서, 나중에는 리액트 라우터의 주소가 변경될 때를 확인하거나 리덕스 스토어의 dispatch를 mocking하여 디스패치 되는 액션의 정보를 볼 수 도 있습니다. 이 링크에서 하단에 있는 액션탭을 열고 컴포넌트에서 항목을 선택해보시면 이 Actions 애드온이 어떤 역할을 하는지 더욱 쉽게 이해 할 수 있을 것입니다. 참고로 이 애드온은 우리가 Storybook CLI로 만든 프로젝트에 기본적으로 적용이 되어있기 때문에 별도로 설치하실 필요가 없습니다. 이 애드온을 한번 사용해보기 위하여, Hello 컴포넌트에 onHello 와 onBye 라는 함수를 props 로 받아오게 해서 버튼을 클릭 했을 때 각 함수를 호출하도록 구현을 해보겠습니다. src&#x2F;Hello&#x2F;Hello.js 12345678910111213141516171819import React from &#x27;react&#x27;;const Hello = (&#123;name, big, onHello, onBye&#125;) =&gt; &#123; return ( &lt;div&gt; &#123; (big) ? &lt;h1&gt;안녕하세요, &#123;name&#125;!&lt;/h1&gt; : &lt;p&gt;안녕하세요, &#123;name&#125;!&lt;/p&gt; &#125; &lt;div&gt; &lt;button onClick=&#123;onHello&#125;&gt;Hello&lt;/button&gt; &lt;button onClick=&#123;onBye&#125;&gt;Bye&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; );&#125;;export default Hello; 이제 Hello 컴포넌트의 스토리 파일을 다음과 같이 수정해보세요. 123456789101112131415161718192021222324252627282930313233import React from &#x27;react&#x27;;import &#123; withKnobs, text, boolean &#125; from &#x27;@storybook/addon-knobs&#x27;;import &#123; action &#125; from &#x27;@storybook/addon-actions&#x27;;import Hello from &#x27;./Hello&#x27;;export default &#123; title: &#x27;components|basic/Hello&#x27;, // 스토리북에서 보여질 그룹과 경로를 명시 component: Hello, // 어떤 컴포넌트를 문서화 할지 명시 decorators: [withKnobs] // 애드온 적용&#125;;export const hello = () =&gt; &#123; // knobs 만들기 const big = boolean(&#x27;big&#x27;, false); const name = text(&#x27;name&#x27;, &#x27;Storybook&#x27;); return ( &lt;Hello name=&#123;name&#125; big=&#123;big&#125; onHello=&#123;action(&#x27;onHello&#x27;)&#125; onBye=&#123;action(&#x27;onBye&#x27;)&#125; /&gt; );&#125;;hello.story = &#123; name: &#x27;Default&#x27;&#125;;export const standard = () =&gt; &lt;Hello name=&quot;Storybook&quot; /&gt;;export const big = () =&gt; &lt;Hello name=&quot;Storybook&quot; big /&gt;; 새로운 액션을 만들 땐 위 코드와 같이 action(&#39;액션 이름&#39;) 이라고 작성을 하시면 됩니다. 이제 Storybook페이지를 열어서 Hello 및 Bye 버튼들을 눌러보세요. Actions 탭에 발생한 액션들이 잘 나타나고 있나요? 2-3. Docs 애드온Docs 애드온은 MDX 형식으로 문서를 작성 할 수 있게 해주고, 컴포넌트의 props와 주석에 기반하여 자동으로 아주 멋진 문서를 자동생성해줍니다. 먼저, 이 애드온을 설치해주세요. 12$ yarn add --dev @storybook/addon-docs$ # 또는 npm install --save-dev @storybook/addon-docs 그 다음에는, .storybook 경로에 있는 main.js 파일을 열어서 다음 코드를 추가해주세요. .storybook&#x2F;main.js 1234module.exports = &#123; stories: [&#x27;../src/**/*.stories.(js|mdx)&#x27;], addons: [&#x27;@storybook/addon-actions&#x27;, &#x27;@storybook/addon-links&#x27;, &#x27;@storybook/addon-knobs/register&#x27;, &#x27;&#x27;@storybook/addon-docs&#x27;]&#125;; 이제 적용이 끝났습니다! Storybook 서버를 종료 후 다시 실행하면 Hello 스토리를 열었을 때 다음과 같이 상단에 Docs라는 탭이 보여질 것입니다. Props 문서화 하기지금은 Props 부분이 “No props found for this component” 라고 보여지면서 비어있습니다. 이 부분을 채우려면 prop-types 또는 TypeScript를 사용해야합니다. 아직 우리 프로젝트에 TypeScript 설정을 하진 않았으니까, prop-types를 사용해보도록 하겠습니다. 추가적으로, defaultProps도 지정해주면 이를 추출해서 보여줄 수 있습니다. defaultProps 도 설정을 해보세요. 먼저, prop-types 패키지를 설치해주세요. 12$ yarn add --save prop-types$ # 또는 npm install --save prop-types src&#x2F;Hello&#x2F;Hello.js 1234567891011121314151617181920212223242526272829303132333435import React from &#x27;react&#x27;;import PropTypes from &#x27;prop-types&#x27;;const Hello = (&#123; name, big, onHello, onBye &#125;) =&gt; &#123; return ( &lt;div&gt; &#123; (big) ? &lt;h1&gt;안녕하세요, &#123;name&#125;!&lt;/h1&gt; : &lt;p&gt;안녕하세요, &#123;name&#125;!&lt;/p&gt; &#125; &lt;div&gt; &lt;button onClick=&#123;onHello&#125;&gt;Hello&lt;/button&gt; &lt;button onClick=&#123;onBye&#125;&gt;Bye&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; );&#125;;Hello.propTypes = &#123; /** 보여주고 싶은 이름 */ name: PropTypes.string.isRequired, /** 이 값을 `true` 로 설정하면 h1 태그로 렌더링 됩니다. */ big: PropTypes.bool, /** Hello 버튼 누를 때 호출할 함수 */ onHello: PropTypes.func, /** Bye 버튼 누를 때 호출할 함수 */ onBye: PropTypes.func&#125;;Hello.defaultProps = &#123; big: false&#125;;export default Hello; propTypes 를 설정 할 때 각 props 위에 /** */ 주석으로 문구를 넣어주면 이 문구가 나중에 문서에서 나타나게 됩니다. 코드를 저장하고 Docs 페이지를 확인해보세요. 다음과 같이 설명이 잘 나타났나요? 컴포넌트에 부제목 및 설명 넣기컴포넌트에 부제목(Subtitle)을 설정해보겠습니다. 부제목을 설정 할 때에는 스토리의 parameters 부분을 설정하면 됩니다. src&#x2F;Hello&#x2F;Hello.stories.js - export default 부분 12345678export default &#123; title: &#x27;components|basic/Hello&#x27;, // 스토리북에서 보여질 그룹과 경로를 명시 component: Hello, // 어떤 컴포넌트를 문서화 할지 명시 decorators: [withKnobs], // 애드온 적용 parameters: &#123; componentSubtitle: &#x27;&quot;안녕하세요&quot;라고 보여주는 컴포넌트&#x27; &#125;&#125;; 이렇게, componentSubtitle 값을 설정해주고 나면 페이지에서 다음과 부제목이 같이 보여지게 됩니다. 이번에는 설명(Description)을 추가해보겠습니다. 컴포넌트의 설명을 추가 할 때는 컴포넌트 파일에서 컴포넌트 코드 바로 윗 부분에 주석으로 작성하면 됩니다. src&#x2F;Hello&#x2F;Hello.js 1234567891011/** * 안녕하세요 라고 보여주고 싶을 땐 `Hello` 컴포넌트를 사용하세요. * * - `big` 값을 `true`로 설정하면 **크게** 나타납니다. * - `onHello` 와 `onBye` props로 설정하여 버튼이 클릭했을 때 호출 할 함수를 지정 할 수 있습니다. */const Hello = (&#123;name, big, onHello, onBye&#125;) =&gt; &#123; return ( ... );&#125;; 이렇게 멀티라인 주석을 작성하시면 되는데, 주석의 시작 부분에서 /** 와 같이, 별표를 두번 넣어주셔야 Docs 가 만들어질 때 이를 파싱합니다. 문서가 잘 만들어졌나요? MDX로 문서를 작성하기MDX를 사용하면 마크다운으로 리액트 컴포넌트를 더욱 쉽게 문서화 할 수 있습니다. 만약 자동 생성되는 DocsPage만 사용한다면 설명을 추가 할 수 있는 공간이 고정되어있기 때문에 설명을 함에 있어서 제한이 있을 수 있지만, MDX를 사용한다면 원하는 곳 어디든지 설명을 추가 할 수 있기 때문에 더욱 자유롭게 문서화를 할 수 있습니다. 컴포넌트 문서화 외에도, Style Guide 에 속하는 색상, Typography에 관한 문서 또는 디자인 시스템에 대한 README 를 작성 할 때 MDX 를 사용하면 유용합니다. 먼저, MDX를 사용하여 기존에 우리가 만들었던 스토리의 Docs 페이지를 커스터마이징 하는 방법을 알아보겠습니다. 우선 src&#x2F;Hello 디렉터리에 Hello.mdx 라는 파일을 새로 생성하세요. mdx 확장자는 VSCode 확장 프로그램을 설치해야 코드에 Syntax Highlighting이 됩니다. (다른 에디터를 사용하신다면 관련 확장 프로그램이 있는지 한번 따로 검색해보세요) intellij IDE 의 경우 MDX 플러그인 설치 방법 (현재 공식적으로 mdx 플러그인을 제공하고 있지는 않으므로 아래와 같이 수동으로 설정 해야 합니다.) 참고 Support MDX file formathttps://github.com/mdx-js/mdx Download the sources of the vscode-mdx plugin In WebStorm, open Preferences&#x2F;Settings | Editor | TextMate Bundles Click on the Add button and select the folder with the downloaded plugin Apply changes and close the settings dialog. src&#x2F;Hello&#x2F;Hello.mdx 123456789101112131415161718192021222324252627282930import &#123; Story, Props, Description, Preview &#125; from &#x27;@storybook/addon-docs/blocks&#x27;;import Hello from &#x27;./Hello&#x27;;# Hello&lt;Hello name=&quot;MDX&quot; big=&#123;true&#125; /&gt;&lt;Description of=&#123;Hello&#125; /&gt;## Props이 컴포넌트에서 사용되는 Props 들을 볼까요?&lt;Props of=&#123;Hello&#125; /&gt;## 그냥 조그마한 Hello&lt;Preview&gt; &lt;Story id=&quot;components-basic-hello--standard&quot; /&gt;&lt;/Preview&gt;그냥 조그마한 Hello 입니다.## 커다란 Hello커다란 Hello를 보여주고 싶으면 `big` props 를 `true` 로설정하시면 됩니다.&lt;Preview&gt; &lt;Story id=&quot;components-basic-hello--big&quot; /&gt;&lt;/Preview&gt; MDX를 사용하면 이렇게 컴포넌트들을 마크다운 내부에서 바로 렌더링 할 수 있답니다. &#39;@storybook/addon-docs/blocks&#39; 안에 들어있는 Block 컴포넌트를 사용하면 기존에 자동생성된 DocsPage 에서 보여줬었던 것 처럼 컴포넌트의 설명 및 Props 정보를 추출하여 보여줄 수 있습니다. 그리고, 우리가 사전에 만든 Story 들을 DocsPage안에서 보여줄 수도 있죠. 기존에 만들었던 Story 를 보여줄 때에는 Story 컴포넌트에 id props 를 설정해주어야 합니다. 이 id 값은 Storybook에서 Story를 선택했을 때 주소창에서 확인 할 수 있습니다. 파일을 다 작성한 다음에는 기존에 만들었던 스토리 파일에서 docs 파라미터를 다음과 같이 설정해보세요. src&#x2F;Hello&#x2F;Hello.stories.js 123456789101112131415161718import React from &#x27;react&#x27;;import &#123; withKnobs, text, boolean &#125; from &#x27;@storybook/addon-knobs&#x27;;import &#123; action &#125; from &#x27;@storybook/addon-actions&#x27;;import Hello from &#x27;./Hello&#x27;;import mdx from &#x27;./Hello.mdx&#x27;;export default &#123; title: &#x27;components|basic/Hello&#x27;, // 스토리북에서 보여질 그룹과 경로를 명시 component: Hello, // 어떤 컴포넌트를 문서화 할지 명시 decorators: [withKnobs], // 애드온 적용 parameters: &#123; componentSubtitle: &#x27;&quot;안녕하세요&quot;라고 보여주는 컴포넌트&#x27;, docs: &#123; page: mdx &#125; &#125;&#125;; mdx 파일을 불러와서 이렇게 파라미터쪽에 설정을 해주고 나면, Docs 페이지가 다음과 같이 커스터마이징 된 상태로 보여질 것입니다. MDX로만 스토리 작성하기이전 예시에서는 stories.js 파일도 만들고 mdx 파일도 만드는 방식으로 컴포넌트의 스토리 및 문서를 작성해주었습니다. 이번에는, stories.js 를 따로 만들지 않고 mdx 파일 내부에서 모든 작업을 하는 방법을 알아보도록 하겠습니다. src 디렉터리에 Bye 라는 디렉터리를 새로 만들고, Bye.js 컴포넌트를 다음과 같이 작성해보세요. src&#x2F;Bye&#x2F;Bye.js 123456789101112import React from &#x27;react&#x27;;import PropTypes from &#x27;prop-types&#x27;;const Bye = (&#123;name&#125;) =&gt; &#123; return &lt;p&gt;안녕히 가세요, &#123;name&#125;&lt;/p&gt;;&#125;;Bye.propTypes = &#123; name: PropTypes.string&#125;;export default Bye; 그 다음에는 Bye.stories.mdx 파일을 같은 디렉터리에 만들어서 다음과 같이 작성해주세요. src&#x2F;Bye&#x2F;Bye.stories.mdx 123456789101112131415161718import &#123; Meta, Story, Props, Preview &#125; from &#x27;@storybook/addon-docs/blocks&#x27;;import &#123; withKnobs, text, boolean &#125; from &#x27;@storybook/addon-knobs&#x27;;import Bye from &#x27;./Bye&#x27;;&lt;Meta title=&quot;components|basic/Bye&quot; component=&#123;Bye&#125; decorators=&#123;[withKnobs]&#125; /&gt;# Button&lt;Preview&gt; &lt;Story name=&quot;Default&quot;&gt; &lt;Bye name=&#123;text(&#x27;name&#x27;, &#x27;stories.js&#x27;)&#125; /&gt; &lt;/Story&gt;&lt;/Preview&gt;## Props&lt;Props of=&#123;Bye&#125; /&gt; Meta Block 을 사용하면 기존에 우리가 CSF 형태로 스토리를 작성 할 때 넣어주는 값들을 설정 할 수있습니다. 이를테면 title, component, decorators, parameters 가 있죠. 어떤 상황에 MDX를 사용해야 할까?Docs 애드온을 통하여 자동으로 만들어진 문서에서 제공하는 정보로는 컴포넌트의 기능을 자세하게 표현하기 어려운 상황에 MDX를 사용하시면 됩니다. (대부분의 경우, 자동으로 생성되는 문서만으로도 충분 할 때가 많습니다.) 추가적으로, 컴포넌트가 아닌 문서를 작성해야 하는 상황에는 (예: Introduction, Colors, Typography 등..) MDX-only로 작성하시면 됩니다. 컴포넌트에 대한 MDX를 작성하실 때에는 MDX-only로 문서를 작성하는 것을 저는 권장하지 않습니다. 그 이유는 나중에 TypeScript를 사용하게 된다면 IDE에서 .mdx 확장자에 대한 TypeScript 지원이 제대로 이루어지지 않기 때문입니다. 참조 https://storybook.js.org/ https://velog.io/@velopert/start-storybook","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"SPA","slug":"Frontend/SPA","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/"},{"name":"React.js","slug":"Frontend/SPA/React-js","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/React-js/"}],"tags":[{"name":"spa","slug":"spa","permalink":"https://woonyzzang.github.com/tags/spa/"},{"name":"test","slug":"test","permalink":"https://woonyzzang.github.com/tags/test/"},{"name":"storybook","slug":"storybook","permalink":"https://woonyzzang.github.com/tags/storybook/"}]},{"title":"React.js Storybook Typescript Design System","slug":"reactjs-storybook-typescript-design-system","date":"2020-03-16T14:38:27.000Z","updated":"2024-06-07T09:27:28.371Z","comments":true,"path":"2020/03/16/reactjs-storybook-typescript-design-system/","permalink":"https://woonyzzang.github.com/2020/03/16/reactjs-storybook-typescript-design-system/","excerpt":"","text":"TypeScript와 Storybook을 사용한 리액트 디자인 시스템 구축하기이 튜토리얼은 TypeScript와 Storybook을 사용하여 리액트 디자인 시스템을 구축하는 방법을 다룹니다. 이 문서를 통하여 여러분들은 다음과 같은 주제들을 배우게 됩니다. 디자인 시스템 이해하기 Storybook의 주요 기능 살펴보기 및 컴포넌트 문서화하기 디자인 시스템 구축하기 Rollup을 사용하여 컴포넌트 라이브러리를 NPM에 등록하기 기존 프로젝트에 Storybook 적용하기 디자인 시스템, 디자이너들에겐 굉장히 익숙한 주제일 것입니다. 프론트엔드 개발자에겐, 익숙할 수도 있고 그렇지 않을 수도 있습니다. 그 이유는 개발에 있어서 필수적인 요소는 아니기 때문이죠. 하지만 있으면 굉장히 도움이 많이 되고 생산성을 올려주는 것은 사실입니다. 하지만 솔직히 준비하는데 시간이 좀 많이 들어가죠. 그래서 도입하고 싶은데 여건이 안돼서 그러지 못한 분들도 많을 것이라고 생각이 됩니다. 저 또한 그런 사람입니다. 필요성은 예전부터 느껴왔지만 계속해서 미뤄왔고 조금 뒤늦게 도입을 시작했으며 현재 진행형입니다. 디자인 시스템이 얼마나 중요한지, 얼마나 도움이 되는지, 워크플로우를 얼마나 개선시키는지, 그러한 주제는 아직 저도 경험치가 풍부하지는 못해서 아쉽게도 이 강의에선 그 주제에 대해서 다루지 않았습니다. 그 대신에 이 강의에서는 프런트엔드 개발자로서 디자인 시스템을 어떻게 이해해야 하며 그리고 또 이를 도입하기 위하여 어떻게 준비를 해나가야 하는지에 대한 내용을 다뤄볼것입니다. 이 강의에서는 디자인 시스템을 준비하는 과정에서 매우 유용하게 사용될 수 있는 도구인 Storybook이라는 도구를 알아보고 직접 사용해보는 시간을 가져볼 것이고요, 여기서 덤으로 컴포넌트를 만들 때 TypeScript를 사용하는 방법도 다뤄볼 것입니다. 이 강의에서 우리는 디자인 시스템을 직접 구축해보고 NPM에 등록해서 사용하는 것도 알아볼 것입니다. 이 튜토리얼의 최종 결과물: https://react-uikit-sample.surge.sh/ https://www.npmjs.com/package/react-uikit-sample 1. 디자인 시스템이란 무엇인가?디자인 시스템을 정의해보기 전에 먼저 이해해야 할 두가지 용어가 있습니다: Style Guide Component Library Style Guide: 스타일 가이드는 특정 브랜드 또는 프러덕트에서 디자인을 할 때 지켜야 하는 규칙들로 이루어져있습니다. 예를 들자면 다음과 같은 영역을 다루죠. 색상 아이콘 여백 (margin) 패딩 (padding) 타이포그라피 (typography) UI에 있어서는 상당히 추상적인 영역이며 디자인 할 때 전역적으로 적용되는 부분입니다. 그리고 꼭 UI에만 해당하는 것은 아닙니다. 로고, 굿즈, 문서, 포스터 등에서도 적용 할 수 있습니다. 다음 예시들을 보시면 스타일 가이드가 무엇인지 더욱 쉽게 다가올 것입니다. The Guardian: https://design.theguardian.com/ Medium: https://www.behance.net/gallery/7226653/Medium-Brand-Development Netflix: https://brand.netflix.com/en/assets/ NASA: https://standardsmanual.com/products/nasa-graphics-standards-manual Audi: https://www.audi.com/ci/en/intro/basics/colours.html Component Library: 컴포넌트 라이브러리는 “Pattern Library” 라는 이름으로도 불립니다. 재사용 가능한 컴포넌트들의 컬렉션으로 이루어져있지요. Button Modal ToggleSwitch Card Checkbox … 디자인 시스템은 스타일 가이드와 컴포넌트의 복합체이며, 컴포넌트들이 함께 사용 될 때 어떻게 사용되어야 하는지, 디자인을 할 때 어떤 규칙들을 지켜야 하는지에 대한 가이드를 다룹니다. Source: https://product-unicorn.com/design-systems-style-guides-all-those-libraries-what-the-hell-is-the-difference-4c2741193fdc 디자인 시스템 예시 https://designsystem.digital.gov/design-tokens/ https://www.carbondesignsystem.com/ https://polaris.shopify.com/ https://atlassian.design/ 중요한 사실방금 내린 정의는 여러분이 조금 더 쉽게 이해하기 위해서 드린 설명이며 이는 디자인 시스템의 공식 정의가 아닙니다. 즉, 방금 다룬 이 정의가 유일한 정의가 아니라 사람, 그룹, 기업에 따라 다른 정의를 가지고 있을 수 있습니다. 인터넷에서 디자인 시스템을 검색하게 되었을때 나오는 다양한 시각자료들을 봐도, 사람들이 디자인 시스템에 대해서 생각할때 다들 조금씩 다른 견해를 가지고 있는 것을 볼 수 있습니다. 하지만 결국 다 비슷합니다. 디자인 시스템에 대한 여러가지 정의의 공통점은 디자인과 개발의 생산성을 높여주기 위한 문서화된 가이드 라는 것이죠. 여기서 문서화, 이게 중요합니다. 제대로 문서화가 되어있지 않으면 시스템을 사용 할수 없습니다. 디자인 시스템에 대하여 리서치를 하면서 가장 인상 깊었던 문구가 있습니다. “If you don’t document it, it doesn’t exist” 우리가 아무리, 재사용이 쉬운 컴포넌트를 만들어도, 코드 상에 주석을 작성을 하고 그래도 문서화가 되어있지 않다면 그것은 디자인 시스템이라고 부를 수 없는 것입니다. 문서화를 하려면 어떻게 해야 할까요? 직접 처음부터 뼈대부터 만들수도 있겠지만 이 작업을 쉽게 하기 위하여 사용하는 도구가 바로, Storybook입니다. Storybook이 어떤 도구인지 빠르게 파악하고 싶다면 이 영상을 확인해보세요. Storybook 대안으로 사용 할 수 있는 도구들Storybook에 대해서 본격적으로 진행하기 전에 대안으로 사용 할 수 있는 도구들은 어떻게 있는지 간단하게 소개드리도록 하겠습니다. Storybook 대안으로 사용 할 수 있는 도구는 Docz와 StyleGuidist가 있습니다. Docz의 경우 Gatsby 정적 페이지 생성기를 기반으로 만들어진 도구입니다. Storybook 대비 설정해야 할 것이 매우 적고, 문서를 작성 할 때 MDX라는 확장자를 사용하여 작성 할 수 있습니다 (참고 링크). MDX는 마크다운과 JSX를 함께 작성 할 수 있는 포맷입니다. StyleGuidist는도 Docz랑 비슷하게 마크다운에 JSX를 포함시켜 문서를 작성 할 수 있게 해주는 도구입니다. 과거의 Storybook은 컴포넌트의 문서를 작성하는 것에 특화되어 있었습니다. 마크다운 + JSX 포맷의 문서를 지원하지 않았기 때문에 컴포넌트가 아닌 내용을 문서화 하기엔 어려움이 있었는데요, Storybook v5.2 부터는 Docs라는 애드온이 개발 되면서 MDX 포맷으로 작성 할 수 있게 되어 이 문제가 개선되었습니다. Docz와 Gatsby는 오로지 문서 작성만을 목적으로 사용되는 도구라면, Storybook은 다양한 애드온을 제공함으로써 UI 개발에 도움이 되는 여러 기능을 갖추고 있습니다. 컴포넌트 문서화 도구로서 인지도&#x2F;사용률은 Storybook이 매우 월등한 편입니다. 참조 https://velog.io/@velopert/design-system-using-typescript-and-storybook","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"SPA","slug":"Frontend/SPA","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/"},{"name":"React.js","slug":"Frontend/SPA/React-js","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/React-js/"}],"tags":[{"name":"spa","slug":"spa","permalink":"https://woonyzzang.github.com/tags/spa/"},{"name":"test","slug":"test","permalink":"https://woonyzzang.github.com/tags/test/"},{"name":"storybook","slug":"storybook","permalink":"https://woonyzzang.github.com/tags/storybook/"}]},{"title":"VSCode Extension Dev3","slug":"vscode-extension-dev3","date":"2019-12-11T16:01:04.000Z","updated":"2024-06-05T06:54:12.887Z","comments":true,"path":"2019/12/12/vscode-extension-dev3/","permalink":"https://woonyzzang.github.com/2019/12/12/vscode-extension-dev3/","excerpt":"","text":"Vscode Extension (플러그인) 만들기3저번 markdown 파일에서 업그레이드 버전입니다.단어수 체크할 때 Hi 를 계속 호출하기 귀찮으니 자동으로 체크해주는 코드입니다. 우선 클래스를 하나 만들어 주고.. 12345678910111213141516171819202122232425262728293031class WordCounterController &#123; private _wordCounter: WordCounter; private _disposable: Disposable; constructor(wordCounter: WordCounter) &#123; this._wordCounter = wordCounter; // subscribe to selection change and editor activation events let subscriptions: Disposable[] = []; window.onDidChangeTextEditorSelection(this._onEvent, this, subscriptions); window.onDidChangeActiveTextEditor(this._onEvent, this, subscriptions); // update the counter for the current file // 키면 한번 업데이트 console.log(&#x27;update&#x27;); this._wordCounter.updateWordCount(); // create a combined disposable from both event subscriptions this._disposable = Disposable.from(...subscriptions); &#125; dispose() &#123; this._disposable.dispose(); &#125; private _onEvent() &#123; console.log(&#x27;_onEvent&#x27;); this._wordCounter.updateWordCount(); &#125;&#125; onDidChangeTextEditorSelection 함수는 커서 위치가 변경되면 이벤트가 발생 onDidChangeActiveTextEditor 함수는 활성 편집기가 변경되는 이벤트 파라미터 12345A function that represents an event to which you subscribe by calling it with a listener function as argument.@param listener — The listener function will be called when the event happens.@param thisArgs — The this-argument which will be used when calling the event listener.@param disposables — An array to which a disposable will be added.@return — A disposable which unsubscribes the event listener. 코드를 이해하면서 봐야하는데… 로그찍어서 확인해보니 onDidChange* 함수가 실행되면 this._onEvent 가 실행되서 updateWordCount() 가 됩니다. 이제 클래스를 만들었으니 적용해야합니다. activate 를 수정해줍시다. 12345678910111213141516export function activate(context: ExtensionContext) &#123; // Use the console to output diagnostic information (console.log) and errors (console.error). // This line of code will only be executed once when your extension is activated. console.log(&#x27;Congratulations, your extension &quot;WordCount&quot; is now active!&#x27;); // create a new word counter let wordCounter = new WordCounter(); let controller = new WordCounterController(wordCounter) // Add to a list of disposables which are disposed when this extension is deactivated. context.subscriptions.push(wordCounter); context.subscriptions.push(controller);&#125; json 파일도 수정해줍니다. activationEvents 안에 onLanguage:markdown 설정을 해줍니다. onLanguage:$&#123;language&#125; 이벤트는 언어 ID 를 사용하며 해당 언어의 파일이 열리면 발생합니다. mands 의 sayHi 는 필요없어져서 지웠습니다. 이제 자동으로 체크해줍니다! 참조 https://kdinner.tistory.com/8?category=308458","categories":[{"name":"Editor","slug":"Editor","permalink":"https://woonyzzang.github.com/categories/Editor/"},{"name":"VSCode","slug":"Editor/VSCode","permalink":"https://woonyzzang.github.com/categories/Editor/VSCode/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://woonyzzang.github.com/tags/vscode/"}]},{"title":"VSCode Extension Dev2","slug":"vscode-extension-dev2","date":"2019-12-11T15:53:38.000Z","updated":"2024-06-05T06:53:45.397Z","comments":true,"path":"2019/12/12/vscode-extension-dev2/","permalink":"https://woonyzzang.github.com/2019/12/12/vscode-extension-dev2/","excerpt":"","text":"Vscode Extension (플러그인) 만들기2우선 다시 폴더를 만들어주시고 extesion.ts 함수입니다. 계속 Hello World 만 쳐야 하는게 싫어서 Hi 로 바꿔봤습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// The module &#x27;vscode&#x27; contains the VS Code extensibility API// Import the module and reference it with the alias vscode in your code belowimport &#123; window, commands, Disposable, ExtensionContext, StatusBarAlignment, StatusBarItem, TextDocument &#125; from &#x27;vscode&#x27;;// This method is called when your extension is activated. Activation is// controlled by the activation events defined in package.json.export function activate(context: ExtensionContext) &#123; // Use the console to output diagnostic information (console.log) and errors (console.error). // This line of code will only be executed once when your extension is activated. console.log(&#x27;Congratulations, your extension &quot;WordCount&quot; is now active!&#x27;); // create a new word counter let wordCounter = new WordCounter(); // sayHello 를 sayHi 함수로 변경 let disposable = commands.registerCommand(&#x27;extension.sayHi&#x27;, () =&gt; &#123; wordCounter.updateWordCount(); &#125;); // Add to a list of disposables which are disposed when this extension is deactivated. context.subscriptions.push(wordCounter); context.subscriptions.push(disposable);&#125;class WordCounter &#123; private _statusBarItem: StatusBarItem = window.createStatusBarItem(StatusBarAlignment.Left); public updateWordCount() &#123; // Get the current text editor let editor = window.activeTextEditor; if (!editor) &#123; this._statusBarItem.hide(); return; &#125; let doc = editor.document; // Only update status if a Markdown file // markdown 체크 if (doc.languageId === &quot;markdown&quot;) &#123; let wordCount = this._getWordCount(doc); // Update the status bar this._statusBarItem.text = wordCount !== 1 ? `$&#123;wordCount&#125; Words` : &#x27;1 Word&#x27;; this._statusBarItem.show(); &#125; else &#123; this._statusBarItem.hide(); &#125; &#125; public _getWordCount(doc: TextDocument): number &#123; let docContent = doc.getText(); // Parse out unwanted whitespace so the split is accurate docContent = docContent.replace(/(&lt; ([^&gt;]+)&lt;)/g, &#x27;&#x27;).replace(/\\s+/g, &#x27; &#x27;); docContent = docContent.replace(/^\\s\\s*/, &#x27;&#x27;).replace(/\\s\\s*$/, &#x27;&#x27;); let wordCount = 0; if (docContent !== &quot;&quot;) &#123; wordCount = docContent.split(&quot; &quot;).length; &#125; return wordCount; &#125; dispose() &#123; this._statusBarItem.dispose(); &#125;&#125; JSON 파일도 수정해줍니다. JSON 은 주석이 안되서 사진만 빠르게.. 이제 HI 라고 쳐도 반응을 합니다.! 아래에 3단어라고 표시됩니다. Hi 라고 호출해야지 Words 가 표시되는데 자동으로 쭉 ~ 표시되는 방법은 다음편에 계속하겠습니다. 참조 https://kdinner.tistory.com/7?category=308458","categories":[{"name":"Editor","slug":"Editor","permalink":"https://woonyzzang.github.com/categories/Editor/"},{"name":"VSCode","slug":"Editor/VSCode","permalink":"https://woonyzzang.github.com/categories/Editor/VSCode/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://woonyzzang.github.com/tags/vscode/"}]},{"title":"VSCode Extension Dev1","slug":"vscode-extension-dev1","date":"2019-12-11T15:34:58.000Z","updated":"2024-06-05T06:53:01.161Z","comments":true,"path":"2019/12/12/vscode-extension-dev1/","permalink":"https://woonyzzang.github.com/2019/12/12/vscode-extension-dev1/","excerpt":"","text":"Vscode Extension (플러그인) 만들기1vscode 확장에서는 코드로 직접 키 입력을 감지해서 단축키 작업을 실행하는것이 아니라, 특정한 이름으로 커맨드를 만들고 유저가 직접 커맨드와 단축키를 바인딩하는 과정을 거칩니다. VSCode API 확장 프로그램의 activate 함수 아래에 아래와 같은 코드를 작성합니다.커맨드 이름은 extension.확장프로그램이름.기능이름 과 같이 작성합니다. 12345let disposable = vscode.commands.registerCommand(&#x27;extension.foo.helloWorld&#x27;, () =&gt; &#123; // 이곳에 커맨드가 눌리면 실행될 코드를 작성합니다.&#125;);context.subscriptions.push(disposable); 커맨드를 등록하는 코드를 작성했으면, 실제로 단축키와 연결하기 위해 vscode의 단축키 설정을 변경해야 합니다.단축키 조합은 파일 -&gt; 기본 설정 -&gt; 바로가기 키 에서 설정할 수 있습니다. 1234567[ &#123; &quot;key&quot;: &quot;ctrl+space&quot;, &quot;command&quot;: &quot;extension.foo.helloWorld&quot;, &quot;when&quot;: &quot;editorTextFocus&quot; &#125;] 텍스트 가져오기12345678// 현재 포커싱된 윈도우의 텍스트 에디터를 가져옵니다.let editor = vscode.window.activeTextEditor; let doc = editor.document;// 실제 String 타입의 코드입니다.let src = doc.getText();// 파일 이름입니다.let fileName = doc.fileName; 12// 현재 유저가 선택한 위치의 텍스트만 가져올 수도 있습니다.doc.getText(editor.selection); 텍스트 편집하기소스를 수정할때는 직접 string 값에 접근해 작업하는것이 아닌, edit 메소드를 이용합니다. 1234567editor.edit(builder =&gt; &#123; // 현재 선택된 텍스트를 &quot;AA&quot; 로 치환합니다. builder.replace(editor.selection, &quot;AA&quot;); // 현재 커서의 끝에 &quot;BB&quot; 를 삽입합니다. builder.insert(editor.selection.end, &quot;BB&quot;);&#125;); edit 메소드의 반환값에 then을 이용하여 모든 편집이 수행된 후의 작업을 지정할 수 있습니다. 12345editor.edit(builder =&gt; &#123;&#125;).then(() =&gt; &#123; // 텍스트 편집이 수행된 후 하고싶은 작업을 작성합니다.&#125;); 확장 플러그인을 만들어 보는 과정은 아래와 같습니다. Vscode Extension 패키지 설치1$ npm install -g yo generator-code 설치 후 yo code 입력시 아래 화면이 뜹니다. 타입스크립트로 만들어서 앤터 ! 열심히 설치가 됩니다. hello-world로 들어가서 작업하라는데 안됩니다. 디버그 눌러도 없다고 뜨고 만들어서 해봐도 안된다 뜨고.. (이 오류때문에 안되는줄 알고 포기했었던..) 하지만 하는 방법을 찾았습니다.! 요게 vscode 에서 디버그? 경로잡고 해주는 파일 같은데 (아닐수도) workspaceFolder 가 cd로 들어가져도 안바뀌나봐요.. 아예 새창을 띄우시고 hello-world 폴더를 띄우셔서 디버그 하시면 됩니다. 디버그에 성공하시면 새창이 뜹니다.! 실패한게 아니에요.! 여기서 Mac 은 Cmd +shift + p, 윈도우는 ctrl + shift + p ?? (제가 지금 맥이라..)단축키를 누르시면 뜹니다. 거기에 hello world를 치시면 ~ 아래에 hello world 라고 출력되었습니다 ~ 다음에는 조금 응용해서 발전하는걸 보여드리겠습니다.! 참조 https://kdinner.tistory.com/6","categories":[{"name":"Editor","slug":"Editor","permalink":"https://woonyzzang.github.com/categories/Editor/"},{"name":"VSCode","slug":"Editor/VSCode","permalink":"https://woonyzzang.github.com/categories/Editor/VSCode/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://woonyzzang.github.com/tags/vscode/"}]},{"title":"Cent OS Let`s Encrypt SSL Install","slug":"cent-os-lets-encrypt-ssl-install","date":"2019-11-04T16:52:29.000Z","updated":"2024-06-07T09:27:28.271Z","comments":true,"path":"2019/11/05/cent-os-lets-encrypt-ssl-install/","permalink":"https://woonyzzang.github.com/2019/11/05/cent-os-lets-encrypt-ssl-install/","excerpt":"","text":"Let’s Encrypt 무료 SSL 인증서 발급Certbot이라는 툴을 사용하여 Let’s Encrypt의 SSL인증서를 발행하고, HTTP통신을 HTTPS로 암호화합니다. HTTP &#x2F; HTTPS란?Hypertext Transfer Protocol(HTTP)는 인터넷상의 무수히 존재하는 웹사이트의 데이터를 송수신하는데 필요한 통신 프로토콜입니다.이 http통신을 보다 안전하게 수행하기 위한 프로토콜 및 URI스킴을 https라고 하는데, 엄밀하게 말하면 https 자체는 프로토콜이 아니고, SSL&#x2F;TLS프로토콜에 의해 제공되는 시큐어한 접속상태에서 http통신을 수행하는 것을 말합니다. 이렇게 시큐어한 접속상태를 유지하기 위하여 SSL인증서의 발행이 필요하게 됩니다. SSL인증서란?서버정보와 서버의 공개키, 인증서를 발행한 인증국의 정보가 서명되어 있는 파일입니다. 서버의 공개키(CSR)와 비밀키(Key) 인증국(CA)가 전자서명한 SSL인증서(CRT)와 중간CA인증서 서버의 공개키는 클라이언트와의 통신을 암호화하는데 사용하고, 서명은 위조방지를 위해 사용하며 인증서를 발행하는 CA라 불리는 제3자기관이 CSR의 정보를 바탕으로 서명합니다. 중간 CA인증서는 SSL인증서를 발행하는 인증국 또는 그 아래에 있는 별도의 인증국에 의해 서명된 파일인데 필수는 아니지만, 시큐리티 레벨 향상을 위하여 중간CA를 1개이상 사용하는 계층구조를 취하는 인증을 추천합니다. SSL인증서 발행과 설정의 흐름다음과 같은 순서로 진행됩니다. 적용할 (웹)서버에서 CSR과 KEY를 작성 CSR을 CA에 송신해서 인증서의 발행을 신청 CA로부터 전자서명된 CRT와 중간CA인증서를 수령 수령한 인증서류를 웹서버에 설치 Certbot이란?https://certbot.eff.org/ Certbot은 무료이면서 자동으로 SSL인증서를 발행할수 있는 툴입니다. CSR과 KEY파일 작성부터 웹서버 설정까지 자동으로 처리할 수 있습니다. CRON을 사용하면, 인증서의 갱신작업까지도 완전히 자동화가 가능합니다. 인증서의 서명과 발행은 Let’s Encrypt라고 불리우는 인증국에 의해 처리됩니다. Let’s Encrypt란?https://letsencrypt.org/ 미국의 ISRG(Internet Security Research Group)가 운영하는 무료 SSL인증 서명 및 발행하는 기관이며,Cisco, OVH, Mozilla, Google Chrome, Electronic Frontier Foundation, Internet Society, facebook 등 유명기업이 지원하는 비영리단체입니다. (https://letsencrypt.org/sponsors/)Let’s Encrypt 인증서의 유효기간이 90일인데, 스크립트설정을 통해서 자동으로 갱신 가능하므로 반영구적으로 유지가능한 인증서라고 할 수 있습니다. 서버상에 스크립트설정이 필요하므로 일반적인 렌털 서버에서의 이용은 어려운 경우가 많거나, 렌털서버업체에서 부가서비스로 제공하기도 합니다. Let’s Encrypt의 발표에 따르면 2019년에 루트인증서는 1억2천만개이상, FQDN은 2억1500만개이상까지 성장할 것이라고 분석하고 있는데, 내용을 보면 SSL인증서 적용이 엄청난 속도로 증가하고 있음을 알 수 있습니다. ※ 자세한 내용은 여기 참고: https://letsencrypt.org/2018/12/31/looking-forward-to-2019.html 무료인증서와 유료인증서 간단 비교무료라고 해서 해독하기 쉬운 암호화방식을 쓴다거나 하는 일은 없으며, 유료&#x2F;무료와 상관없이 암호화강도는 동일합니다. 무료인증서 장점 비용이 들지 않는다 Let’s Encrypt의 경우, 스크립트설정으로 자동갱신이 가능(반영구적) 단점 블랙리스트에 포함되어 기계적으로 발행 불가할 경우 등을 포함 일체의 서포트를 받을 수 없다. 무료로 취득가능하므로 피싱사이트등에서 악용되는 일이 많다 스크립트 설정이 가능할 정도의 전문지식이 있어야 한다. 운영기반의 자금이 기부로 유지되고 있어, 일반적인 인증국에 비해 서비스를 종료할 수 있는 리스크가 높다. (일반적으로..) 부가서비스가 없다(예: 웹사이트보호, 인증국의 과실로 발생한 보안사고에 대한 손해보상 등) 유료인증서 장점 블랙리스트에 포함되어 기계적으로 발행 불가시 수동으로 대응해주는 등의 서포트를 받을 수 있다. 보다 신뢰성이 높은 인증방식(OV&#x2F;EV)의 인증서를 선택할 수 있다 유효기간이 최장 2년인 인증서를 구입할 수 있다 부가서비스를 받을 수 있다(예: 웹사이트보호, 인증국의 과실로 발생한 보안사고에 대한 손해보상 등) 단점 비용이 든다 자동갱신은 거의 대응하지 않는다. 이제 실제로 Certbot을 사용하여, Let’s Encrypt에서 발행한 SSL인증서를 우리의 웹서버에 설정합니다. 설정Certbot의 설치와 SSL인증서 발행그럼 Certbot을 사용하여 인증서를 발행해 봅니다. https://certbot.eff.org/ 에 접속하여, 자신에게 맞는 software와 system을 선택합니다. 기본적으로 선택후 나타나는 화면의 지시대로 설치&#x2F;설정해 나갑니다. (Apache &#x2F; CentOS&#x2F;RHEL7) Certbot은 EPEL (Enterprise Linux 용 추가 패키지)에 패키지되어 있습니다. Certbot을 사용하려면 먼저EPEL 저장소를 활성화 해야 합니다 . RHEL 또는 Oracle Linux에서는 선택적 채널을 활성화해야 합니다. 12# 필요시 아래와 같이 활성화해 줍니다.$ yum install epel-release Certbot을 인스톨합니다. 1$ yum install certbot python2-certbot-apache 인증서를 설치합니다. Apache의 설정이 자동으로 검출되어 아래와 같이 도메인이 리스트업되므로 설치할 대상 도메인의 번호를 선택합니다.발행된 인증서는 /etc/letsencrypt/live/ 디렉토리 밑에 위치합니다. 12# 이 명령을 실행하면 인증서가 생기고 Certbot이 Apache 구성을 자동으로 편집하여 서비스를 제공 (참고용)$ certbot --apache Apache구성을 수동으로 편집하기 위해서 certonly옵션으로 인증서를 설치합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061$ certbot --apache certonlySaving debug log to /var/log/letsencrypt/letsencrypt.logPlugins selected: Authenticator apache, Installer apacheEnter email address (used for urgent renewal and security notices) (Enter &#x27;c&#x27; tocancel): example@gmail.com # 관리자용 이메일주소를 입력합니다 (최초 1회만)Starting new HTTPS connection (1): acme-v02.api.letsencrypt.org- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Please read the Terms of Service athttps://letsencrypt.org/documents/LE-SA-v1.2-November-15-2017.pdf. You mustagree in order to register with the ACME server athttps://acme-v02.api.letsencrypt.org/directory- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -(A)gree/(C)ancel: a # 동의합니다 (최초 1회만)- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Would you be willing to share your email address with the Electronic FrontierFoundation, a founding partner of the Let\\&#x27;s Encrypt project and the non-profitorganization that develops Certbot? We\\&#x27;d like to send you email about our workencrypting the web, EFF news, campaigns, and ways to support digital freedom.- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -(Y)es/(N)o: n # 뉴스,캠페인등 소식은 받지 않는걸로; (최초 1회만)Which names would you like to activate HTTPS for? - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -1: example.herokuapp.com # 아파치에 설정된 도메인 리스트가 자동으로 나열됩니다.2: www.example.herokuapp.com- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Select the appropriate numbers separated by commas and/or spaces, or leave inputblank to select all options shown (Enter &#x27;c&#x27; to cancel): 1 # 콤마 또는 스페이스로 구분해서 여러개를 입력해도 첫번째만 유효 (여러개의 인증서를 발급할 경우, 하나씩 인증서를 설치합니다)Obtaining a new certificatePerforming the following challenges:http-01 challenge for naruhodo.cfhttp-01 challenge for www.naruhodo.cfWaiting for verification...Cleaning up challengesResetting dropped connection: acme-v02.api.letsencrypt.orgIMPORTANT NOTES:- Congratulations! Your certificate and chain have been saved at: /etc/letsencrypt/live/naruhodo.cf/fullchain.pem # 인증서와 체인이 저장된 곳Your key file has been saved at:/etc/letsencrypt/live/naruhodo.cf/privkey.pem # 개인키 저장된 곳Your cert will expire on 2019-08-18. To obtain a new or tweaked # 유효기간은 2019-08-18일까지version of this certificate in the future, simply run certbotagain. To non-interactively renew *all* of your certificates, run&quot;certbot renew&quot; # 모든 인증서를 즉시 갱신하려면 certbot renew를 실행- If you like Certbot, please consider supporting our work by:Donating to ISRG / Let&#x27;s Encrypt: https://letsencrypt.org/donateDonating to EFF: https://eff.org/donate-le 생성된 인증서를 확인합니다. 12345678910$ cd /etc/letsencrypt/live$ ls|--example.herokuapp.com| |--cert.pem| |--chain.pem| |--fullchain.pem| |--privkey.pem| |--README|--README Apache설정 먼저, &#x2F;etc&#x2F;httpd&#x2F;conf.d&#x2F;ssl.conf파일에서 SSL관련 글로벌 설정을 확인합니다. 1$ vi /etc/httpd/conf.d/ssl.conf ssl.conf 123456789101112131415## When we also provide SSL we have to listen to the # the HTTPS port in addition.#Listen 443 https # 확인...# &lt;VirtualHost _default_:443&gt;# 아래와 같이 수정합니다.&lt;VirtualHost *:443&gt; DocumentRoot &quot;/var/www/html/&quot; # 확인 ServerName YOUR_MAIN_DOMAIN:443 # 확인 SSLEngine on # 확인&lt;/VirtualHost&gt; https통신에서 사용하는 443&#x2F;tcp 포트를 오픈합니다. 1$ firewall-cmd --add-service=https --permanent &amp;&amp; firewall-cmd --reload 발행한 SSL인증서를 도메인별로 설정합니다. 1$ vi /etc/httpd/conf.d/httpd-vhosts-le-ssl.conf # &lt;vhost-ssl-YOUR_DOMAN_NAME.conf형식으로 작성 (multi 도메인 적용을 위해) httpd-vhosts-le-ssl.conf 123456789101112131415161718192021222324&lt;IfModule mod_ssl.c&gt; &lt;VirtualHost *:443&gt; ServerAdmin example@gmail.com ServerName example.herokuapp.com ServerAlias example.herokuapp.co.kr ServerAlias www.example.herokuapp.com ServerAlias www.example.herokuapp.co.kr DocumentRoot /home/www/ #DocumentRoot /var/www/html/example.herokuapp.com &lt;Directory &quot;/home/www/main/&quot;&gt; AllowOverride FileInfo Require all granted &lt;/Directory&gt; ErrorLog logs/virtual-ssl-error_log CustomLog logs/virtual-ssl-access_log combined env=!no_log Include /etc/letsencrypt/options-ssl-apache.conf SSLCertificateFile /etc/letsencrypt/live/example.herokuapp.com/cert.pem # SSL인증서 SSLCertificateKeyFile /etc/letsencrypt/live/example.herokuapp.com/privkey.pem # 개인키 SSLCertificateChainFile /etc/letsencrypt/live/example.herokuapp.com/chain.pem # 중간CA증명서 &lt;/VirtualHost&gt;&lt;/IfModule&gt; httpd데몬을 재기동해 줍니다. 1$ systemctl restart httpd 그런데, http://example.herokuapp.com 로 접속해보면 SSL이 적용되지 않는 체 그대로 노출되고 있습니다. 이제 Redirect설정으로 http로 접속해도 https로 Redirect되도록 설정해 보겠습니다. https만 설정할 수도 있으나(처음부터 https만 운영하는 경우)할 수도 있으나,초기에 http를 운영하다가 https를 적용하는 경우에는 사용자 편의측면에서 http&#x2F;https 접속가능하게 하고, http로 접속하는 경우에 https로 자동으로 돌려주는 설정을 추가해 줍니다. http 및 https 사이트가 존재하는 것은 유저에게도 어떤 URL이 타당한 것인지 혼란을 초래할 수 있고, 웹 억세스 분석이 어려워지며, SEO에도 악영향을 줄 수 있으므로 반드시 1개의 URL로 운영하는 것이 좋습니다. 80번 포트에 설정한 VirtualHost에 아래의 내용을 추가합니다. 1$ vi /etc/httpd/conf/extra/httpd-vhost.conf 12345678910111213141516171819202122&lt;VirtualHost *:80&gt; ServerAdmin example@gmail.com ServerName example.herokuapp.com ServerAlias example.herokuapp.co.kr ServerAlias www.example.herokuapp.com ServerAlias www.example.herokuapp.co.kr DocumentRoot /home/www/ &lt;Directory &quot;/home/www/main/&quot;&gt; AllowOverride FileInfo Require all granted &lt;/Directory&gt; RewriteEngine on # 추가 RewriteCond %&#123;SERVER_NAME&#125; =example.herokuapp.com [OR] RewriteCond %&#123;SERVER_NAME&#125; =example.herokuapp.co.kr [OR] RewriteCond %&#123;SERVER_NAME&#125; =www.example.herokuapp.com [OR] RewriteCond %&#123;SERVER_NAME&#125; =www.example.herokuapp.co.kr RewriteRule ^ https://%&#123;SERVER_NAME&#125;%&#123;REQUEST_URI&#125; [END,NE,R=permanent] #RewriteRule ^(.*)$ https://%&#123;HTTP_HOST&#125;$1 [R=301,L] # 추가 (이 방법을 많이 사용하는데) #RewriteRule ^(.*)$ https://www.example.herokuapp.com [R=301,L] # 추가 (제대로 동작하지 않아 직접 입력)&lt;/VirtualHost&gt; httpd데몬을 재기동해 줍니다. 1$ systemctl restart httpd 유효기간 90일, SSL인증서의 갱신을 자동화Certbot은 인증서가 만료되기 전에 자동으로 갱신되도록 구성 할 수 있습니다. 다음 명령을 실행하여 인증서의 자동 갱신을 테스트 할 수 있습니다. (선택) 1$ certbot renew --dry-run 테스트가 완료되면 정기적으로 백업을 해두라고 권장을 하죠. 백업해 둡니다. 1$ tar cvzf etc_letsencrypt.tar.gz /etc/letsencrypt crontab을 사용하여 스케쥴링을 자동화합니다.매일 하루에 두번(정오,자정)씩 갱신해주는 cron job을 등록해 줍니다. (Certbot.org 권장) 1234$ crontab -e# 아래의 내용을 추가합니다.0 0,12 * * * python -c &#x27;import random; import time; time.sleep(random.random() * 3600)&#x27; &amp;&amp; certbot renew 123$ systemctl restart crond$ systemctl status crond HTTPS가 잘 적용되었는지 확인웹사이트에 적용되어 있는 SSL인증서의 확인방법 &#x2F; Chrome developer툴에 의한 확인방법 MAC: command+option+I(대문자i) &#x2F; Windows: F12 or Ctrl+shift+I(대문자i) Security 탭을 오픈 View certificates을 클릭 SSL Server Test공용 인터넷상의 SSL 웹 서버 구성에 대한 심층 분석을 수행하는 무료 온라인 서비스를 이용하여 테스트를 진행할 수 있습니다. https://www.ssllabs.com/ssltest/index.html 위에 사이트에 접속해서 테스트하려는 Hostname을 입력하고 Submit을 클릭하면 등급을 확인 할 수 있습니다.(테스트는 약간의 시간이 걸립니다. 완료되면 등급과 함께 세부항목의 점수를 확인할 수 있습니다.) Certificate, Protocol Support, Key Exchange, Cipher Strength등 4개 항목에 대한 점수도 알 수 있습니다. 화면을 스크롤해 보면 매우 상세한 정보들을 추가로 알 수 있습니다. 여건이 된다면 내용을 참고로 설정을 보강하여 A＋등급에 도전해보는 것도 좋겠습니다. 301 Redirect 동작 확인브라우저에서 http://example.herokuapp.com 로 접속하여, https://www.example.herokuapp.com로 자동으로 바뀌는지 확인합니다. 123$ curl -I http://example.herokuapp.com$ curl -I http://www.example.herokuapp.com 301 Redirect Checker를 이용해서 확인해 봅니다. http://ohotuku.jp/redirect_checker&#x2F; 이상으로 Certbot과 Let’s encrypt를 이용해서 SSL인증서의 발행과아파치 웹서버 설정으로 HTTPS를 활성화해 보았습니다. 참조 https://certbot.eff.org/lets-encrypt/centosrhel7-apache https://puzji.tistory.com/entry/Certbot-SSL%EC%9D%B8%EC%A6%9D%EC%84%9C-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0","categories":[{"name":"OS","slug":"OS","permalink":"https://woonyzzang.github.com/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"https://woonyzzang.github.com/categories/OS/Linux/"},{"name":"CentOS","slug":"OS/Linux/CentOS","permalink":"https://woonyzzang.github.com/categories/OS/Linux/CentOS/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://woonyzzang.github.com/tags/linux/"},{"name":"centos","slug":"centos","permalink":"https://woonyzzang.github.com/tags/centos/"}]},{"title":"Wordpress Account Login Session Redirect","slug":"wordpress-account-login-session-redirect","date":"2019-11-04T16:43:11.000Z","updated":"2024-06-07T09:27:28.387Z","comments":true,"path":"2019/11/05/wordpress-account-login-session-redirect/","permalink":"https://woonyzzang.github.com/2019/11/05/wordpress-account-login-session-redirect/","excerpt":"","text":"워드프레스 로그인 계정 세션 연동 리다이렉트 페이지워드프레스의 로그인 세션과 연동해서 비로그인시 해당 페이지를 리다이렉트 시키는 방법 입니다. 인덱스 페이지 파일안에 PHP 세션을 활성화 시키고 $_SESSION[&#39;wp_uidev_logged_in&#39;] 란 세션으 만들어 예외처리 코드를 추가 합니다. index.php 12345678910111213141516&lt;?php session_start(); if (!$_SESSION[&#x27;wp_uidev_logged_in&#x27;]) &#123; $description = &#x27;설명&#x27;; $title = &#x27;제목&#x27;; $error_message = &quot;이 페이지에 접근 권한이 없습니다.&#x27;\\n\\n- J Dev 블로그 계정으로 로그인중인 사용자만 접근할 수 있습니다.\\n- J Dev 블로그 로그인 계정으로 인증 한 후 다시 접속해 주세요.&quot;; $error_message = preg_replace(&#x27;/(\\r\\n|\\r|\\n)/&#x27;, &#x27;\\n&#x27;, addslashes($error_message)); $redirect_url = &#x27;https://www.google.co.kr/wordpress/wp-admin/&#x27;; echo &quot;&lt;!DOCTYPE html&gt;&lt;html lang=\\&quot;ko\\&quot;&gt;&lt;head&gt;&lt;meta charset=\\&quot;utf-8\\&quot;&gt;&lt;meta name=\\&quot;viewport\\&quot; content=\\&quot;width=device-width,initial-scale=1\\&quot;&gt;&lt;meta name=\\&quot;description\\&quot; content=\\&quot;&#123;$description&#125;\\&quot;&gt;&lt;meta name=\\&quot;author\\&quot; content=\\&quot;woonyzzang\\&quot;&gt;&lt;title&gt;&#123;$title&#125;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;alert(&#x27;&#123;$error_message&#125;&#x27;);location.replace(&#x27;&#123;$redirect_url&#125;&#x27;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&quot;; exit; &#125;?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;&lt;meta name=&quot;description&quot; content=&quot;설명&quot;&gt;&lt;meta name=&quot;author&quot; content=&quot;wonyzzang&quot;&gt;&lt;title&gt;타이틀&lt;/title&gt;&lt;/head&gt;&lt;body&lt;h1&gt;Hello World!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 워드프레스 파일 안의 functions.php 파일안에 아래 코드를 추가 합니다. 인덱스 파일에서 만들었던 $_SESSION[&#39;wp_uidev_logged_in&#39;] 세션으로 워드프레스 블로그에 로그인 중인지 아닌지를 판별 합니다. functions.php 12345678910111213141516// 로그인 후 세션생성function session_login() &#123; if (!isset($_SESSION[&#x27;wp_uidev_logged_in&#x27;])) &#123; $_SESSION[&#x27;wp_uidev_logged_in&#x27;] = true; &#125;&#125;add_action(&#x27;wp_login&#x27;, &#x27;session_login&#x27;);// 로그아웃 시 세션종료function session_logout() &#123; unset($_SESSION[&#x27;wp_uidev_logged_in&#x27;]); // session_destroy();&#125;add_action(&#x27;wp_logout&#x27;, &#x27;session_logout&#x27;);","categories":[{"name":"Backend","slug":"Backend","permalink":"https://woonyzzang.github.com/categories/Backend/"},{"name":"PHP","slug":"Backend/PHP","permalink":"https://woonyzzang.github.com/categories/Backend/PHP/"},{"name":"Wordpress","slug":"Backend/PHP/Wordpress","permalink":"https://woonyzzang.github.com/categories/Backend/PHP/Wordpress/"}],"tags":[{"name":"php","slug":"php","permalink":"https://woonyzzang.github.com/tags/php/"},{"name":"wordpress","slug":"wordpress","permalink":"https://woonyzzang.github.com/tags/wordpress/"}]},{"title":"Javascript Attributes","slug":"javascript-attributes","date":"2019-09-22T12:07:39.000Z","updated":"2024-06-10T04:53:59.555Z","comments":true,"path":"2019/09/22/javascript-attributes/","permalink":"https://woonyzzang.github.com/2019/09/22/javascript-attributes/","excerpt":"","text":"꼼꼼히 살펴보는 SCRIPT 엘리먼트아마도 &lt;script&gt;는 자바스크립트를 공부할 때 가장 먼저 배우는 HTML 엘리먼트일 것이다. 속성이 많지도 않고 심지어 아무런 속성을 입력하지 않아도 유효하고 잘 동작하는 엘리먼트라서 지나치기 쉽다. 하지만 자바스크립트 실행에 있어서는 어쩌면 가장 중요한 엘리먼트이기에 한 번쯤은 제대로 꼼꼼히 살펴보는 게 좋을 것이다. 이 글은 지속적으로 업데이트되는 Living Standard 문서에 기초하고 있으므로 2014년에 발표된 HTML5 권고안에 포함되지 않은 내용도 있다. 이런 경우에는 별도로 관련 표기를 해두었으니 참고하기 바란다. 스크립트 엘리먼트스크립트 엘리먼트는 &lt;script&gt;로 시작하고 &lt;/script&gt;로 끝난다. 다른 HTML 엘리먼트와 마찬가지로 엘리먼트 이름의 대소문자를 구분하지 않고, 고유한 기능이 있는 다양한 속성을 사용할 수 있다. 필수 속성이 없기 때문에 아무런 속성을 설정하지 않고도 사용할 수 있다. 아무런 속성을 사용하지 않을 때는 보통 엘리먼트 내부에 스크립트 컨텐츠를 작성한다. 명세에서는 스크립트 언어가 자바스크립트라고 가정하고 있으며 다른 언어의 지원은 (적어도 현재까지는) 명세와 충돌할 것이라 선언하고 있다. … implementing other languages is in conflict with this standard, given the processing model defined for the script element. “스크립트 엘리먼트에 정의된 처리 모델을 고려해 볼 때, (자바스크립트 이외의) 다른 언어의 구현은 이 표준과 충돌할 것이다.” IE10까지만 해도 현재는 폐지된 language 속성을 사용해서 VBScript를 스크립트 언어로 사용할 수 있었는데 이 방법이 IE11부터는 공식적으로 지원이 중단되었기 때문에 주요 브라우저의 최신 버전을 기준으로 했을 때 자바스크립트 외의 스크립트 언어를 네이티브로 지원하는 브라우저는 없다. 하지만 호환성을 위해 IE11에서도 다음과 같은 헤더를 통해 IE10 모드를 켜두면 VBScript를 사용할 수 있다고 한다. 1&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=10&quot;&gt; 스크립트 컨텐츠스크립트 콘텐츠에는 유니코드 문자를 모두 사용할 수 있다. 단, 다음 세 가지 항목의 텍스트는 포함할 수 없다(관련 명세). 여는 주석 &lt;!– 닫는 주석 –&gt; 여는 스크립트 태그 &lt;script 따라서 다음과 같은 스크립트는 유효하지 않은 것으로 인식한다. 123var example = &#x27;문제 있는 문자열: &lt;!-- &lt;script&gt;&#x27;;console.log(example); 하위 호환성 문제때문에 스크립트 엘리먼트 내부에 있는 &lt;!--와 &lt;script는 항상 짝이 맞아야 파서가 정확하게 닫는 태그를 인식할 수 있다. 위 예제에서는 &lt;script는 두 번 나타난 반면 &lt;/script&gt;는 한 번 밖에 나타나지 않았기 때문에 &lt;/script&gt;는 자바스크립트 코드의 일부인 것처럼 취급된다. 물론 올바르지 않은 코드라서 자바스크립트도 실행되지 않는다. 이 문제를 해결하는 가장 쉬운 방법은 &lt;!--와 &lt;script&gt; 텍스트를 각각 &lt;\\!--와 &lt;\\script&gt;로 이스케이프 처리를 하는 것이다. 마찬가지로 다음과 같이 조건 식에 나타나는 것도 주의해야 한다. 123456789// 문제가 발생함if (x&lt;!--y) &#123; ... &#125;if ( player&lt;script ) &#123; ... &#125;// 문제가 발생하지 않음if (x &lt; !--y) &#123; ... &#125;if (!--y &gt; x ) &#123; ... &#125;if (player &lt; script)&#123; ... &#125;if (script &gt; player)&#123; ... &#125; 역시 하위호환성 때문에 스크립트 컨텐츠에 있는 &lt;!-- 기호는 한 줄 주석 //과 같이 취급된다. 그래서 다음과 같은 올바르지 않은 자바스크립트 코드도 실행할 수 있다. 1234var a = 10, b = 20;&lt;!-- a = 30; 실행되지 않는다.console.log( a + b ); 여기서 설명한 스크립트 컨텐츠의 괴상한 특성은 HTML 문서에 삽입된 스크립트 엘리먼트에 텍스트 노드로서 추가한 컨텐츠일때만 동작한다. src 속성을 사용해 외부에서 호출하는 자바스크립트 코드에는 적용되지 않으므로 주의하자. src 속성스크립트 파일을 외부에서 불러올 때 사용한다. 이 속성에 유효한 URL을 입력하면 외부의 스크립트를 불러들여서 실행한다. 불러와서 처리하는 방식은 type 속성의 값에 따라 달라질 수 있는데 이 부분은 잠시 뒤에 다루겠다. src 속성이 설정되어 있을 때 스크립트의 컨텐츠, 다시 말해 &lt;script&gt;와 &lt;/script&gt; 사이에 나타나는 텍스트 데이터에는 src가 가리키는 스크립트에 관한 설명만 추가할 수 있다. 입력 가능한 데이터는 공백(탭, 스페이스, 줄바꿈)을 포함하여 자바스크립트의 블럭 주석(/* ... */) 또는 한 줄 주석(//) 뿐이다. 명세 문서에서 예제를 가져오면 다음과 같다. 1234567&lt;script src=&quot;cool-effects.js&quot;&gt;// 새로운 인스턴스 생성:// var e = new Effect();// .play를 사용해서 효과를 시작하고 .stop을 사용해서 중단한다.// e.play();// e.stop();&lt;/script&gt; 다만 명세에서 정한 대로 사용하지 않고 주석 외의 문자열, 예를 들어 자바스크립트 코드를 입력한다고 해서 문제가 발생하지는 않는다. 그저 무시될 뿐이다. 웹 브라우저는 src 속성에 유효한 URL이 입력되어 있을 경우 그를 우선시한다. type 속성스크립트의 종류를 설정할 수 있다. 사실상 지원하는 언어는 자바스크립트 뿐이라 생략할 수 있고, 이 경우 text/javascript가 사용된다. 그 외에도 application/javascript, application/ecmascript 등 사용할 수 있는 값은 많지만 브라우저에 따라 지원하지 않는 경우도 있으므로 표준인 text/javascript를 사용하는 편이 좋다. 또한 웹 서버에서 스크립트 파일을 보내줄 때는 반드시 text/javascript를 MIME 타입을 사용해야 한다고 정하고 있다. Servers should use text&#x2F;javascript for JavaScript resources. Servers should not use other JavaScript MIME types for JavaScript resources, and must not use non-JavaScript MIME types. 자바스크립트가 아닌 다른 타입을 일부러 설정하는 경우도 있다. 이 경우엔 당연하게도 해당 코드를 자바스크립트로 인식하지 않으며 따라서 실행하지도 않고 스크립트 엘리먼트 안의 컨텐츠는 단순한 문자열 데이터 블럭이 된다. 예를 들어 Backbone 프레임워크에서는 다음과 같이 스크립트 엘리먼트에 템플릿을 설정하기도 했다(출처: Sitepoint). 12345&lt;script type=&quot;text/template&quot; id=&quot;surfboard-template&quot;&gt; &lt;td&gt;&lt;%= manufacturer %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= model %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= stock %&gt;&lt;/td&gt;&lt;/script&gt; 참고로 HTML5에는 이와 같은 용도를 위해 template 엘리먼트가 마련되어 있다. HTML5 명세에는 없지만 Living Standard 문서에 기술되어 있고, 최근 브라우저에서 새롭게 지원하기 시작한 타입으로는 module이 있다(대소문자 구분하지 않음). type 속성이 module로 설정되면 웹 브라우저는 스크립트를 module script로서 다루게 된다. 이 모드와 구분하기 위해 전통적인 방식으로 다루는 스크립트는 classic script라고 부른다. 모듈 스크립트(module script)가 되면 Node.js 혹은 Babel을 통해서나 가능하던 import 문법을 웹 브라우저에서 네이티브로 사용할 수 있다! 다음 예제를 보자(출처: Jake Archibald의 블로그) 12345&lt;script type=&quot;module&quot;&gt;import &#123;addTextToBody&#125; from &#x27;./utils.js&#x27;;addTextToBody(&#x27;Modules are pretty cool.&#x27;);&lt;/script&gt; 1234567// utils.jsexport function addTextToBody(text) &#123; const div = document.createElement(&#x27;div&#x27;); div.textContent = text; document.body.appendChild(div);&#125; ES6의 모듈이 동작하는 방식에 대해서는 스크립트 엘리먼트를 다루는 이 글의 주제를 벗어나므로 다루지 않겠지만, 아직 잘 모르고 있다면 모질라 기술 블로그의 “ES6 In Depth: 모듈(한국어)“을 읽어보기 바란다. 모듈 타입의 스크립트는 다른 모듈(위 예제에서는 utils.js)을 불러올 때 비동기 방식으로 가져오는데, 스크립트를 다운로드 하는 방식에 대해서는 잠시 뒤에 다시 다루도록 하겠다. module 타입은 Edge, Chrome, Safari, iOS, Safari, Chrome for Android 등 주요 브라우저에서 지원하고 있다. 이 글을 쓰는 시점의 최신 버전인 Firefox 59에서도 이 타입을 지원하기는 하지만 about:config 설정에서 dom.moduleScripts.enabled항목을 설정해주어야 사용할 수 있다. 자세한 내용은 아래 이미지를 참고하고, 최신 상태를 확인하고 싶다면 caniuse.com에서 조회해보도록 하자. nomodule 속성type=&quot;module&quot;을 지원하지 않는 브라우저에서 사용할 스크립트 파일을 따로 설정하는 불리언 속성이다. 12&lt;script type=&quot;module&quot; src=&quot;main.js&quot;&gt;&lt;/script&gt;&lt;script nomodule src=&quot;main.fallback.js&quot;&gt;&lt;/script&gt; 모듈 스크립트를 지원하지 않는 구식 브라우저에서는 type=&quot;module&quot;이 설정된 스크립트 엘리먼트의 src 속성을 무시하지만 두 번째 줄에 있는 src 속성은 자바스크립트 코드로서 다루게 될 것이다. 반면 모듈 스크립트를 지원하는 최신 브라우저에서는 type=&quot;module&quot;이 설정된 자바스크립트를 모듈로서 다루고 nomodule이 설정된 스크립트 엘리먼트를 무시한다. async &#x2F; defer 속성스크립트를 비동기로 읽어들이고 싶을 때 사용하는 불리언 속성들이다. 기본적으로 스크립트 엘리먼트는 HTML 파서(parser)의 동작을 중단하고 스크립트를 다운로드 후 실행하는 이른바 블러킹 모드(blocking mode)로 동작한다. 여러 스크립트 엘리먼트가 있을 경우에도 실행 순서를 보장할 수 있다는 장점은 있지만, 스크립트 파일을 다운로드하는 동안에 파싱(parsing)이 중단되므로 웹 페이지의 성능을 저하시킨다. 그런데 async 또는 defer 속성을 사용하면 다운로드는 백그라운드에서 진행되고 스크립트를 실행하는 동안만 HTML 파싱을 중단하는 소위 non-blocking 모드로 동작한다. 따라서 웹 페이지는 두 속성을 사용하지 않았을 때보다 더 빠르게 표시될 것이다. 두 속성에는 두 가지 차이가 있다. 하나는 defer는 다운로드가 먼저 끝나더라도 파싱이 완료될 때까지 기다렸다가 스크립트를 실행하지만, async는 다운로드가 끝나면 바로 스크립트를 실행한다는 것이다. 나머지 하나는 defer는 두 속성 중 아무 것도 사용하지 않았을 때와 마찬가지로 실행 순서를 보장해주지만, async는 다운로드 받은 순서대로 실행되기 때문에 실행 순서가 스크립트 엘리먼트의 출현 순서와 다를 수 있다는 것이다. 구식 브라우저에서는 defer만 지원하기도 해서 다음과 같이 두 속성을 모두 적어두기도 한다. 1&lt;script defer async src=&quot;async.js&quot;&gt;&lt;/script&gt; 위 예제와 같이 작성하면 async를 지원하는 최신 브라우저에서는 async가 defer에 우선하기 때문에 async의 특성을 따르고 구식 브라우저에서는 defer의 특성을 따른다. 모듈 스크립트에는 async만 사용할 수 있는데, async가 설정되어 있으면 관련 모듈의 다운로드가 끝난 후 바로 스크립트를 실행하지만 설정되어 있지 않으면 마치 defer처럼 웹 페이지 파싱이 끝날 때까지 기다렸다가 실행한다(위 이미지 참조). crossorigin 속성현재 문서와 다른 호스트에서 스크립트를 불러올 때 해당 스크립트를 어떻게 다룰 것인지 설정하는 속성이며 사용할 수 있는 값으로는 anonymous와 use-credentials가 있다. window.onerror로 에러를 다루는 경우 보안상의 이유때문에 출처가 같지 않은 곳에서 불러오는 스크립트에서 발생하는 에러는 그다지 도움이 되지 않는 정보만 전달된다. 다음의 예제를 통해 차이를 확인해보자. 두 예제 모두 에러가 발생하는 파일을 불러오고, 다음과 같은 코드를 사용해 window.error를 통해 에러를 #log 엘리먼트에 출력하도록 했다. 123456789101112&lt;script&gt;window.onerror = function(message, url, lineNum, columnNum, error) &#123; var log = document.getElementById(&#x27;log&#x27;); log.innerText = &#x27;&#x27; + &#x27;Error: &#x27; + message + &#x27;\\nURL: &#x27; + url + &#x27;\\nline: &#x27; + lineNum + &#x27;\\ncolumn: &#x27; + columnNum;&#125;&lt;/script&gt;&lt;pre id=&quot;log&quot;&gt;&lt;/pre&gt; crossorigin 속성을 사용하지 않은 첫 번째 예제는 다음과 같이 화면에 나타난다. 보다시피 에러 내용도 명확하지 않고 에러가 발생한 위치도 알 수 없다. 반면, crossorogin 속성을 사용해서 스크립트를 불러온 두 번째 예제에서는 다음과 같이 에러 메시지 내용이 보다 세밀하게 나타난다. 앞서 말했듯이 이 같은 동작은 잠재적인 보안 문제때문이다. 악성 웹 사이트에서 onerror를 사용해 다른 사이트에 로그인이 되었는지 확인할 수 있었기 때문이다. 예를 들어 아무 사이트에서나 Gmail 스크립트를 불러오면 다음과 같이 사용자가 Gmail에 로그인했는지 여부를 알 수 있었다(출처: Jeremiah Grossman 블로그). 따라서 이 동작은 window.onerror에 전달하는 정보에만 적용될 뿐 개발자 도구에는 적용되지 않는다. crossorigin 속성의 사용 여부와 상관없이 개발자 도구에서는 상세한 에러 정보가 표시된다. 모듈 모드에서는 crossorigin 속성의 값이 조금 다른 의미를 지닌다. 모듈 모드는 출처가 다른 스크립트를 항상 CORS 방식으로 불러온다. 즉, 다른 호스트에서 스크립트 파일을 불러오고 있는데 스크립트 파일을 보내주는 서버에서 CORS 헤더를 설정하지 않으면 스크립트가 실행되지 않는다. 기본적으로 일반 모드에서 스크립트를 불러올 때는 출처와 상관없이 쿠키 등의 인증 정보(credentials)가 서버에 전달되는데, 모듈 모드에서는 출처가 같지 않은 스크립트 파일을 불러올 때 쿠키 등의 민감한 정보를 보내지 않는다. 출처가 다른 경우에도 crossorigin 속성에 명시적으로 “use-credentials”를 설정하면 인증 정보를 서버로 전송한다. 코드로 표현해보면 다음과 같다(출처: Jake Archibald의 블로그). 1234567891011121314&lt;!-- 인증 정보(쿠키 등) 보냄 --&gt; &lt;script src=&quot;1.js&quot;&gt;&lt;/script&gt;&lt;!-- 인증 정보(쿠키 등) 보내지 않음 - 동일 출처 --&gt; &lt;script type=&quot;module&quot; src=&quot;1.js?&quot;&gt;&lt;/script&gt;&lt;!-- 인증 정보(쿠키 등) 보냄 - 동일 출처 --&gt; &lt;script type=&quot;module&quot; crossorigin src=&quot;1.js&quot;&gt;&lt;/script&gt;&lt;!-- 인증 정보(쿠키 등) 보내지 않음 - 동일 출처 아님 --&gt; &lt;script type=&quot;module&quot; crossorigin src=&quot;http://다른_호스트/1.js&quot;&gt;&lt;/script&gt;&lt;!-- 인증 정보(쿠키 등) 보냄 - 동일 출처 아님 --&gt; &lt;script type=&quot;module&quot; crossorigin=&quot;use-credentials&quot; src=&quot;http://다른_호스트/1.js&quot;&gt;&lt;/script&gt; 주의할 점은 동일 출처가 아닌 상태에서 use-credentials를 사용할 때는 서버의 응답 헤더에 Access-Control-Allow-Credentials: true가 포함되어 있어야 한다는 것이다. 사라진 속성몇 해 전까지만 해도 스크립트 엘리먼트에 charset을 사용해서 스크립트 외부 파일의 문자셋을 정해주곤 했었다. 지금과는 달리 euc-kr로 인코딩된 웹 페이지가 많았는데 스크립트 파일은 utf-8로 작성된 경우 문자가 잘못 표기되는 것을 방지하기 위해서였다. 이 속성은 HTML5에서 더 이상 지원되지 않기 때문에 사용해서는 안되는 속성이지만, 사용하는 경우에도 utf-8만 지원한다(대소문자 구분 안함). 여담이지만 아직도 euc-kr, cp949, ksc5601(모두 사실상 같은 코드)과 같은 인코딩을 사용하는 웹 페이지가 있기는 하다(네이버 카페라거나 Naver Cafe 라거나…). language 속성도 사용하면 안되는 속성이지만 사용할 경우에는 반드시 값이 “JavaScript”여야 한다(대소문자 구분안함). 참조 https://taegon.kim/archives/6804","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Javascript","slug":"Frontend/Javascript","permalink":"https://woonyzzang.github.com/categories/Frontend/Javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://woonyzzang.github.com/tags/js/"}]},{"title":"[Chrome] Webfont Cross Domain","slug":"chrome-webfont-cross-domain","date":"2019-09-22T12:04:45.000Z","updated":"2024-06-14T10:41:36.580Z","comments":true,"path":"2019/09/22/chrome-webfont-cross-domain/","permalink":"https://woonyzzang.github.com/2019/09/22/chrome-webfont-cross-domain/","excerpt":"","text":"웹폰트 크로스도메인 문제 해결https://www.example.com 의 웹폰트(CSS)를 https://example.com 으로 웹 브라우저에 접속할 때 아래와 같이 웹폰트를 로드하지 못하는 에러가 발생 될 수 있습니다. 12345Font from origin &#x27;https://www.example.com&#x27; has been blockedfrom loading by Cross-Origin Resource Sharing policy:The &#x27;Access-Control-Allow-Origin&#x27; header contains theinvalid value &#x27;*.&#x27;. Origin &#x27;https://example.com&#x27; istherefore not allowed access. 이유는 크로스도메인 문제로 아래와 같이 www.example.com 루트에 .htaccess 파일을 만들어서 넣어주면 해결 됩니다. 12345&lt;IfModule mod_headers.c&gt; &lt;FilesMatch &quot;\\.(ttf|ttc|otf|eot|woff|font.css)$&quot;&gt; Header set Access-Control-Allow-Origin &quot;*&quot; &lt;/FilesMatch&gt;&lt;/IfModule&gt; 참조 https://blog.wonhada.com/?p=1923","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"CSS","slug":"Frontend/CSS","permalink":"https://woonyzzang.github.com/categories/Frontend/CSS/"}],"tags":[{"name":"chrome","slug":"chrome","permalink":"https://woonyzzang.github.com/tags/chrome/"},{"name":"css","slug":"css","permalink":"https://woonyzzang.github.com/tags/css/"},{"name":"webfont","slug":"webfont","permalink":"https://woonyzzang.github.com/tags/webfont/"}]},{"title":"Cent OS Terminal Recording","slug":"cent-os-terminal-recording","date":"2019-09-22T12:01:49.000Z","updated":"2024-06-07T09:27:28.272Z","comments":true,"path":"2019/09/22/cent-os-terminal-recording/","permalink":"https://woonyzzang.github.com/2019/09/22/cent-os-terminal-recording/","excerpt":"","text":"터미널을 보기 쉽게 녹화하기개발 블로그를 하다보면 터미널 작업을 업로드해야 할 때가 종종 있습니다. 커맨드를 실행하면 많은 작업이 스쳐 지나가지만 보통 블로그에 올리는 것은 실행할 커맨드나 실행된 결과 화면 뿐입니다. 그래서 블로그를 참고해서 작업을 진행할 때는 이게 제대로 동작하는 것인지, 발생한 오류가 그냥 넘어가도 될만한 것인지 확인하기 어려운 경우가 많습니다. 대신 처음부터 끝까지 녹화된 화면을 올리면 어떨까요? asciinemaasciinema는 터미널 화면을 녹화하고 공유하는 툴입니다. 단순한 화면 녹화라면 이렇게 소개해드리지 않았을 겁니다. 녹화된 영상과 달리 실행 중인 커맨드를 복사할 수 있습니다. 위 영상을 재생해보시면 커맨드 복사가 가능한 것을 확인하실 수 있을 겁니다. asciinema 는 설치와 사용이 정말 쉽습니다. 사용하는 입장에서도 쉽게 포스트의 퀄리티를 높일 수 있고, 블로그를 방문한 분들도 단순 커맨드보다 도움이 되어 win-win 할 수 있는 툴입니다. 어떻게 가능할까? asciinema 를 설치하고 녹화를 시작하면 화면의 아웃풋을 모두 캡쳐해서 저장합니다. 녹화된 결과를 asciinema.org 에서 제공하는 API 를 이용해서 바로 업로드합니다. 업로드된 결과를 javascript 플레이어를 이용해서 재생합니다. asciinema 는 유닉스의 가상 터미널을 이용한 script 커맨드에서 영감을 받아 만들어졌습니다. 키보드를 이용한 사용자의 입력과 화면에 출력되는 내용, 시간 등을 캡쳐해 .ascii 포맷으로 메모리에 저장합니다. 이는 ANSI escape code 에 따라서 커서의 위치, 색깔 등 여러 정보가 저장됩니다. 녹화된 파일은 사용자의 선택에 따라 asciinema.org 에 업로드되고, 업로드된 영상은 ANSI-compatible video terminals parser 를 이용해서 파싱 후 재생됩니다. 이는 iTerm, xterm, Gnome Terminal 등 여러 터미널에서도 잘 동작합니다. 이러한 작업으로 인해 단순 영상 재생이 아니라 텍스트 복사가 가능해집니다. 설치하기asciinema 는 리눅스와 macOS 에서 동작합니다. 123456789101112131415# macOS (Homebrew)$ brew install asciinema# Ubuntu$ sudo apt-add-repository ppa:zanchey/asciinema$ sudo apt-get update$ sudo apt-get install asciinema# Fedora 21 버전 이하$ sudo yum install asciinema# Fedora 22 버전 이상$ sudo dnf install asciinema# Pip (Python 3)$ sudo pip3 install asciinema 이외에 가능한 버전과 설치 방법은 링크를 참고하세요. 녹화하기 asciinema rec 녹화를 시작합니다. 녹화할 작업을 합니다. exit 를 입력하거나 Ctrl + d 로 녹화를 중지합니다. 완료된 작업은 Enter 를 눌러 바로 업로드하고 업로드된 url 을 확인합니다. 혹은 Ctrl + c 를 눌러 업로드하지 않고 로컬에 저장합니다. 녹화 후 업로드된 파일을 관리하기 위해서 asciinema.org 에서 가입한 계정 정보와 터미널을 연동시킬 수 있습니다. 로컬에서 파일로 관리하는 것보다 편하고, 녹화한 영상을 활용하기에도 편해서 이 방법을 추천드립니다. 1$ asciinema auth Hexo 에 영상 추가하기이제 녹화한 영상을 Hexo 블로그에 첨부해보도록 하겠습니다. hexo-tag-asciinema플러그인을 사용하면 아주 쉽게 추가가 가능합니다. 설치부터 해보겠습니다. 1$ npm install --save hexo-tag-asciinema 설치된 플러그인은 다음과 같이 사용할 수 있습니다. 1&#123;% asciinema video_id %&#125; 위 영상 마지막에 보면 업로드 후에는 업로드된 url 을 확인할 수 있는데요, 이 뒤에 붙어있는 것이 video_id 입니다. https://asciinema.org/a/187354 그럼 다음처럼 쉽게 영상을 첨부할 수 있습니다. 1&#123;% asciinema 187354 %&#125; 쉽게 터미널을 녹화하고 공유할 수 있는 툴인 asciinema 를 살펴봤습니다. 참조 https://futurecreator.github.io/2018/06/16/record-terminal-asciinema/ https://asciinema.org/docs/how-it-works https://github.com/asciinema/asciinema/blob/master/doc/asciicast-v1.md","categories":[{"name":"OS","slug":"OS","permalink":"https://woonyzzang.github.com/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"https://woonyzzang.github.com/categories/OS/Linux/"},{"name":"CentOS","slug":"OS/Linux/CentOS","permalink":"https://woonyzzang.github.com/categories/OS/Linux/CentOS/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://woonyzzang.github.com/tags/linux/"},{"name":"centos","slug":"centos","permalink":"https://woonyzzang.github.com/tags/centos/"}]},{"title":"Cent OS Tomcat 9 수동 설치","slug":"cent-os-tomcat9-install","date":"2019-09-16T16:11:15.000Z","updated":"2024-06-07T09:27:28.272Z","comments":true,"path":"2019/09/17/cent-os-tomcat9-install/","permalink":"https://woonyzzang.github.com/2019/09/17/cent-os-tomcat9-install/","excerpt":"","text":"Tomcat 9 수동 설치CentOS 7.2 에서 yum으로 tomcat을 설치하면 tomcat 7 이 설치된다. 현재 tomcat은 9버전 이 최신 버전이고 이를 설치하려면 아래와 같이 진행하면 됩니다. 1. tomcat 다운로드 다운로드: https://tomcat.apache.org/download-90.cgi 1$ curl -O http://mirror.navercorp.com/apache/tomcat/tomcat-9/v9.0.24/bin/apache-tomcat-9.0.24.tar.gz 2. 다운로드 받은 화일의 압축을 풀고 &#x2F;usr&#x2F;local 디렉토리로 이동합니다.(&#x2F;usr&#x2F;local 에 설치)1234$ tar -xf apache-tomcat-9.0.24.tar.gz$ mv apache-tomcat-9.0.24 /usr/local$ cd /usr/local$ mv apache-tomcat-9.0.24 tomcat 3. tomcat user와 group 생성하고, tomcat 화일의 소유권 변경합니다.1234$ useradd tomcat$ groupadd tomcat$ cd /usr/local$ chown -R tomcat:tomcat tomcat 4. systemd가 tomcat데몬을 제어하도록 등록합니다. 등록하지 않으면, &#x2F;opt&#x2F;tomcat&#x2F;bin&#x2F; 디렉토리에서 스크립트를 이용하여 데몬을 실행, 정지해야 합니다./etc/systemd/system/tomcat.service 파일을 생성하고 아래 코드르 등록합니다. 1234567891011121314151617[Unit]Description=Apache Tomcat 9After=syslog.target network.target[Service]User=tomcatGroup=tomcatType=forkingEnvironment=CATALINA_PID=/usr/local/tomcat/tomcat.pidEnvironment=CATALINA_HOME=/usr/local/tomcatEnvironment=CATALINA_BASE=/usr/local/tomcatExecStart=/usr/local/tomcat/bin/startup.shExecStop=/usr/local/tomcat/bin/shutdown.shRestart=on-failure[Install] WantedBy=multi-user.target 아래 명령어로 tomcat을 systemd 에 등록하고, tomcat을 실행해 봅니다. 1234$ systemctl daemon-reload$ systemctl enable tomcatCreated symlink from /etc/systemd/system/multi-user.target.wants/tomcat.service to /etc/systemd/system/tomcat.service.$ systemctl start tomcat 5. 웹 브라우저에서 http:&#x2F;&#x2F;:8080 으로 접속합니다.( 는 tomcat이 설치된 서버)페이지에 접속은 잘 되지만, manager와 host-manager, server status는 접속되지 않습니다. 이것은, localhost에서만 접속되도록 설정이 되어 있기 때문인데, 아래 파일에서 관련 부분을 주석 처리 합니다. /usr/local/tomcat/webapps/manager/META-INF/context.xml 수정(주석처리) 123&lt;Context antiResourceLocking=&quot;false&quot; privileged=&quot;true&quot; &gt;&lt;!-- &lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot; allow=&quot;127\\.\\d+\\.\\d+\\.\\d+|::1|0:0:0:0:0:0:0:1&quot; /&gt; --&gt; /usr/local/tomcat/webapps/host-manager/META-INF/context.xml 수정(주석처리) 12&lt;!-- &lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot; allow=&quot;127\\.\\d+\\.\\d+\\.\\d+|::1|0:0:0:0:0:0:0:1&quot; /&gt; --&gt; 이제, 아래 role과 user를 등록해주면 manager, host manager 에 접속이 가능해 집니다. /usr/local/tomcat/conf/tomcat-users.xml 수정 12345678910111213&lt;!-- &lt;role rolename=&quot;tomcat&quot;/&gt; &lt;role rolename=&quot;role1&quot;/&gt; &lt;user username=&quot;tomcat&quot; password=&quot;&lt;must-be-changed&gt;&quot; roles=&quot;tomcat&quot;/&gt; &lt;user username=&quot;both&quot; password=&quot;&lt;must-be-changed&gt;&quot; roles=&quot;tomcat,role1&quot;/&gt; &lt;user username=&quot;role1&quot; password=&quot;&lt;must-be-changed&gt;&quot; roles=&quot;role1&quot;/&gt;--&gt; &lt;role rolename=&quot;tomcat&quot;/&gt; &lt;role rolename=&quot;admin-gui&quot;/&gt; &lt;role rolename=&quot;manager-gui&quot;/&gt; &lt;role rolename=&quot;manager-status&quot;/&gt; &lt;user username=&quot;admin&quot; password=&quot;passwd&quot; roles=&quot;manager-gui,admin-gui,manager-status&quot; /&gt;&lt;/tomcat-users&gt; 모든 ip 접속 가능 설정/usr/local/tomcat/latest/webapps/manager/META-INF/context.xml 수정 123456&lt;Context antiResourceLocking=&quot;false&quot; privileged=&quot;true&quot; &gt;&lt;!-- &lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot; allow=&quot;127\\.\\d+\\.\\d+\\.\\d+|::1|0:0:0:0:0:0:0:1&quot; /&gt; &lt;Manager sessionAttributeValueClassNameFilter=&quot;java\\.lang\\.(?:Boolean|Integer|Long|Number|String)|org\\.apache\\.catalina\\.filters\\.CsrfPreventionFilter\\$LruCache(?:\\$1)?|java\\.util\\.(?:Linked)?HashMap&quot;/&gt;--&gt;&lt;/Context&gt; /usr/local/tomcat/latest/webapps/host-manager/META-INF/context.xml 수정 12345&lt;!-- &lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot; allow=&quot;127\\.\\d+\\.\\d+\\.\\d+|::1|0:0:0:0:0:0:0:1&quot; /&gt; &lt;Manager sessionAttributeValueClassNameFilter=&quot;java\\.lang\\.(?:Boolean|Integer|Long|Number|String)|org\\.apache\\.catalina\\.filters\\.CsrfPreventionFilter\\$LruCache(?:\\$1)?|java\\.util\\.(?:Linked)?HashMap&quot;/&gt;--&gt;&lt;/Context&gt; 설정변경후 tomcat 재시작 합니다. 1$ systemctl restart tomcat http:&#x2F;&#x2F;:8080&#x2F;manager&#x2F;html 에 접속 합니다. tomcat-users.xml 에 설정된 admin &#x2F; password 을 입력 합니다. 응용프로그램 을 배포, 배포해제 , 시작 , 중시 및 리로드 할수 있습니다. Tomcat 가상 호스트 관리자 대시보드 접속 http:&#x2F;&#x2F;:8080&#x2F;host-manager&#x2F;html 에 접속 합니다. Tomcat 가상 호스트를 생성, 삭제 및 관리 할수 있습니다. 참조 https://blog.boxcorea.com/wp/archives/2405 http://dev.crois.net/2019/02/10/centos7-tomcat-9-install/","categories":[{"name":"OS","slug":"OS","permalink":"https://woonyzzang.github.com/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"https://woonyzzang.github.com/categories/OS/Linux/"},{"name":"CentOS","slug":"OS/Linux/CentOS","permalink":"https://woonyzzang.github.com/categories/OS/Linux/CentOS/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://woonyzzang.github.com/tags/linux/"},{"name":"centos","slug":"centos","permalink":"https://woonyzzang.github.com/tags/centos/"}]},{"title":"Cent OS Apache와 Tomcat 연동","slug":"cent-os-apache-tomcat","date":"2019-09-16T16:08:39.000Z","updated":"2024-06-07T09:27:28.270Z","comments":true,"path":"2019/09/17/cent-os-apache-tomcat/","permalink":"https://woonyzzang.github.com/2019/09/17/cent-os-apache-tomcat/","excerpt":"","text":"Apache와 Tomcat 연동Tomcat도 단독으로 서비스를 할 수 있으나 보편적으로 Apache와 연동하여 사용하는 경우가 많습니다. 그 이유는 아래와 같습니다. 정적컨텐츠의 서비스 속도(이미지 동영상의 경우 Apache가 빠름) 여러 대의 Apache와 Tomcat서버의 클러스터링 구성 Apache 웹서버의 다양한 모듈 확장 보안 강화 연동 방식은 mod_jk, mod_proxy, mod_prox_ajp 세가지 방식이 존재한다고 합니다만, 이중에서 mod_jk 방식을 살펴 보겠습니다.대체적으로 보통 mod_jk로 연동하는 경우가 많고, 나머지 2가지에 비해 URL 또는 컨텐츠별 설정이 쉽다고 합니다. 1. mod_jk설치 mod_jk를 설치 하려면 gcc, gcc-c++, httpd-devel 세가지 패키지가 설치되어 있어야 합니다. 아래 명령어를 입력하여 3가지 패키지를 모두 설치합니다. 1$ yum install gcc gcc-c++ httpd-devel http://tomcat.apache.org/download-connectors.cgi 링크 위치 주소로 방문하여 최신 다운로드 파일 링크를 확인 합니다. 화면 중간에 보시면 tar.gz파일의 링크가 있습니다. 우클릭하여 링크 주소 복사 를 통해 링크를 카피합니다. 다운로드 받을 디렉토리 위치로 이동한 후 파일을 아래의 명령어로 다운로드 받습니다. 123$ wget -c &#123;&#123;링크카피주소&#125;&#125;$ wgwt -c http://mirror.navercorp.com/apache/tomcat/tomcat-connectors/jk/tomcat-connectors-1.2.46-src.tar.gz 다운로드 받은 파일의 확장자가 tar.gz입니다. 이는 압축파일이며, 압축파일을 해제하기 위해 아래의 명령어를 실행합니다. 1$ tar zxvf tomcat-connector* 압축이 풀리며 디렉토리가 생성된 것을 확인할 수 있습니다. 생성된 디렉토리 안에 native디렉토리로 들어갑니다. Makefile을 생성하기 위해 아래 명령어를 실행합니다. 옵션 내용은 Apache확장기능 설치를 도와주는 유틸리티의 경로입니다. 기본 설치 경로는 /usr/bin 입니다. 혹, 경로에 찾을수 없다는 에러가 발생하신다면 /usr/sbin 의 경로도 한번 살펴보시기 바랍니다. 1$ ./configure --with-apxs=/usr/bin/apxs make명령어로 컴파일을 실행합니다. 1$ make 컴파일 완료후 install 합니다. 1$ make install 참고로 다음과 같은 명령어를 사용해서 컴파일과 install 을 동시에 실행할 수도 있습니다. 1$ make &amp;&amp; make install install 후 /etc/httpd/modules/ 경로의 파일 안에 mod_jk.so 파일이 생성되어있음을 확인할 수 있습니다. Selinux의 보안관련 설정을 변경해주어야 하는데요, 아래의 명령어를 실행합니다. 1$ chcon -u system_u -r object_r -t httpd_modules_t /etc/httpd/modules/mod_jk.so 2. Apache 설정 Apache의 설정은 /etc/httpd/conf/httpd.conf 파일인데 vi 에디터로 오픈합니다. vi에디터 창에서 / 를 누르고 LoadModule 단어를 검색 키워드로 찾아(엔터후 n버튼을 누르면 다음찾기가 됩니다.) 그 아래쪽에 다음의 내용을 추가합니다. httpd.conf 파일 12345678910111213141516171819...## Dynamic Shared Object (DSO) Support## To be able to use the functionality of a module which was built as a DSO you# have to place corresponding `LoadModule&#x27; lines at this location so the# directives contained in it are actually available _before_ they are used.# Statically compiled modules (those listed by `httpd -l&#x27;) do not need# to be loaded here.## Example:# LoadModule foo_module modules/mod_foo.so#Include conf.modules.d/*.confLoadModule jk_module modules/mod_jk.so // 추가... Apache의 가상 호스트 /etc/httpd/conf/extra/httpd-vhosts.conf 파일도 아래 코드를 추가 합니다. httpd-vhosts.conf 파일은 httpd.conf 에 가상호스트 include 설정이 되어 있어야 합니다. httpd-vhosts.conf 파일 123456789&lt;VirtualHost *:80&gt; ServerName localhost # 확장자 jsp, json, xml, do를 가진 경로는 woker worker1 으로 연결하는 구문입니다. JkMount /*.jsp worker1 JkMount /*.do worker1 JkMount /*.json worker1 JkMount /*.xml worker1 &lt;/VirtualHost&gt; 화면에 보시면 conf.modules.d 경로가 include가 된 것을 볼 수 있습니다. /etc/httpd/conf.modules.d 경로에 진입하여 vi mod_jk.conf 를 실행하여 새로운 설정파일을 오픈 합니다. 1$ vi /etc/httpd/conf.modules.d/mod_jk.conf 123456789101112&lt;IfModule mod_jk.c&gt; # 워커 설정파일 위치 JkWorkersFile conf/workers_jk.properties # 공유 메모리파일 위치 반드시 Selinux 보안때문에 run에 위치 필수 JkShmFile run/mod_jk.shm # log 위치 JkLogFile logs/mod_jk.log # 로그레벨 설정 JkLogLevel info # 로그 포맷에 사용할 시간 형식을 지정한다. JkLogStampFormat &quot;[%y %m %d %H:%M:%S]&quot; &lt;/IfModule&gt; vi 에디터에서 :wq 로 저장하고 빠져 나옵니다. 이제 mod_jk.conf 파일에서 설정한 워커 설정 파일을 만들 차례 입니다. 설정한 경로가 &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;workers_jk.properties 입니다. vi 로 해당경로 를 오픈하여 파일을 생성합니다. 1$ vi /etc/httpd/conf/workers_jk.properties 123456worker.list=worker1worker.tomcat.port=8009 worker.tomcat.host=localhost worker.tomcat.type=ajp13 worker.tomcat.lbfactor=1 port를 8009로 설정함은 tomcat의 server.xml설정에 기인합니다. 확인은 아래에서 가능합니다. 1$ vi /usr/share/tomcat/conf/server.xml tomcat 은 기본 URIEncoding 이 ISO-8859-1 이므로 한글이 깨지므로 모든 커넥터 설정에 URIEncoding=&quot;UTF-8&quot; 을 추가해야 합니다. 1&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot;/&gt; /etc/httpd/conf/extra/httpd-vhosts.conf 파일을 열어 Apache와 Tomcat Document 위치를 맞추어줍니다. 이부분을 맞추어 주지 않으면 jsp 파일은 보이지만 이미지와 CSS가 로드 되지 않습니다. httpd-vhosts.conf 파일을 오픈하여 DocumentRoot 구문에 Tomcat의 문서 경로로 변경해줍니다. &#x2F;usr&#x2F;share&#x2F;tomcat&#x2F;webapps&#x2F;ROOT 입니다. 1$ vi /etc/httpd/conf/extra/httpd-vhosts.conf 1234567891011121314151617&lt;VirtualHost *:80&gt; ServerAdmin seungwoon@gmail.com DocumentRoot /usr/share/tomcat/webapps/ # // 추가 ServerName localhost # // 추가 &lt;Directory &quot;/usr/share/tomcat/webapps/ROOT/&quot;&gt; AllowOverride none Require all granted &lt;/Directory&gt; # 확장자 jsp, json, xml, do를 가진 경로는 woker tomcat으로 연결하는 구문입니다. JkMount /*.jsp worker1 JkMount /*.do worker1 JkMount /*.xml worker1 JkMount /*.json worker1&lt;/VirtualHost&gt; /etc/httpd/conf/httpd.conf 파일을 열어 기본 인덱스 설정에 index.jsp 를 추가 합니다. 123456789101112## DirectoryIndex: sets the file that Apache will serve if a directory# is requested.# // 변경 전&lt;IfModule dir_module&gt; DirectoryIndex index.html&lt;/IfModule&gt;# 변경 후&lt;IfModule dir_module&gt; DirectoryIndex index.html index.jsp&lt;/IfModule&gt; 마지막으로 아랫부분의 SELinux 설정을 해줍니다. 1$ chcon -R --type=httpd_sys_rw_content_t /usr/share/tomcat/webapps/ROOT 만약 위 명령어 실행 시 에러가 발생하면 setenforce 0 명령어로 SELinux 임시 해제 후 SELinux 설정을 한 후 setenforce 1 명령어로 SELinux 실행 합니다. 123$ setenforce 0 // SELinux 끄기$ chcon -R --type=httpd_sys_rw_content_t /usr/share/tomcat/webapps/ROOT$ setenforce 1 // SELinux 켜기 아파치를 재시작 합니다. 1$ systemctl restart httpd 톰캣을 재시작 합니다. 1$ systemctl restart tomcat 이제 결과를 확인 하기 위하여 http:&#x2F;&#x2F;&#x2F;index.jsp로 접속합니다. 8080포트 없이 진입했는데 Tomcat화면이 나오시면 성공입니다. 그러면 보시는 바와 같이 톰캣 페이지가 응답이 되지만, CSS, image 등이 제외된 상태로 HTML 문서만 응답이 됩니다. 그 이유는 아파치 환경 설정에서 tomcat connection 에서 설정한 JkMount 옵션 때문입니다..jsp 파일만 worker가 처리하도록 보냈기 때문에, 정적 파일들은 아파치에서 응답해야 합니다.하지만 아파치에는 톰캣 페이지에서 제공해야 하는 정적 파일들이 없기 때문에 톰캣에서 받아온 HTML 문서만 응답할 수 밖에 없습니다. 이로 미루어 보아, worker를 통해 아파치가 톰캣으로부터 jsp파일만 가져온 것을 확인할 수 있습니다.즉, 아파치와 톰캣이 연동된 것입니다. 간단한 애플리케이션이 있다면 worker를 수정해서 80포트로 접근했을 때 애플리케이션을 응답할 수 있도록 설정할 수 있습니다.Tomcat Manager에서 웹 애플리케이션을 deploy 했을 때, 그 이름을 example 이라고 하겠습니다.그러면 JkMount를 다음과 같이 수정해서 웹 애플리케이션이 아파치와 연동되서 실행될 수 있습니다 1$ vi /etc/httpd/conf/extra/httpd-vhosts.conf Tomcat connection 부분의 JkMount를 아래와 같이 수정합니다. 123456789101112&lt;VirtualHost *:80&gt; ServerAdmin example@gmail.com DocumentRoot /usr/share/tomcat/webapps/ ServerName localhost &lt;Directory &quot;/usr/share/tomcat/webapps/ROOT/&quot;&gt; AllowOverride none Require all granted &lt;/Directory&gt; JkMount /example/* worker1 # // 수정&lt;/VirtualHost&gt; 다시 아파치를 재시작 합니다. 1$ systemctl restart httpd 브라우저에서 http:&#x2F;&#x2F;&#x2F;example&#x2F;~~ )에 접속해봅니다. 만약에 리소스 파일 계속 접근이 안된다면 /usr/share/tomcat/webapps/ROOT 디렉토리의 파일권한을 755로 변경 해줍니다. Tomcat ROOT 디렉토리로 변경/usr/share/tomcat/conf/server.xml 파일에서 아래 처럼 변경 후 톰캣 재시작을 합니다. 123456789101112# // 변경 전&lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt; ...&lt;/Host&gt;# 변경 후&lt;Host name=&quot;localhost&quot; appBase=&quot;/home/www&quot; unpackWARs=&quot;false&quot; autoDeploy=&quot;false&quot;&gt; &lt;Context path=&quot;/&quot; docBase=&quot;.&quot; reloadable=&quot;false&quot; /&gt; ...&lt;/Host&gt; WAR 파일 수동 압축 풀기1$ jar xvf &lt;war파일이름&gt;.war 입력 :8080포트 차단하기 vi 에디터로 /usr/share/tomcat/conf/server.xml 파일을 오픈 합니다. Connector port가 8080 으로 되어 있는데 이부분을 80 으로 변경하면 됩니다. 1234567891011121314151617181920...&lt;!-- A &quot;Connector&quot; represents an endpoint by which requests are received and responses are returned. Documentation at : Java HTTP Connector: /docs/config/http.html (blocking &amp; non-blocking) Java AJP Connector: /docs/config/ajp.html APR (HTTP/AJP) Connector: /docs/apr.html Define a non-SSL HTTP/1.1 Connector on port 8080--&gt;&lt;!-- // 변경 전 --&gt;&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;&lt;!-- // 변경 후 --&gt;&lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;... 참조 https://suwoni-codelab.com/linux/2017/05/29/Linux-CentOS-Apache-Tomcat/ https://goddaehee.tistory.com/77 https://victorydntmd.tistory.com/225","categories":[{"name":"OS","slug":"OS","permalink":"https://woonyzzang.github.com/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"https://woonyzzang.github.com/categories/OS/Linux/"},{"name":"CentOS","slug":"OS/Linux/CentOS","permalink":"https://woonyzzang.github.com/categories/OS/Linux/CentOS/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://woonyzzang.github.com/tags/linux/"},{"name":"centos","slug":"centos","permalink":"https://woonyzzang.github.com/tags/centos/"}]},{"title":"Cent OS Tomcat 설치","slug":"cent-os-tomcat-install","date":"2019-09-16T16:03:33.000Z","updated":"2024-06-07T09:27:28.272Z","comments":true,"path":"2019/09/17/cent-os-tomcat-install/","permalink":"https://woonyzzang.github.com/2019/09/17/cent-os-tomcat-install/","excerpt":"","text":"Tomcat 설치 설치 옵션에 따라 Tomcat이 이미 설치가 되어 있을 수 있습니다. 확인은 아래의 명령어로 확인합니다. 1$ yum list installed | grep tomcat 설치가 되어있다면 아래 처럼 확인 할 수 있습니다. 설치가 되어 있지 않은 경우는 아래의 명령어로 설치를 진행합니다. 1$ yum install -y tomcat* Tomcat 도 같은 중요 인프라를 직접 소스를 컴파일해서 사용하는 방법도 있으나 직접 소스를 컴파일 하는 방법은 버그나 취약점도 직접 대응 해야하는 문제가 생겨 패키지 설치를 더 권장한다고 합니다. Tomcat의 설치 된 경로는 아래와 같이 /usr/share/tomcat 에서 확인할 수 있습니다. Java oracle jdk 버전 설치 Tomcat의 설치의 경우 한가지를 더 설치를 해줘야 합니다. 아래를 살펴보시겠습니다. 위 스크린샷을 살펴보시면 jdk 가 오라클 사의 jdk 가 아닌 openjdk로 이루어져있습니다. 대부분의 소프트웨어가 오라클 사의 jdk로 개발 및 테스트가 이루어지기 때문에 오라클 사의 jdk를 설치하는 것이 더 안정적일 것입니다. 리눅스가 아닌 다른 PC 에서 오라클 사의 웹사이트로 들어가서 화면에서 아래쪽 jdk Download 항목으로 들어갑니다. http://www.oracle.com/technetwork/java/javase/downloads/index.html jdk Download 부분을 클릭하여 들어가면 스크린샷과 같이 운영체제별 jdk 설치 파일들이 보이는데 사용하시는 컴퓨터가 64비트 일경우 linux x64 의 확장자 rpm 으로 되어 있는 파일을, 32비트 일 경우 x86 중 확장자 rpm으로 되어 있는 파일을 다운로드 받습니다. 다운로드 받으신후 크롬의 경우에는 브라우저 우측 메뉴에 다운로드 메뉴를 확인하실 수있습니다. 확인이 려우시면 주소창에서 chrome://downloads 를 입력하셔도 됩니다. 다운로드 창에서 아래와 같이 링크 주소 복사 를 클릭합니다. 다운로드 받을 링크 주소를 복사 한 후 다운로드 받을 만한 디렉토리로 이동하셔서 wget 명령어를 통해 파일을 다운로드 받습니다. -c 옵션은 이어받기 옵션입니다. 그리고 주의할 점이 하나 있습니다. 이 글을 준비하면서 처음 알게 된 내용인데요, 파일을 다운로드 -&gt; 리눅스에서 wget 명령어를 실행하는 과정까지 시간을 빠르게 하셔야 합니다. 오라클 홈페이지의 보안인듯 한데요. 만약에 그 과정에서 시간이 오래 지체 되면 다운로드가 되지 않았습니다.글을 쓰다보니 길게 늘어졌는데 이상하게 다운로드가 안되었습니다. 다운로드를 눌러 놓고 빠르게 링크를 복사 한후 콘솔창에서 다운로드 받으시기를 바랍니다. 1$ wget -c &#123;&#123;다운로드링크주소&#125;&#125; 다운로드 후 보시게 되면 확장자가 rpm이 아니라 링크 주소의 뒤 파라미터까지 같이 따라 붙게 되는데요 파일명을 mv 명령어로 수정 해줍니다. 파일명을 일일이 입력하시기 어려울 때는 파일명을 약간 입력하시고 TAB키를 실행하시면 자동완성이 됩니다~ 1$ mv jdk-8u131-linux-x64.rpm\\?AuthParam\\=1495957368_9164317af788b0392a02d2334b6dc573 jdk-8u131-linux-x64.rpm 이름을 변경하신 파일을 rpm 명령어로 설치를 진행합니다. i옵션은 설치, v옵션은 설치 정보 보여주기, h hash 문자로 설치 진행을 보여주는 옵션입니다. 1$ rpm -ivh jdk-8u131-linux-x64.rpm 기본적으로 Java는 여러버전을 한꺼번에 설치할 수 있습니다. 여러버전에서 기본 사용할 Java를 설정할수 있는데요. alternatives 명령어로 변경할 수 있습니다. 아래의 명령어를 입력하시고 설치하신 Java의 번호를 입력하시면 됩니다. 1$ alternatives --config java Java openjdk 버전으로 설치 설치 옵션에 따라 Tomcat이 이미 설치가 되어 있을 수 있습니다. 확인은 아래의 명령어로 확인합니다. 1$ yum list java*jdk-devel 설치 리스트 목록의 java 버전으로 설치 가능 합니다. 1$ yum install java-1.8.0-openjdk-devel.x86_64 설치 확인 1$ rpm -qa java*jdk-devel 1$ javac -version Tomcat 실행 설치가 완료되면 방화벽을 설정해줍니다. 12$ firewall-cmd --permanent --add-port=8080/tcp $ firewall-cmd --reload 방화벽 관련 파일 경로는 /etc/firewalld/zones/publlic.xml 파일에 설정 됩니다. 이제 서비스를 활성화 시키고 부팅시 실행이 되게 해줍니다. 1$ systemctl enable tomcat 서비스를 시작합니다. 1$ systemctl start tomcat 서비스 접속을 웹브라우저를 통해 ip와 포트번호 8080을 입력하고 접속 확인을 합니다. http:&#x2F;&#x2F;{아이피주소}:8080 참조 https://suwoni-codelab.com/linux/2017/05/28/Linux-CentOS-Tomcat/ https://zetawiki.com/wiki/CentOS_JDK_%EC%84%A4%EC%B9%98 http://apache.mirror.cdnetworks.com/tomcat/tomcat-connectors/jk/tomcat-connectors-1.2.46-src.tar.gz","categories":[{"name":"OS","slug":"OS","permalink":"https://woonyzzang.github.com/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"https://woonyzzang.github.com/categories/OS/Linux/"},{"name":"CentOS","slug":"OS/Linux/CentOS","permalink":"https://woonyzzang.github.com/categories/OS/Linux/CentOS/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://woonyzzang.github.com/tags/linux/"},{"name":"centos","slug":"centos","permalink":"https://woonyzzang.github.com/tags/centos/"}]},{"title":"Cent OS Apache 웹서버 설치","slug":"cent-os-apache-install","date":"2019-09-16T16:00:51.000Z","updated":"2024-06-07T09:27:28.269Z","comments":true,"path":"2019/09/17/cent-os-apache-install/","permalink":"https://woonyzzang.github.com/2019/09/17/cent-os-apache-install/","excerpt":"","text":"Apache 설치 설치 옵션에 따라 Apache Web Server 설치가 이미 되어 있을 수 있습니다. 설치가 되어있다면 아래 처럼 확인 할 수 있습니다. 설치가 되어 있지 않은 경우는 아래의 명령어로 설치를 진행합니다. 1$ yum install -y httpd Apache 같은 중요 인프라를 직접 소스를 컴파일해서 사용하는 방법도 있으나 직접 소스를 컴파일 하는 방법은 버그나 취약점도 직접 대응 해야하는 문제가 생겨 패키지 설치를 더 권장한다고 합니다. 설치 후 잠시 설정파일과 로그 파일이 위치한 곳을 확인 해보겠습니다. 경로는 /etc/httpd 입니다 주요 디렉토리 설명 conf: 웹 서버의 주요 설정 파일인 httpd.conf, MIME 형식을 지정하기 위한 파일인 magic 파일이 있는 곳 conf.d: 아파치의 주요설정을 분리 해서 저장 하는 곳, httpd.conf 설정내용을 분리하여 이곳에 저장하면, httpd.conf 파일에서 불러와서 사용하게 됩니다. httpd.conf 파일 맨 마지막에 IncludeOptional conf.d/*.conf 구문이 있습니다. logs: 로그파일이 저장 되는 디렉토리 modules: 아파치 모듈 설치디렉토리 설치가 완료되면 방화벽을 설정해줍니다. 123$ firewall-cmd --permanent --add-service=http $ firewall-cmd --permanent --add-service=https $ firewall-cmd --reload 방화벽 관련 파일 경로는 /etc/firewalld/zones/publlic.xml 파일에 설정 됩니다. 이제 서비스를 활성화 시키고 부팅시 실행이 되게 해줍니다. 1$ systemctl enable httpd 서비스를 시작합니다 1$ systemctl start httpd 서비스 접속을 웹브라우저를 통해 ip를 입력하고 접속 확인을 합니다. http:&#x2F;&#x2F;{아이피주소} 웹브라우저에서 위 화면이 오면 Apache 설치 및 구동이 완료되었습니다. 글을 마치기 전에 배포 디렉토리를 살펴보겠습니다. &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf 파일을 vi로 열어보면 아래와 같은 구문이 보입니다. 경로는 &#x2F;var&#x2F;www&#x2F;html 에 문서를 위치하면 화면에 뿌려 주게됩니다. 123&lt;IfModule dir_module&gt; DirectoryIndex index.html &lt;/IfModule&gt; &#x2F;var&#x2F;www&#x2F;html 경로의 디렉토리에 들어가시면 파일이 존재하지 않습니다.여기에 vi 에디터로 index.html 파일을 생성하고 저장하신 후 다시 사이트로 들어가시면 자신이 저장한 index.html파일이 화면에 뿌려지는 것을 확인하실 수 있습니다. httpd.conf 수정으로 기본 home 디렉토리의 경로를 변경시 403 Forbidden You don’t have permission to access / on this server. 접근 권한 에러가 나타날 수 있습니다. SELinux 방화벽 해제를 하고 접근이 되는지 확인해 볼 수 있습니다. 1$ setenforce 0 httpd.conf 파일 수정12345678910111213# If you wish httpd to run as a different user or group, you must run# httpd as root initially and it will switch. # // 변경 전# User/Group: The name (or #number) of the user/group to run httpd as.# It is usually good practice to create a dedicated user and group for# running httpd, as with most system services.#User apacheGroup apache# // 변경 후User nobodyGroup nobody 1234567891011# ServerName gives the name and port that the server uses to identify itself.# This can often be determined automatically, but we recommend you specify# it explicitly to prevent problems during startup.## If your host doesn&#x27;t have a registered DNS name, enter its IP address here.# // 변경 전#ServerName www.example.com:80# // 변경 후ServerName &#123;서버아이피주소&#125;:80 12345678910111213# Relax access to content within /var/www.# // 변경 전&lt;Directory &quot;/var/www&quot;&gt; AllowOverride None # Allow open access: Require all granted&lt;/Directory&gt;# // 변경 후&lt;Directory &quot;/&quot;&gt; AllowOverride None Require all granted&lt;/Directory&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# Further relax access to the default document root:# // 변경 전&lt;Directory &quot;/var/www/html&quot;&gt; # # Possible values for the Options directive are &quot;None&quot;, &quot;All&quot;, # or any combination of: # Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews # # Note that &quot;MultiViews&quot; must be named *explicitly* --- &quot;Options All&quot; # doesn&#x27;t give it to you. # # The Options directive is both complicated and important. Please see # http://httpd.apache.org/docs/2.4/mod/core.html#options # for more information. # Options Indexes FollowSymLinks # # AllowOverride controls what directives may be placed in .htaccess files. # It can be &quot;All&quot;, &quot;None&quot;, or any combination of the keywords: # Options FileInfo AuthConfig Limit # AllowOverride None # # Controls who can get stuff from this server. # Require all granted&lt;/Directory&gt;# // 변경 후&lt;Directory &quot;/var/www/html&quot;&gt; # # Possible values for the Options directive are &quot;None&quot;, &quot;All&quot;, # or any combination of: # Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews # # Note that &quot;MultiViews&quot; must be named *explicitly* --- &quot;Options All&quot; # doesn&#x27;t give it to you. # # The Options directive is both complicated and important. Please see # http://httpd.apache.org/docs/2.4/mod/core.html#options # for more information. # Options Indexes FollowSymLinks # # AllowOverride controls what directives may be placed in .htaccess files. # It can be &quot;All&quot;, &quot;None&quot;, or any combination of the keywords: # Options FileInfo AuthConfig Limit # AllowOverride None # # Controls who can get stuff from this server. # Order allow,deny Allow from all&lt;/Directory&gt; 1234567891011# DirectoryIndex: sets the file that Apache will serve if a directory# is requested.# // 변경 전&lt;IfModule dir_module&gt; DirectoryIndex index.html&lt;/IfModule&gt;# // 변경 후&lt;IfModule dir_module&gt; DirectoryIndex index.html index.html.var index.php index.u&lt;/IfModule&gt; 123456789101112# The following lines prevent .htaccess and .htpasswd files from being # viewed by Web clients. # // 변경 전&lt;Files &quot;.ht*&quot;&gt; Require all denied&lt;/Files&gt;# // 변경 후&lt;Files ~ &quot;^\\.ht&quot;&gt; Order allow,deny Deny from all&lt;/Files&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115# &quot;/var/www/cgi-bin&quot; should be changed to whatever your ScriptAliased# CGI directory exists, if you have that configured.# // 변경 전&lt;Directory &quot;/var/www/cgi-bin&quot;&gt; AllowOverride None Options None Require all granted&lt;/Directory&gt;&lt;IfModule mime_module&gt; # # TypesConfig points to the file containing the list of mappings from # filename extension to MIME-type. # TypesConfig /etc/mime.types # # AddType allows you to add to or override the MIME configuration # file specified in TypesConfig for specific file types. # #AddType application/x-gzip .tgz # # AddEncoding allows you to have certain browsers uncompress # information on the fly. Note: Not all browsers support this. # #AddEncoding x-compress .Z #AddEncoding x-gzip .gz .tgz # # If the AddEncoding directives above are commented-out, then you # probably should define those extensions to indicate media types: # AddType application/x-compress .Z AddType application/x-gzip .gz .tgz # # AddHandler allows you to map certain file extensions to &quot;handlers&quot;: # actions unrelated to filetype. These can be either built into the server # or added with the Action directive (see below) # # To use CGI scripts outside of ScriptAliased directories: # (You will also need to add &quot;ExecCGI&quot; to the &quot;Options&quot; directive.) # #AddHandler cgi-script .cgi # For type maps (negotiated resources): #AddHandler type-map var # # Filters allow you to process content before it is sent to the client. # # To parse .shtml files for server-side includes (SSI): # (You will also need to add &quot;Includes&quot; to the &quot;Options&quot; directive.) # AddType text/html .shtml AddOutputFilter INCLUDES .shtml&lt;/IfModule&gt;# // 변경 후&lt;Directory &quot;/var/www/cgi-bin&quot;&gt; AllowOverride None Options None Require all granted&lt;/Directory&gt;&lt;IfModule mime_module&gt; # # TypesConfig points to the file containing the list of mappings from # filename extension to MIME-type. # TypesConfig /etc/mime.types # # AddType allows you to add to or override the MIME configuration # file specified in TypesConfig for specific file types. # #AddType application/x-gzip .tgz AddType application/x-httpd-php .php .html .htm .inc AddType application/x-httpd-php-source .phps # # AddEncoding allows you to have certain browsers uncompress # information on the fly. Note: Not all browsers support this. # #AddEncoding x-compress .Z #AddEncoding x-gzip .gz .tgz # # If the AddEncoding directives above are commented-out, then you # probably should define those extensions to indicate media types: # AddType application/x-compress .Z AddType application/x-gzip .gz .tgz # # AddHandler allows you to map certain file extensions to &quot;handlers&quot;: # actions unrelated to filetype. These can be either built into the server # or added with the Action directive (see below) # # To use CGI scripts outside of ScriptAliased directories: # (You will also need to add &quot;ExecCGI&quot; to the &quot;Options&quot; directive.) # #AddHandler cgi-script .cgi AddHandler php7-script .php .u # For type maps (negotiated resources): AddHandler type-map var # # Filters allow you to process content before it is sent to the client. # # To parse .shtml files for server-side includes (SSI): # (You will also need to add &quot;Includes&quot; to the &quot;Options&quot; directive.) # AddType text/html .shtml AddOutputFilter INCLUDES .shtml&lt;/IfModule&gt; httpd.conf 파일 수정 후 에러가 발생하면 httpd -t 명령어로 httpd.conf 몇째 줄이 틀렸는지 확인 해 볼 수 있습니다. 12$ cd /etc/httpd/conf/ // httpd.conf 파일이 있는 경로로 이동$ httpd -t 가상 호스트각각의 도메인마다 다른 서비스를 하고 싶을때 아파치의 VirtualHost를 사용하면 편리합니다. 1234567# Supplemental configuration## Load config files in the &quot;/etc/httpd/conf.d&quot; directory, if any.IncludeOptional conf.d/*.conf# 가상호스트 .conf 파일 경로 추가Include /etc/httpd/conf/extra/httpd-vhosts.conf etc/httpd/conf/extra 디렉토리안에 httpd-vhosts.conf 파일을 생성 후 아래와 같이 작성합니다. 123456789101112131415161718192021222324252627282930313233343536373839404142# 도메인1&lt;VirtualHost *:80&gt; ServerAdmin example@gmail.com DocumentRoot /home/www/ ServerName example.com ServerAlias example.co.kr ServerAlias www.example.com ServerAlias www.example.co.kr ErrorDocument 404 /errors/error_404.php # 커스텀 404 에러 페이지 # ErrorLog logs/dummy-host.example.com-error_log # CustomLog logs/dummy-host.example.com-access_log common &lt;Directory /home/www/main/&gt; Options FollowSymLinks AllowOverride FileInfo &lt;/Directory&gt; #&lt;Directory /home/www/admin/&gt; # Options Indexes MultiViews FollowSymLinks # AllowOverride All #&lt;/directory&gt; &lt;Files ~ &quot;\\.inc$&quot;&gt; Order allow,deny Deny from all &lt;/Files&gt; ErrorLog /dev/null CustomLog /dev/null common&lt;/VirtualHost&gt;# 도메인2&lt;VirtualHost *:80&gt; ServerAdmin example@gmail.com DocumentRoot /home/event/ ServerName example2.co.kr &lt;Directory /home/event/&gt; Options FollowSymLinks AllowOverride FileInfo &lt;/Directory&gt;&lt;/VirtualHost&gt; DNS 서버가 있다면 이 과정은 필요가 없습니다.DNS 서버가 없다는 가정 하에, local에서 테스트를 하기 위해서는 hosts 파일을 수정해야 합니다. 우선 브라우저를 실행하는 것은 윈도우이기 때문에 윈도우의 hosts 파일 C:\\Windows\\System32\\drivers\\etc 에서 도메인을 등록합니다.(관리자 권한으로 실행해서 저장해야 합니다.) 12345# localhost name resolution is handled within DNS itself.# 127.0.0.1 localhost# ::1 localhost192.168.209.142 example.com 서버의 IP 주소를 확인한 후, 위와 같이 IP와 URL을 작성합니다.즉 example.com 으로 접근하면 192.168.209.142 임을 알 수 있도록 도메인에 등록한 것입니다. 참조 https://suwoni-codelab.com/linux/2017/05/27/Linux-CentOS-Apache/","categories":[{"name":"OS","slug":"OS","permalink":"https://woonyzzang.github.com/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"https://woonyzzang.github.com/categories/OS/Linux/"},{"name":"CentOS","slug":"OS/Linux/CentOS","permalink":"https://woonyzzang.github.com/categories/OS/Linux/CentOS/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://woonyzzang.github.com/tags/linux/"},{"name":"centos","slug":"centos","permalink":"https://woonyzzang.github.com/tags/centos/"}]},{"title":"[Chrome] Ajax로 로컬파일 테스트","slug":"chrome-local-ajax","date":"2019-08-28T15:03:02.000Z","updated":"2024-06-14T10:41:36.579Z","comments":true,"path":"2019/08/29/chrome-local-ajax/","permalink":"https://woonyzzang.github.com/2019/08/29/chrome-local-ajax/","excerpt":"","text":"크롬 브라우저에서 Ajax로 로컬파일 사용하기웹 개발을 하다보면 WAS나 웹서버 없이 그냥 로컬에서 파일만 가지고 개발하는 경우가 생기게 됩니다.html 파일을 서버에 올리지 않고 로컬의 파일을 바로 크롬 브라우저에서 테스트 하는 경우 1Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https Cross domain 보안 이슈로 인해 위와 같은 오류가 발생합니다. 해결 방안 열려있는 모든 크롬창을 완전히 닫습니다. 바탕화면이나 시작 메뉴의 크롬 바로가기 아이콘 &gt; 우클릭 &gt; 속성 을 선택합니다. 3-1. 대상(T) 항목에 --allow-file-access-from-files 옵션을 추가 합니다. 또는, 3-2. 대상(T) 항목에 --disable-web-security --user-data-dir 옵션을 추가 합니다. 이제 새로만든 바로가기 아이콘으로 크롬을 실행하면 로컬파일에서도 ajax 테스트가 가능 합니다. 참고 가끔 크롬을 모두 끄고 다시 시작해도 동일하게 오류가 발생할 때가 있습니다. 이럴땐 작업관리자에서 백그라운드로 크롬에 실행되고 있는 것입니다. 백그라운드 프로세스도 모두 죽이고 다시 하면 됩니다. 정상적으로 개발용으로 크롬이 열리면 “지원되지 않는 명령줄 플래그(–disable-web-security)를 사용 중이므로 안정성과 보안에 문제가 발생합니다.” 라는 경고가 뜹니다. 터미널 커맨드터미널에서 아래 명령어를 입력하여 실행 합니다. Windows 12// 크롬이 설치 된 폴더로 이동해서$ chrome.exe --disable-web-security --user-data-dir Linux 1$ google-chrome --disable-web-security --user-data-dir Mac 1$ open -a Google\\ Chrome --args --disable-web-security --user-data-dir 참조 https://westzero.tistory.com/111 https://goni9071.tistory.com/2","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Javascript","slug":"Frontend/Javascript","permalink":"https://woonyzzang.github.com/categories/Frontend/Javascript/"}],"tags":[{"name":"chrome","slug":"chrome","permalink":"https://woonyzzang.github.com/tags/chrome/"},{"name":"js","slug":"js","permalink":"https://woonyzzang.github.com/tags/js/"}]},{"title":"VMware Workstation and Device/Credential Guard are not compatible","slug":"vmware-device-credential-guard-error","date":"2019-08-28T14:56:42.000Z","updated":"2024-06-05T06:51:40.300Z","comments":true,"path":"2019/08/28/vmware-device-credential-guard-error/","permalink":"https://woonyzzang.github.com/2019/08/28/vmware-device-credential-guard-error/","excerpt":"","text":"VMware Workstation and Device&#x2F;Credential Guard are not compatible 에러 해결아래와 같은 에러 발생 시 발생 원인Windows 10부터는 OS 내에서 자체 가상화를 지원하고 있는데 VMware 와 충돌으로 인해 문제가 될 수 있습니다. 조치 사항 실행 창에서 gpedit.msc 을 실행합니다. 해당 화면에서 로컬 컴퓨터 정책 &gt; 컴퓨터 구성 &gt; 관리 템플릿 &gt; 시스템 &gt; Device Guard 에 들어가 가상화 기반 보안 켜기의 상태를 사용 안 함으로 설정한다. 실행 창에서 appwiz.cpl 을 실행합니다. 실행 창 단축키는 Win 키 + R 을 누르면 됩니다. 프로그램 및 기능에서 Windows 기능 켜기/끄기 를 클릭합니다. Windows 기능에서 Hyper-V 관련 폴더 또는 Windows 샌드박스 체크 확인 후 활성화 되어 있는 부분의 체크를 해제합니다. 다시 시작 을 해서 재부팅 합니다. 참조 http://palkoon76.blogspot.com/2017/10/os-windows-10-vmware.html https://abc2080.tistory.com/entry/VMware-Workstation-and-DeviceCredential-Guard-are-not-compatible","categories":[{"name":"Tools","slug":"Tools","permalink":"https://woonyzzang.github.com/categories/Tools/"},{"name":"VMware","slug":"Tools/VMware","permalink":"https://woonyzzang.github.com/categories/Tools/VMware/"}],"tags":[{"name":"vmware","slug":"vmware","permalink":"https://woonyzzang.github.com/tags/vmware/"},{"name":"windows","slug":"windows","permalink":"https://woonyzzang.github.com/tags/windows/"}]},{"title":"Windows 10 Sandbox 사용","slug":"windows-sandbox","date":"2019-08-18T14:41:40.000Z","updated":"2024-06-05T07:05:54.241Z","comments":true,"path":"2019/08/18/windows-sandbox/","permalink":"https://woonyzzang.github.com/2019/08/18/windows-sandbox/","excerpt":"","text":"Windows 10 에서 샌드박스 설치 및 사용하기윈도우10 1903 빌드 18305부터 제공되는 가상머신 기능인 샌드박스를 공식으로 지원합니다.샌드박스는 쉽게 말하면 호스트 시스템과 분리된 독립된 영역에서 가상 윈도우를 실행해주는 앱이라고 생각하면 됩니다. 샌드박스는 호스트 OS에 영향을 주지 않기 때문에 혹시라도 호스트 OS에 피해를 줄 우려가 있는 프로그램을 실행하거나 인터넷을 해야 할 때 사용하면 호스트 시스템을 보호할 수 있습니다. 가상머신 프로그램인 VM웨어나 버추얼박스의 게스트 OS와 비슷하다고 생각하면 됩니다. 샌드박스와 가상머신 프로그램과 다른 점은 가상 머신의 OS들은 종료 후 다시 부팅해서 계속 사용이 가능한데 비해 윈도우10의 샌드박스는 1회용으로 앱을 종료하면 모든 내용이 영구히 사라지게 됩니다. 필요 시스템 사양 Windows 10 1903 빌드 18305 이상 Pro 이상 에디션 및 64비트 버전 (홈버전 및 32비트는 제공하지 않음) CPU 가상화 지원 (BIOS에서 가상화 기능 사용 설정도 할 것) CPU 코어 2개 이상 (4개 이상 권장) 4GB 이상의 메모리 용량 (8GB 이상 권장) 1GB 이상의 저장 공간 필요 (SSD 권장) 샌드박스를 사용하기 위해서는 사용 중인 컴퓨터가 가상화를 지원해야 합니다.요즘 컴퓨터는 대부분 가상화를 지원하기 때문에 샌드박스 실행이 안 된다면 메인보드 바이오스 설정에 가상화 옵션이 활성화되어 있는지 확인해 보면 됩니다.샌드박스는 윈도우10 홈 버전에서는 지원을 하지 않기 때문에 프로나 엔터프라이즈 버전을 사용해야 합니다. 샌드박스 기능은 VMWare 처럼 VT-x 를 지원하는 CPU에서만 사용 가능합니다 현시점에서 VM웨어가 설치된 컴퓨터에 샌드박스를 설치하면 충돌이 난다고 합니다.다른 가상머신을 사용 중이라면 샌드박스 사용은 더 기다린 후에 해보는 게 좋을 거 같습니다. 윈도우10 샌드박스 설치 및 실행 방법샌드박스는 기본으로 설치되어 있지 않기 때문에 따로 설치를 해야 사용할 수 있습니다. 검색에 windows 기능 을 검색해서 Windows 기능 켜기/끄기를 실행합니다. Windows 샌드박스에 체크를 하고 확인을 클릭합니다. Windows 샌드박스 설치가 진행됩니다.다시 시작을 클릭해서 재부팅을 해주면 설치 완료입니다. 샌드박스를 실행하는 방법은 시작에서 Windows Sandbox를 찾아서 클릭하면 됩니다. 샌드박스 실행 시행하면 윈도우안에 독립된 또 다른 윈도우를 실행 할 수 있습니다. 샌드박스 종료 샌드박스 특성상 종료시 작업한 모든것이 사라집니다.가상머신을 사용 안 하는 경우 샌드박스를 이용하여 바이러스 의심 가는 파일 실행시 또는 설치나 테스트 그리고 위험 사이트 방문 시 활용하면 좋겠습니다. 참조 https://rootblog.tistory.com/179 https://osmanias.com/tip/2621785","categories":[{"name":"OS","slug":"OS","permalink":"https://woonyzzang.github.com/categories/OS/"},{"name":"Windows","slug":"OS/Windows","permalink":"https://woonyzzang.github.com/categories/OS/Windows/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://woonyzzang.github.com/tags/windows/"}]},{"title":"Windows 10 Linux Bash Shell 사용","slug":"windows-bash","date":"2019-08-18T14:40:10.000Z","updated":"2024-06-05T07:00:09.340Z","comments":true,"path":"2019/08/18/windows-bash/","permalink":"https://woonyzzang.github.com/2019/08/18/windows-bash/","excerpt":"","text":"Windows 10 에서 Linux Bash Shell 사용하기Windows 10에 Windows Subsystem for Linux(WSL)라는 기능이 생기면서, bash shell 지원함에 따라 Windows 에서도 Linux를 사용 할 수 있게 되었습니다. Windows 10에서 bash 셀을 사용하기 위해서 설치하는 과정을 알아보겠습니다. 필요 시스템 사양 Windows 10 64bit Windows 10 v.1607 ( v.1607버전 이하이신분들은 윈도우즈 업데이트를 받으시기 바랍니다.) 설치하기윈도우 빌드 정보 확인WSL 기능을 사용하려면 Windows 10의 빌드 버전이 14316 이상이어야 한다. 버전 확인은 [설정] -&gt; [정보] -&gt; [OS 빌드]를 확인하자. 개발자 모드 설정[설정] -&gt; [업데이트 및 보안] -&gt; [개발자용] -&gt; [개발자 모드] 선택 윈도우 기능 켜기[제어판] -&gt; 프로그램 및 기능 -&gt; [Windows 기능 켜기/끄기] -&gt; [Linux용 Windows 하위 시스템] 체크 후 재부팅 리눅스 설치cmd를 관리자권한으로 열고 프롬프트에 bash 를 치면 아래와 같이 https://aka.me/webstore 로 가라는 메시지가 나온다. 12345C:\\windows\\system32&gt;bashLinux용 Windows 하위 시스템에 배포가 설치되어 있지 않습니다.아래의 Windows 스토어에서 배포를 설치할 수 있습니다.https://aka.ms/wslstore계속하려면 아무 키나 누르세요... 브라우저에서 위의 주소로 접속하여 Store를 열고 마음에 드는 리눅스 배포판을 선택합니다.여기서는 Utuntu를 선택하여 다운로드 합니다. 다운로드가 완료되면 실행을 눌러 설치 합니다. 설치가 진행되며 우분투에서 사용할 username과 password를 입력하면 곧바로 bash 셸을 사용할 수 있습니다. 참조 https://crynut84.github.io/2018/01/10/building-dev-env-using-wsl/ https://wedul.site/429","categories":[{"name":"OS","slug":"OS","permalink":"https://woonyzzang.github.com/categories/OS/"},{"name":"Windows","slug":"OS/Windows","permalink":"https://woonyzzang.github.com/categories/OS/Windows/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://woonyzzang.github.com/tags/windows/"}]},{"title":"Windows 10 Update Error Failed","slug":"windows-update-error","date":"2019-08-18T14:38:26.000Z","updated":"2024-06-05T07:06:49.736Z","comments":true,"path":"2019/08/18/windows-update-error/","permalink":"https://woonyzzang.github.com/2019/08/18/windows-update-error/","excerpt":"","text":"윈도우10 업데이트 오류 실패 조치방법윈도우 업데이트 때문에 부팅 시간이 오래걸리는데 마지막에 윈도우10 업데이트를 실패하였습니다. 라는 문구와 함께 윈도우 업데이트가 계속해서 오류 발생했을 때 조치하는 방법을 알아보겠습니다. 윈도우10 업데이트 서비스 중지윈도우 업데이트가 계속해서 오류가 발생할 경우 업데이트와 관련된 폴더를 삭제하여 초기화 시키는 방법이 있습니다. 그 전에 해당 폴더에 접근하고 있는 윈도우 업데이트 서비스를 중지 시켜야 삭제가 하가능합니다. 윈도우10 업데이트 서비스를 종료시키기 위해서는 먼저 1번 윈도우키를 누른 다음 2번 설정을 클릭해 줍니다. 검색창에 로컬 서비스 보기 라고 입력을 한 후 서비스창으로 이동합니다. 서비스창에서 windows Update를 찾아 오른쪽 마우스를 클릭하여 하위 메뉴에 있는 중지 버튼을 클릭하여 윈도우10 업데이트 서비스를 중지 시켜줍니다. SoftwareDistribution 폴더 데이터 삭제이번에는 업데이트 파일들이 있는 SoftwareDistribution 폴더 삭제를 삭제해 보겠습니다. 탐색기에서 C:\\Windows 경로에 들어가 보면 SoftwareDistribution 폴더가 있습니다. 폴더를 선택하고 삭제를 해줍니다. 그럼 안에 있던 업데이트 관련 데이터가 모두 삭제 됩니다. 이제 다시 위에 들어갔던 로컬 서비스로 다시 들어가 서비를 시작해 줍니다. 윈도우10 업데이트윈도우 업데이트가 제대로 이루어지는지 다시한번 실행시켜 줍니다. 설정에서 윈도우 업데이트 및 보안를 클릭합니다. 왼쪽에 있는 Windows 업데이트를 클릭하고 2번 업데이트 확인 버튼을 클릭합니다. 그럼 업데이트 내역을 다시 확인하면서 업데이트가 다시 이루어 질 것입니다. 참조 https://appadal.tistory.com/804","categories":[{"name":"OS","slug":"OS","permalink":"https://woonyzzang.github.com/categories/OS/"},{"name":"Windows","slug":"OS/Windows","permalink":"https://woonyzzang.github.com/categories/OS/Windows/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://woonyzzang.github.com/tags/windows/"}]},{"title":"Windows 10 연결 프로그램 초기화","slug":"windows-open-program-init","date":"2019-08-18T14:33:05.000Z","updated":"2024-06-05T07:05:01.448Z","comments":true,"path":"2019/08/18/windows-open-program-init/","permalink":"https://woonyzzang.github.com/2019/08/18/windows-open-program-init/","excerpt":"","text":"Windows 10 연결 프로그램 초기화하는 방법Windows 10 사용 중 특정 파일 형식에 대한 기본 앱 선택을 잘못했을 경우 초기화하는 방법입니다.초기화 이후에 다시 원하는 프로그램으로 연결할 수 있습니다. 다음 연결프로그램 설정 또는 기본앱 설정 내용은 Windows 10 을 기준으로 설명되었으나, Windows 8.1 에서도 적용 가능하니 참고 및 진행해주시길 바랍니다. 별도의 설정을 통한 초기화에는 어려움이 있지만, 아래의 방법을 통해서 연결된 프로그램이 없는 상태로 변경할 수 있습니다. (아래 방법은 해당 파일(새 텍스트 문서.package)의 연결 프로그램이 텍스트 문서(메모장)로 잘못 연결된 상태를 가정하여, 다시 연결된 프로그램이 없는 상태로 변경하는 방법입니다.) 초기화 탐색기를 열고 파일을 하나 생성하거나 다른 파일의 복사본을 만든 후 이름 및 확장자를 변경합니다.확장자는 기존에 연결된 프로그램이 없는 확장자 로 아무렇게나 지정합니다.(예 : 새 텍스트 문서 - 복사본.아무거나) 변경해야 할 파일(새 텍스트 문서.package)을 마우스 오른쪽 버튼으로 클릭하여 연결 프로그램 - 다른 앱 선택 을 선택을 클릭합니다. 이 파일을 열 때 사용할 앱을 선택하세요. 메뉴가 나타나면 하단에 항상 이 앱을 사용하여 .XXX 파이 열기 를 체크하시고 추가앱 을 클릭합니다. 추가 앱 을 누른 후 스크롤을 가장 아래로 내리고 이 PC에서 다른 앱 찾기를 클릭 합니다. 파일 선택 창이 나타나면, 우측 하단의 확장자 선택 박스를 클릭하여 모든 파일 (*.*) 로 설정하여, 임의로 생성한 확장자를 가진(새 텍스트 문서 - 복사본.아무거나) 이 파일을 선택하고 열기를 클릭 합니다. 아래와 같은 메시지 창이 나오면 무시하고, 닫기를 클릭합니다. 이후 “새 텍스트 문서 - 복사본.아무거나”파일을 삭제하고, 새 텍스트 문서.package 파일의 연결 프로그램 상태가 변경되었는지 확인합니다. 참조 https://blog.naver.com/syjnew/221141479466","categories":[{"name":"OS","slug":"OS","permalink":"https://woonyzzang.github.com/categories/OS/"},{"name":"Windows","slug":"OS/Windows","permalink":"https://woonyzzang.github.com/categories/OS/Windows/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://woonyzzang.github.com/tags/windows/"}]},{"title":"Mac 원격 제어 하기 (windows, mac)","slug":"mac-remote-control","date":"2019-08-15T03:46:00.000Z","updated":"2024-06-05T06:09:31.047Z","comments":true,"path":"2019/08/15/mac-remote-control/","permalink":"https://woonyzzang.github.com/2019/08/15/mac-remote-control/","excerpt":"","text":"프로그램 설치 없이 맥 원격 제어 하기 (windows, mac)맥에서는 기본적으로 화면공유라는 원격관리 서비스를 지원합니다. 공유기의 포트 설정과 함께, 외부망 에서 사용 가능하도록 한다면 외부에서도 자신의 맥 환경으로 업무를 진행할 수 있습니다. 기본적으로 Teamviewer 등등의 외부 원격 프로그램을 설치해서 사용하면 3시간마다 연결이 끊겨 다시 연결을 거는 불편함과 함께, 보안상의 찝찝함이 있었는데 운영체제 내에 들어있는 화면공유 기능은 그러한 점이 없어 상당히 매력적으로 보였습니다. 또한 VNC라는 자유소프트웨어 기반으로 제작되었기 때문에 안드로이드,ios,윈도우,리눅스 등 여러가지 os에서도 원격 제어가 가능하다는 점도 큰 특징 중에 하나입니다. 그럼 이제 살펴보도록 하겠습니다. 먼저 시스템 환경설정 으로 들어가 줍니다. 시스템 환경설정에서 공유 를 클릭해 주세요. 이후에 설정 방법은 2가지가 있습니다. 하나는 공유기 내에서 사용하는 방법이며, 하나는 IP주소를 통하여 외부에서도 원격을 하는 방법입니다. 자신이 원격을 사용하는 용도에 따라서 선택해서 적용 부탁드리겠습니다. 1. 내부 망안에서 화면 공유 화면 공유를 클릭하여 체크합니다. 간단하게 설정이 완료되었습니다.이후 창이 화면 공유:켬 으로 바뀌며 하단의 설명에 자신 내부 IP를 알려줍니다. 그 IP를 기억해 둡니다. 2. 외부 망에서도 화면 공유 원격 관리 를 클릭하여 체크한 후 다음 사용자의 접근 허용 의 다음 사용자만:으로 체크합니다. 그 뒤 ‘+’ 버튼을 클릭합니다. 자신의 계정 명을 클릭한 뒤 다음과 같이 모든 권한을 체크 한 뒤 승인 버튼을 클릭합니다.추가한 계정 명을 기억해 둡니다. 그 뒤, 외부 망에서 접속할 수 있도록 공유기의 포트포워드 설정을 변경해 주어야 합니다. 각 제조사의 설명서를 참고하여서 다음과 같이 설명해 주시면 됩니다. 웹 브라우저에서 192.168.0.1 주소로 접속해 줍니다.그 뒤 관리자 아이디와 비밀번호를 입력하여 로그인 한 뒤, 관리도구를 클릭합니다. (ipTIME 공유기의 기본 관리자 아이디&#x2F;비밀번호는 admin&#x2F;admin 입니다.) 동적 IP 옆에 있는 IP주소를 기억해 둡니다. 고급설정-NAT/라우더 관리 &gt; 포트포워드 설정 탭으로 들어가서, 내부 IP주소를 입력한 뒤에, 프로토콜 방식은 TCP 외부, 내부 포트를 5900으로 설정해준뒤 저장해 줍니다. 맥으로 원격을 들어오는 방법 Finder를 클릭한 뒤 상단 이동탭에서 서버에 연결…을 클릭(cmd+k)합니다. 서버에 연결 창이 뜨면, 방금전에 알아 두었던 IP주소를 입력해 줍니다. (vnc:&#x2F;&#x2F;ip주소) 맥의 이름(추가한 계정 명)과 암호를 입력하고 연결 버튼을 클릭합니다. 원격 제어에 성공하였습니다. 윈도우로 원격을 들어오는 방법 VNC Viewer를 다운로드 받습니다. (Standalone EXE 버전은 무설치 파일 입니다.) VNC Viewer 다운로드 다운받은 VNC 뷰어를 실행해 줍니다. 방금전에 알아 두었던 IP를 입력합니다. (‘vnc:&#x2F;&#x2F;’입력 불필요) Identity Check 경고창이 뜨는데 그냥 무시하고 넘어갑니다. Don’t warm me about this again on this computer에 체크한뒤 Continue 버튼을 클릭합니다. 맥의 이름(추가한 계정 명)과 암호를 입력하고 OK 버튼을 클릭합니다. 원격제어에 성공하였습니다. VNC프로그램은 안드로이드 아이폰 리눅스 까지 모두 지원합니다. 앱스토어나 마켓에서 VNC라고 검색하시면 VNC뷰어가 나오는데 IP를 입력해서 원격화면으로 들어오는 과정 모두 동일합니다. 참조 https://yeopbox.com/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%84%A4%EC%B9%98-%EC%97%86%EC%9D%B4-%EB%A7%A5-%EC%9B%90%EA%B2%A9-%EC%A0%9C%EC%96%B4-%ED%95%98%EA%B8%B0-windows-mac/","categories":[{"name":"OS","slug":"OS","permalink":"https://woonyzzang.github.com/categories/OS/"},{"name":"Mac","slug":"OS/Mac","permalink":"https://woonyzzang.github.com/categories/OS/Mac/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://woonyzzang.github.com/tags/mac/"}]},{"title":"Mac 사파리 브라우저 유튜브 프리징","slug":"mac-safari-youtube-freezing","date":"2019-08-15T03:39:53.000Z","updated":"2020-09-05T13:07:55.898Z","comments":true,"path":"2019/08/15/mac-safari-youtube-freezing/","permalink":"https://woonyzzang.github.com/2019/08/15/mac-safari-youtube-freezing/","excerpt":"","text":"macOS 사파리 브라우저에서 유튜브 프리징 현상 해결방안Safari 브라우저에서 Youtube에 접속해 영상을 보면 다음 영상으로 넘어갈 때 멈췄다가 재생되는 현상이 나타나면 다음과 같은 방법으로 해결 할 수 있다.2번째 방법을 먼저 해보고 안되는 경우, 1번째 방법으로 해결하길 권장한다. (3번째 방법으로는 증상이 해결되지는 않았음) 1. SMC 재설정 (시스템 관리 컨트롤러) : 배터리 탈 부착 안되는 모델에 해당 맥북에 연결된 모든 포트 제거 Magsafe 충전기 어댑터만 연결한 상태에서 전원을 종료 한다. Control + option + shift + 전원 을 동시에 누르고 15초 가량 기다린다. 3-1. 이 때 맥북은 아무런 동작이 일어나지 않는다. (전원이 켜지지 않음) 3-2. 일시적을로 연결된 충전기 LED 표시등이 깜박이거나 색깔이 변하는 경우도 있고 그렇지 않을 경우도 있다. 15초가 지나면 누른 키를 떼고 다시 전원 버튼만 눌러 켠다. SMC 재설정 고려 대상 전원 버튼 눌렀을 때 응답이 없는 경우 맥북에서 디스플레이를 닫거나 열었을 때 잠자기 &#x2F; 깨우기가 안될 경우 배터리 소모가 빠르거나 충전이 안될 경우 컴퓨터 온도가 체감적으로 뜨겁게 느껴질 경우 주변 광 센서 동작이 정상적으로 표시되지 않는 경우 배터리 상태 표시등이 정상적으로 표시되지 않는 경우 연결된 다른 외부 장치 인식에 문제가 발생될 경우 시스템 사운드 출력이 정상적이지 않을 경우 팬 소음이 심하게 발생되거나 팬 동작이 원활하지 않는 경우 2. NVRAM 재설정 (메모리 설정 값을 초기화) 전원을 끈다. 전원을 켜고 command + option + P + R 키를 동시에 누른다. 2-1. 1회 부팅 효과음이 발생되고, 2회째 부팅 효과음이 울릴 때 손을 떼면 된다. 부팅이 된다. NVRAM 재설정 고려 대상 부팅이 안될 경우 음량 조절 &#x2F; 사운드 출력이 안될 경우 외부 디스플레이 출력이 안될 경우 사용중이거나 부팅단계에서 커널 패닉이 발생할 경우 시간 설정 저장이 안되거나 문제가 있을 경우 3. 디스크 유틸리티 검사&#x2F;복구 전원을 켜고 command + R 키를 누르고 있는다. 부팅중에 작업창이 뜰 것이다. 디스크 유틸리티를 선택하고 다음을 클릭 한다. 내장의 하드디스크(OS X 설치된)를 선택하고 검사 &#x2F; 복구 버튼을 눌러 실행한다. 완료가 되면 재부팅을 한다. 2번째 방법으로 하고나니 아무런 문제 없이 Safari 브라우저에서 Youtube 영상이 멈췄다가 재생되는 현상 사라졌다. 참조 https://m.blog.naver.com/PostView.nhn?blogId=eangelic&amp;logNo=220757283406&amp;proxyReferer=https%3A%2F%2Fwww.google.com%2F","categories":[{"name":"OS","slug":"OS","permalink":"https://woonyzzang.github.com/categories/OS/"},{"name":"Mac","slug":"OS/Mac","permalink":"https://woonyzzang.github.com/categories/OS/Mac/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://woonyzzang.github.com/tags/mac/"}]},{"title":"Shadow DOM","slug":"html5-shadow-dom","date":"2019-08-15T03:33:20.000Z","updated":"2024-06-07T09:27:28.303Z","comments":true,"path":"2019/08/15/html5-shadow-dom/","permalink":"https://woonyzzang.github.com/2019/08/15/html5-shadow-dom/","excerpt":"","text":"Shadow DOM은 무엇일까?DOM(Document Object Model)은 HTML 문서의 구조화된 표현입니다. 이것은 브라우저가 페이지에 무엇을 렌더링 할지 결정하기 위해, 혹은 자바스크립트 프로그램이 페이지의 콘텐츠 및 구조, 스타일을 수정하기 위해 사용됩니다. 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;My first web page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;p&gt;How are you?&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 위의 HTML 문서는 다음과 같은 DOM 트리를 생성합니다. 지난 몇 년 동안 Shadow DOM과 Virtual DOM이라는 용어를 들어보셨을 겁니다. 이들은 DOM과 관련이 있지만 매우 다른 개념을 가리킵니다.이 문서에서는 shadow DOM이 무엇인지, 그리고 기존의 DOM과 어떻게 다른지에 대해 다루도록 하겠습니다. HTML 문서의 모든 요소와 스타일로 이루어진 DOM은 하나의 큰 글로벌 범위 내에 있습니다.페이지의 요소가 문서 내에 깊이 중첩되어 있거나 어디에 배치되어있는지 상관없이 document.querySelector() 메서드를 사용하여 접근이 가능합니다. 마찬가지로, CSS 스타일 또한 글로벌 범위 내의 어떤 요소든 선택이 가능합니다. 문서 전체에 스타일을 일괄 적용하고 싶을 때 이러한 방식은 매우 유용합니다. 예를 들어, box-sizing 속성을 사용한 한 줄의 코드를 통해 페이지에 있는 모든 단일 요소를 선택할 수 있습니다. 1* &#123; box-sizing: border-box &#125; 반면에 어떤 요소는 완전한 캡슐화를 필요로 하는 경우가 있고, 이것이 글로벌 스타일에 영향을 받는 것을 원하지 않을 수 있습니다.이에 대한 좋은 예는 트위터의 “follow” 버튼과 같이 외부에서 가져온 위젯을 들 수 있습니다. 1&lt;iframe scrolling=&quot;no&quot; frameborder=&quot;0&quot; allowtransparency=&quot;true&quot; src=&quot;https://platform.twitter.com/widgets/follow_button.d30011b0f5ce05b98f24b01d3331b3c1.en.html#dnt=false&amp;amp;id=twitter-widget-0&amp;amp;lang=en&amp;amp;screen_name=ireaderinokun&amp;amp;show_count=false&amp;amp;show_screen_name=true&amp;amp;size=m&amp;amp;time=1546395468133&quot;&gt;&lt;/iframe&gt; Javascript를 활성화하고 요소를 검사한다고 가정할 때 이 버튼이 &lt;iframe&gt; 요소라는 것을 알 수 있는데, 이 요소는 실제로 보이는 스타일 버튼과 함께 작은 문서를 로드합니다. &lt;iframe&gt; 은 트위터의 위젯이 호스팅 문서의 전역 CSS에 영향을 받지 않고 의도된 스타일을 보장할 수 있는 방법입니다. 같은 결과를 얻기 위해 캐스케이드를 이용할 수 있지만, 다른 방법으로는 &lt;iframe&gt; 과 같은 보장이 주어지지 않으며 이상적인 방법은 아닙니다. Shadow DOM은 &lt;iframe&gt;과 같은 도구에 의존할 필요 없이, 웹 플랫폼에서 기본적으로 캡슐화와 구성요소화를 허용하기 위해 만들어졌습니다. A DOM within a DOMShadow DOM을 “DOM 내의 DOM”으로 생각할 수도 있지만, 원래의 DOM 트리에서 완전히 분리된 고유의 요소와 스타일을 가진 DOM 트리입니다. Shadow DOM은 웹 작성자가 사용하도록 최근에 지정되었지만, 사용자 에이전트에서 폼 요소와 같이 복잡한 구성요소를 만들고 스타일을 입히기 위해 수년 동안 사용되어 왔습니다.예를 들어 범위 입력 요소를 살펴보겠습니다. 페이지에 해당 요소를 생성하기 위해서는 아래의 코드를 추가해야 합니다. 1&lt;input type=&quot;range&quot;&gt; 이 요소로 인해 다음과 같은 구성 요소가 생성됩니다. 더 깊게 파고들면, &lt;input&gt; 요소가 실제로 여러 작은 &lt;div&gt; 요소로 구성되어 트랙과 슬라이더를 자체적으로 제어하는 것을 볼 수 있습니다. 웹브라우저의 네이티브 Shadow DOM 구조는 Chrome 브라우저 개발자 도구 &gt; Settings &gt; Preferences &gt; Elements &gt; Show user agent shadow DOM 체크박스 옵션을 활성화 해야 확인할 수 있습니다. How the shadow DOM worksShadow DOM이 어떻게 작동하는지 설명하기 위해 &lt;iframe&gt; 대신 shadow DOM을 사용하여 트위터의 “follow” 버튼을 만들어 보겠습니다. 먼저 shadow host로 시작합니다. shadow host는 새로운 shadow DOM을 붙일 원본 DOM의 일반 HTML 요소를 사용합니다. Follow 버튼과 같은 구성요소의 경우, 페이지에 Javascript가 활성화되지 않았거나 shadow DOM이 지원되지 않을 경우 표시할 폴백 요소를 포함할 수 있습니다. 12345&lt;span class=&quot;shadow-host&quot;&gt; &lt;a href=&quot;https://twitter.com/ireaderinokun&quot;&gt; Follow @ireaderinokun &lt;/a&gt;&lt;/span&gt; 주로 상호 작용하는 특정 요소들은 shadow host가 될 수 없기 때문에, 단순히 요소를 shadow host로 사용할 수 없습니다. 호스트에 shadow DOM을 붙이기 위해, attachShadow() 메서드를 사용합니다. 12const shadowEl = document.querySelector(&#x27;.shadow-host&#x27;);const shadow = shadowEl.attachShadow(&#123;mode: &#x27;open&#x27;&#125;); 이 코드는 shadow host의 자식 요소인 빈 shadow root를 생성합니다. &lt;html&gt; 요소가 DOM의 시작인 것처럼 shadow root는 shadow DOM의 시작점 역할을 합니다. 일반 HTML 자식 요소는 검사기에서 확인될지라도 shadow root가 차지하면서 더 이상 페이지에 보이지 않게 됩니다. 다음으로, 새로운 shadow tree를 만들기 위해 콘텐츠를 생성해야 합니다. shadow tree는 DOM tree와 비슷하지만 일반 DOM 대신 shadow DOM을 사용합니다.follow 버튼을 생성하기 위해서는 이미 가지고 있는 폴백 링크와 거의 동일하지만 아이콘이 있는 새로운 &lt;a&gt; 요소가 필요합니다. 1234567const link = document.createElement(&#x27;a&#x27;);link.href = shadowEl.querySelector(&#x27;a&#x27;).href;link.innerHTML = ` &lt;span aria-label=&quot;Twitter icon&quot;&gt;&lt;/span&gt; $&#123;shadowEl.querySelector(&#x27;a&#x27;).textContent&#125;`; 일반적인 방법과 동일하게 appendChild() 메서드를 사용하여 shadow DOM에 새로운 요소를 추가합니다. 1shadow.appendChild(link); 이 시점에서 해당 요소는 아래와 같습니다. 마지막으로 &lt;style&gt; 요소를 만들고 shadow root에 추가함으로써 몇가지 스타일을 적용할 수 있습니다. 1234567891011121314151617181920212223242526272829303132333435363738const styles = document.createElement(&#x27;style&#x27;);styles.textContent = ` a, span &#123; vertical-align: top; display: inline-block; box-sizing: border-box; &#125; a &#123; height: 20px; padding: 1px 8px 1px 6px; background-color: #1b95e0; color: #fff; border-radius: 3px; font-weight: 500; font-size: 11px; font-family:&#x27;Helvetica Neue&#x27;, Arial, sans-serif; line-height: 18px; text-decoration: none; &#125; a:hover &#123; background-color: #0c7abf; &#125; span &#123; position: relative; top: 2px; width: 14px; height: 14px; margin-right: 3px; background: transparent 0 0 no-repeat; background-image: url(data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%2072%2072%22%3E%3Cpath%20fill%3D%22none%22%20d%3D%22M0%200h72v72H0z%22%2F%3E%3Cpath%20class%3D%22icon%22%20fill%3D%22%23fff%22%20d%3D%22M68.812%2015.14c-2.348%201.04-4.87%201.744-7.52%202.06%202.704-1.62%204.78-4.186%205.757-7.243-2.53%201.5-5.33%202.592-8.314%203.176C56.35%2010.59%2052.948%209%2049.182%209c-7.23%200-13.092%205.86-13.092%2013.093%200%201.026.118%202.02.338%202.98C25.543%2024.527%2015.9%2019.318%209.44%2011.396c-1.125%201.936-1.77%204.184-1.77%206.58%200%204.543%202.312%208.552%205.824%2010.9-2.146-.07-4.165-.658-5.93-1.64-.002.056-.002.11-.002.163%200%206.345%204.513%2011.638%2010.504%2012.84-1.1.298-2.256.457-3.45.457-.845%200-1.666-.078-2.464-.23%201.667%205.2%206.5%208.985%2012.23%209.09-4.482%203.51-10.13%205.605-16.26%205.605-1.055%200-2.096-.06-3.122-.184%205.794%203.717%2012.676%205.882%2020.067%205.882%2024.083%200%2037.25-19.95%2037.25-37.25%200-.565-.013-1.133-.038-1.693%202.558-1.847%204.778-4.15%206.532-6.774z%22%2F%3E%3C%2Fsvg%3E); &#125;`; shadow.appendChild(styles); 이렇게 생성된 요소는 다음과 같습니다. The DOM vs the shadow DOM어떤 면에서 shadow DOM은 DOM의 “lite” 버전입니다.DOM과 같이 HTML 요소의 구조화된 표현이며, 페이지에 무엇을 표시할지 결정하고 요소의 수정을 가능하게 합니다. 하지만 DOM과 다르게 완전한 독립 문서를 기반으로 하지 않습니다.이름에서 알 수 있듯이 shadow DOM은 항상 일반 DOM 내의 요소에 부착됩니다. DOM이 없으면 shadow DOM도 존재하지 않습니다. slot슬롯은 사용자가 컴포넌트 내부에 원하는 마크업을 채울 수 있도록 미리 선언해놓은 자리 표시자입니다.주로 사용자 커스텀 요소를 생성할 때 유용합니다. 사용자 커스텀 요소에 필요한 최소한의 마크업만 제공하고 작성자가 원하는 대로 그룹화하고 스타일을 적용하여 사용할 수 있습니다. 슬롯을 설명하기 전에 &lt;template&gt;을 사용한 마크업 예시를 먼저 살펴보겠습니다. 12345678910&lt;!-- 렌더링할 템플릿 선언 --&gt;&lt;template id=&quot;my-template&quot;&gt; &lt;style&gt; p &#123; color: green; &#125; &lt;/style&gt; &lt;p&gt;Hello, Shadow DOM!&lt;/p&gt;&lt;/template&gt; &lt;!-- 사용자 커스텀 요소 사용 --&gt;&lt;my-template&gt;&lt;/my-template&gt; 1234567891011121314// 사용자 커스텀 요소를 정의하고 준비한 템플릿 코드를 가져와 shadow DOM을 생성합니다.// shadow DOM으로 인해 템플릿 내의 코드는 캡슐화됩니다.class myTemplate extends HTMLElement &#123; constructor() &#123; super(); let template = document.getElementById(&#x27;my-template&#x27;); let templateContent = template.content; const shadowRoot = this.attachShadow(&#123;mode: &#x27;open&#x27;&#125;) .appendChild(templateContent.cloneNode(true)); &#125;&#125;customElements.define(&#x27;my-template&#x27;, myTemplate); 템플릿 요소는 마크업 조각 형태로 이루어집니다. 이는 페이지 로딩 시 렌더링 되지 않으며 자바스크립트를 이용해 런타임 시 인스턴스화할 수 있습니다.따라서 자주 사용되는 마크업 조각들을 템플릿 요소에 추가하고 복제함으로써 재사용성을 증가시킵니다. 또한 템플릿 요소가 shadow host로 지정되어 내부 스타일을 가질 수 있습니다. 하지만 템플릿은 단순히 작성된 요소만 화면에 표시하기 때문에 유연하지 않습니다. 슬롯은 이러한 템플릿 코드에 유연성을 제공합니다.슬롯을 사용한 템플릿 코드 예시를 살펴보겠습니다. 123456789101112131415&lt;!-- 빈 슬롯이 추가된 템플릿 선언 --&gt;&lt;template id=&quot;my-template&quot;&gt; &lt;style&gt; :host &#123; color: green; &#125; &lt;/style&gt; &lt;slot&gt;&lt;/slot&gt;&lt;/template&gt; &lt;!-- 각각의 사용자 커스텀 요소마다 다른 요소를 삽입 --&gt;&lt;my-template&gt; &lt;h1&gt;Hello Shadow DOM!&lt;/h1&gt;&lt;/my-template&gt;&lt;my-template&gt; &lt;p&gt;Hello, Shadow DOM!&lt;/p&gt;&lt;/my-template&gt; 하나의 슬롯을 사용했지만 결과적으로는 다른 두 요소를 렌더링 합니다. 슬롯은 shadow DOM에서 사용됩니다. 즉, shadow root에 추가되는 템플릿 코드 내에 슬롯을 작성해야 합니다.빈 슬롯을 추가한 템플릿을 생성한 후, 사용자 커스텀 요소에서 해당 슬롯에 배치하고 싶은 요소를 추가하여 사용할 수 있습니다. 슬롯을 통해 다양한 요소들이 하나의 템플릿에서 구현 가능하므로 매우 유용합니다. named slot다양한 콘텐츠로 이루어진 복잡한 요소는 명명된 슬롯을 사용하여 쉽게 생성할 수 있습니다. 123456789101112&lt;!-- 템플릿 선언 --&gt;&lt;template id=&quot;my-template&quot;&gt; &lt;slot name=&quot;title&quot;&gt;&lt;/slot&gt; &lt;hr&gt; &lt;slot&gt;&lt;/slot&gt;&lt;/template&gt; &lt;!-- 사용자 커스텀 요소 --&gt;&lt;my-template&gt; &lt;h1 slot=&quot;title&quot;&gt;제목&lt;/h1&gt; &lt;p&gt;이 텍스트는 이름 없는 빈 슬롯에 들어가게 됩니다.&lt;/p&gt;&lt;/my-template&gt; 출력된 결과는 아래와 같습니다. 참고: &lt;my-template&gt; 내의 &lt;h1&gt;, &lt;p&gt;과 같은 자식 요소들을 Light DOM이라고 합니다. 이들은 템플릿 코드에 있는 지정된 slot을 찾아갑니다. 슬롯 요소에는 name 속성을 사용합니다. 그리고 원하는 슬롯에 배치할 light DOM 요소에는 slot 속성을 사용하며, 해당 속성값으로 슬롯의 name 값을 지정해줍니다. 스타일 지정웹 구성 요소와 shadow DOM 내부 요소에 스타일을 지정하는 다양한 방법이 있습니다. :host: shadow root로 지정된 웹 구성 요소에 스타일을 적용합니다. :host-context(&lt;selector&gt;): 웹 구성 요소 혹은 상위 요소의 선택자가 &lt;selector&gt;와 일치하면, 웹 구성 요소의 자식 요소에 스타일을 적용합니다. ::slotted(&lt;compound-selector&gt;): 지정한 복합 선택자와 일치하는 슬롯 콘텐츠에 스타일을 적용합니다. 간단한 예시를 살펴보시면, 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!-- 템플릿 선언 --&gt;&lt;template id=&quot;my-template&quot;&gt; &lt;style&gt; :host &#123; all: initial; display: block; contain: content; color: green; &#125; :host(:hover) &#123; border: 1px solid blue; &#125; :host-context(.orange-theme) &#123; color: orange; &#125; ::slotted(a) &#123; color: red; text-decoration: none; &#125; &lt;/style&gt; &lt;slot&gt;&lt;/slot&gt;&lt;/template&gt; &lt;!-- 사용자 커스텀 요소 --&gt;&lt;my-template&gt; &lt;h1&gt;Hello Shadow DOM!&lt;/h1&gt;&lt;/my-template&gt; &lt;my-template class=&quot;orange-theme&quot;&gt; &lt;div&gt; &lt;span&gt;text 1&lt;/span&gt; &lt;span&gt;text 2&lt;/span&gt; &lt;span&gt;text 3&lt;/span&gt; &lt;/div&gt;&lt;/my-template&gt; &lt;my-template&gt; &lt;a href=&quot;#&quot;&gt;Hello, Shadow DOM!&lt;/a&gt;&lt;/my-template&gt; 아래와 같이 사용자 커스텀 요소에 지정된 스타일이 적용됩니다. 보다 자세한 스타일 지정 방식은 https://developers.google.com/web/fundamentals/web-components/shadowdom#styling 에서 확인하실 수 있습니다. 참조 https://wit.nts-corp.com/2019/03/27/5552 https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_templates_and_slots https://developers.google.com/web/fundamentals/web-components/shadowdom?hl=ko https://medium.com/@makerspirit/how-to-style-your-twitter-widget-styling-on-shadow-dom-a405c36edd10 https://gist.github.com/praveenpuglia/0832da687ed5a5d7a0907046c9ef1813 https://alligator.io/web-components/composing-slots-named-slots/","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"HTML","slug":"Frontend/HTML","permalink":"https://woonyzzang.github.com/categories/Frontend/HTML/"}],"tags":[{"name":"html","slug":"html","permalink":"https://woonyzzang.github.com/tags/html/"},{"name":"html5","slug":"html5","permalink":"https://woonyzzang.github.com/tags/html5/"}]},{"title":"Cent OS 7 ifconfig 사용","slug":"cent-os7-ifconfig","date":"2019-08-15T03:07:39.000Z","updated":"2024-06-07T09:27:28.273Z","comments":true,"path":"2019/08/15/cent-os7-ifconfig/","permalink":"https://woonyzzang.github.com/2019/08/15/cent-os7-ifconfig/","excerpt":"","text":"Cent OS 7 ifconfig 명령어 사용하기CentOS 7를 설치하고 ifconfig 명령어를 실행하면 아래와 같이 command not found 라고 명령어를 찾을 수 없다는 메시가 뜹니다. 1234$ ifconfig# command not found 메시지 출력-bash: ifconfig: command not found CentOS 7에서는 이전 버전때와 다르게 ifconfig 명령어를 사용할 수가 없습니다. 그래서 ip addr 또는 ip addr show 와 같은 명령어를 이용하여 IP 정보를 확인하여야 합니다. 123$ ip addr$ ip addr show 만약 ifconfig 명령어를 사용하려면 net-tools 패키지를 설치해야 합니다. yum install 명령어를 이용하여 아래와 같이 net-tools 를 설치하면 CentOS 7에서도 ifconfig 명령어를 사용하여 IP를 확인할 수 있습니다. 1$ yum install –y net-tools net-tools 설치가 완료되었으면 ifconfig 명령어를 실행하여 사용하면 됩니다. 1$ ifconfig","categories":[{"name":"OS","slug":"OS","permalink":"https://woonyzzang.github.com/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"https://woonyzzang.github.com/categories/OS/Linux/"},{"name":"CentOS","slug":"OS/Linux/CentOS","permalink":"https://woonyzzang.github.com/categories/OS/Linux/CentOS/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://woonyzzang.github.com/tags/linux/"},{"name":"centos","slug":"centos","permalink":"https://woonyzzang.github.com/tags/centos/"}]},{"title":"Gitlab Install","slug":"gitlab-install","date":"2019-08-12T13:56:30.000Z","updated":"2024-06-05T05:49:09.092Z","comments":true,"path":"2019/08/12/gitlab-install/","permalink":"https://woonyzzang.github.com/2019/08/12/gitlab-install/","excerpt":"","text":"Gitlab 설치 (CentOS 7)Gitlab은 Git의 원격 저장소 기능과 이슈 트래커 기능등을 제공하는 소프트웨어 입니다. 설치형 Github라는 컨셉으로 시작된 프로젝트이기 때문에 Github와 비슷한 면이 많이 있습니다. 서비스 형 원격저장소를 운영하는 것에 대한 비용이 부담되거나, 소스코드의 보안이 중요한 프로젝트에게 적당 합니다. 패키지 종류GitLab 패키지는 3가지로 구분 됩니다. GitLab CE : Community Edition으로 설치형이고 아무런 제한 없이 무료 GitLab EE : Enterprise Edition으로 설치형이고 매월 유저당 과금. 자세한 내용은 https://about.gitlab.com/pricing/ 참고 GitLab.com : 클라우드형이고 개인이 가입해서 사용하면 무료 (10명 이하의 프로젝트는 무료로 사용할 수 있습니다.) CE와 EE 버전 기능 비교는 https://about.gitlab.com/features/#compare 참고. Gitlab의 특징 Git 저장소 및 관리 프로젝트 생성하면 자동으로 git 저장소가 생성됨 그룹 및 팀원 그룹을 만들고 팀원을 지정해서 그룹 단위로 접근 권한을 관리할 수 있음 업무 관리 마일스톤을 설정하고 이슈를 등록해서 담당자를 지정해서 업무를 관리할 수 있음 코드 커밋 로그에 이슈번호 넣으면 자동으로 이슈와 연결 라벨을 사용해서 이슈를 구분해서 관리할 수 있음 코드 리뷰 Merge request를 통해 코드 리뷰를 할 수 있는 프로세스를 만들 수 있음 해당 request에 댓글로 커뮤니케이션 할 수 있고 소스코드에도 댓글 달 수 있음 위키 markdown 형식 지원 wiki 별도 git 저장소가 생성되어 로컬에서 작업해서 push 해도 됨 이력 및 통계 조회 Activity 이력 조회 Files 브라우징 Commit 브라우징(커밋 이력, 브랜치로 비쥬얼하게 이력 조회, 그래프로 통계 제공) 검색 전체 검색: 프로젝트, 이슈, Merge request 검색 가능 그룹 내 검색: 프로젝트, 이슈, Merge request 검색 가능 프로젝트 내 검색: 코드, 이슈, Merge request, 코멘트, Wiki 검색 가능 Snippets 재사용 가능한 소스 코드나 텍스트를 저장해서 사용하는 기능 공통 유틸성 코드나 팁에 대해서 공개해서 사용하면 좋을 것 같다. 관리자 그룹 및 사용자 관리 관리자 페이지에서 사용자 추가해도 되고 회원가입 형태도 되고 LDAP 연동도 가능함 어플리케이션 지원 iOS, Android, Chrome App 등의 Native App 지원 자세한 사항은 https://about.gitlab.com/applications 참고 CI 패키지에 GitLab CI가 내장되어 있음 GitLab과 연동해서 활용하는 방법이 쉽지 않음 1. git 설치일단 설치가 되어 있는지 확인해보겠습니다. 1$ git --version git 최신버전 설치기존 git 이 설치 되어 있다면 최신 버전을 사용하기 위하여 아래 명령어로 제거합니다. 1$ yum remove git 최신 버전을 사용하기 위해서 소스코드를 컴파일 해서 설치를 할 수도 있으나 업그레이드나 여러가지 불편함이 있기에 Wandisco 사에서 운영하는 repository를 사용하겠습니다. 해당 repository를 사용하기 위하여 아래의 링크를 install 합니다. 1$ yum install http://opensource.wandisco.com/centos/7/git/x86_64/wandisco-git-release-7-1.noarch.rpm 다시 git을 install해줍니다. 1$ yum install git 2. Gitlab 설치 공식 홈페이지의 내용을 따라하면 손쉽게 설치가 됩니다. 살짝 설정을 바꿔줄 부분은 있습니다. https://about.gitlab.com/install/#centos-7 공식 홈페이지는 아래가 처음 설치 할 것으로 소개하고 있는데요, 아마 기본적으로 CentOS를 설치할 때 이미 설치되어 있는 것들이 있을 것입니다. 12345678$ sudo yum install curl policycoreutils openssh-server openssh-clients $ sudo systemctl enable sshd $ sudo systemctl start sshd $ sudo yum install postfix $ sudo systemctl enable postfix $ sudo systemctl start postfix $ sudo firewall-cmd --permanent --add-service=http $ sudo systemctl reload firewalld 설치된 패키지 확인은 아래의 명령어로 확인 하시면 됩니다. 1$ yum list installed | grep 패키지명 GitLab Package repository를 추가합니다. 1$ curl -sS https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash gitlab설치 파일을 다운로드 받고 gitlab설치를 합니다. 다음 명령어를 이용해 설치합니다.참고로 설치할때 EXTERNAL_URL 은 옵션값으로 브라우저로 접속할 정보를 입력하는데 여기에 포트도 추가하여 입력해도 됩니다.대신 포트를 추가하는 경우 firewalld 나 iptables를 사용할 경우 에서 추가 설정을 해주어야 합니다. 1$ sudo yum install gitlab-ce or 12345$ sudo EXTERNAL_URL=&quot;http://[server id]:[port]&quot; yum install -y gitlab-ce# 만약 포트번호 추가했을 경우 firewalld 사용시 아래와 같은 방법으로 해제$ sudo firewall-cmd --permanent --zone=public --add-port=[포트번호]/tcp$ sudo systemctl reload firewalld 설치가 완료되면 다음과 같이 로그가 찍힙니다. 123456789101112131415161718192021222324252627282930313233343536373839Running handlers:Running handlers completeChef Client finished, 199/619 resources updated in 03 minutes 36 secondsgitlab Reconfigured! *. *. *** *** ***** ***** .****** ******* ******** ******** ,,,,,,,,,***********,,,,,,,,, ,,,,,,,,,,,*********,,,,,,,,,,, .,,,,,,,,,,,*******,,,,,,,,,,,, ,,,,,,,,,*****,,,,,,,,,. ,,,,,,,****,,,,,, .,,,***,,,, ,*,. _______ __ __ __ / ____(_) /_/ / ____ _/ /_ / / __/ / __/ / / __ `/ __ \\ / /_/ / / /_/ /___/ /_/ / /_/ / \\____/_/\\__/_____/\\__,_/_.___/ Thank you for installing GitLab!GitLab should be available at http://[server id]:[port] For a comprehensive list of configuration options please see the Omnibus GitLab readmehttps://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/README.md Verifying : gitlab-ee-11.3.4-ee.0.el7.x86_64 Installed: gitlab-ee.x86_64 0:11.3.4-ee.0.el7 Complete! 설정을 바꿔줄 부분이 있습니다. 설정을 바꿔줄 부분은 3가지 입니다. gitlab페이지가 기본적으로 80포트를 사용하고 인증 관련된 unicorn 부분은 8080포트를 사용합니다. 만약 해당 포트가 Apache와 Tomcat에서 사용하는 포트와 동일하면 충돌이 합니다. 그리고 이메일을 사용하기 위해 smtp를 설정할 수 있습니다. gitlab설정파일은 아래에 있습니다. 아래의 경로의 파일을 vi에디터로 오픈합니다. 1$ vi /etc/gitlab/gitlab.rb 오픈 하자마자 보시면 external_url 항목이 보이게 됩니다. gitlab페이지가 보여지는 웹사이트 포트번호 입니다. 원하시는 포트번호를 입력합니다. 나중에 방화벽에서도 오픈시킬 번호 입니다. 1external_url &#x27;http://localhost:포트번호&#x27; 인증 및 unicorn 과 관련된 부분이 두군데가 있습니다. 에디터 화면에서 &#x2F; 입력한후 8080으로 입력하시면 쉽게 찾으실수 있습니다. 8080으로 되어 있는 줄에서 반드시 ‘#’으로된 주석을 제거 하시고 8080 번호를 다른 포트로 변경합니다. 변경하실때 위에서 변경한 포트와 다른 포트로 변경합니다. 내부적으로 인증과 관련한 포트 번호 입니다. 이 포트는 방화벽을 해제할 필요는 없습니다. 이제 smtp설정입니다. 이는 gitlab에서 유저 인증이나 각종 알림의 용도로 사용됩니다. 에디터 화면에서 smtp_enable 라는 글자로 검색을 해봅니다. 검색은 &#x2F; 명령어 입니다. 위 설정을 google smtp정보를 입력할 것입니다. 그리고 입력하시고 주석을 제거합니다. 위 설정은 필수는 아닙니다. 설정을 하지 않으면 유저 생성할때 패스워드 생성할때 유저에게 이메일 보내어 인증이 된 사용자에게 패스워드를 설정하게 되는데, 이는 사용자를 생성하고 다시 관리자가 다시 사용자 정보에 재진입하여 패스워드를 설정해주면 됩니다. 구글 smtp설정은 아래 링크를 참조하세요. https://support.google.com/a/answer/176600?hl=ko 기타 메일 설정은 아래 링크에 더 있습니다. https://docs.gitlab.com/omnibus/settings/smtp.html 12345678910gitlab_rails[&#x27;smtp_enable&#x27;] = true gitlab_rails[&#x27;smtp_address&#x27;] = &quot;smtp.gmail.com&quot; gitlab_rails[&#x27;smtp_port&#x27;] = 587 gitlab_rails[&#x27;smtp_user_name&#x27;] = &quot;my.email@gmail.com&quot; gitlab_rails[&#x27;smtp_password&#x27;] = &quot;my-gmail-password&quot; gitlab_rails[&#x27;smtp_domain&#x27;] = &quot;smtp.gmail.com&quot; gitlab_rails[&#x27;smtp_authentication&#x27;] = &quot;login&quot; gitlab_rails[&#x27;smtp_enable_starttls_auto&#x27;] = true gitlab_rails[&#x27;smtp_tls&#x27;] = false gitlab_rails[&#x27;smtp_openssl_verify_mode&#x27;] = &#x27;peer&#x27; 변경이 완료되었으면 저장하고 빠져 나옵니다. 이제 방화벽 설정을 합니다. 첫번째로 변경한 gitlab페이지가 보여지는 웹사이트 포트번호만 오픈 하시면됩니다. 12$ firewall-cmd --permanent --add-port=변경한포트/tcp $ firewall-cmd --reload 그리고 다음 명령어를 실행하여 적용 합니다. 1$ sudo gitlab-ctl reconfigure 이제 설치가 완료되었습니다. 이제부터 EXTERNAL_URL에 입력한 URL 을 브라우저로 접근이 가능합니다.웹브라우저에서 설정변경한 포트로 진입해봅니다. 1http://서버아이피:변경한포트번호 입력하고 들어가시면 아래의 화면이 처음 나타납니다. root 계정의 패스워드 설정화면입니다. 원하시는 암호로 설정하고 root 아이디로 로그인합니다. root로 로그인하면 나오는 화면입니다. 위쪽에 스패너 아이콘이 관리자용 설정 메뉴입니다. 이곳에서 유저 생성이 가능합니다. 접속 URL 변경 및 수정 1234567891011121314# gitlab.rb 파일안에 URL을 수정합니다.$ vi /etc/gitlab/gitlab.rb ### 아래의 내용을 찾아 수정합니다.external_url &#x27;http://[변경할 server id]:[변경할 port]&#x27; # Gitlab 레파지토리 적용$ sudo gitlab-ctl reconfigure # Gitlab 재시작$ sudo gitlab-ctl restart# 포트 활성화$ firewall-cmd --permanent --add-port=변경한포트/tcp GitLab 서버의 시작&#x2F;종료 12345# Gitlab 서버 시작$ sudo gitlab-ctl start# Gitlab 서버 종료$ sudo gitlab-ctl stop 메일 테스트 12345678910$ sudo gitlab-rails console# 테스트 메일 보내기irb(main):001:0&gt; Notify.test_email(&#x27;xxx@gmail.com&#x27;, &#x27;Message Subject&#x27;, &#x27;Message Body&#x27;).deliver_now# 콘솔 나오기irb(main):002:0&gt; exit# sudo vi /etc/gitlab/gitlab.rb 의 smtp 관련 옵션 수정시 Gitlab 재시작$ sudo gitlab-ctl restart 구글 보안 수준이 낮은 앱의 액세스가 허용되어야 한다. https://www.google.com/settings/security/lesssecureapps gitlab 제거설치되어 있는 gitlab을 제거하기 위해서는 다음과 같은 순서로 실행한다. 123$ gitlab-ctl cleanse$ gitlab-ctl uninstall$ yum remove gitlab-ce 참조 https://about.gitlab.com/ https://wikidocs.net/16279 https://lunightstory.tistory.com/20","categories":[{"name":"Server","slug":"Server","permalink":"https://woonyzzang.github.com/categories/Server/"},{"name":"Gitlab","slug":"Server/Gitlab","permalink":"https://woonyzzang.github.com/categories/Server/Gitlab/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"https://woonyzzang.github.com/tags/gitlab/"}]},{"title":"Cent OS 7 Install","slug":"cent-os7-install","date":"2019-08-12T13:52:30.000Z","updated":"2024-06-07T09:27:28.273Z","comments":true,"path":"2019/08/12/cent-os7-install/","permalink":"https://woonyzzang.github.com/2019/08/12/cent-os7-install/","excerpt":"","text":"Cent OS 7 설치하기리눅스 운영체제는 소스코드 수정이 자유로운 만큼 다양한 프로젝트를 통하여 배포됩니다. 공개 운영체제 배포판 중 레드햇 엔터프라이즈 리눅스와 완벽하게 호환되는 CentOS를 기준으로 설치 방법을 안내하고자 합니다.RHEL의 복제판이라고 볼 수 있는 CentOS는 안정성이 입증되었다는 것이 장점이지만 레드햇의 기술 지원을 받을 수 없다는 단점이 있습니다. Cent OS 이미지 다운로드CentOS 공식 홈페이지 https://www.centos.org/download/ 에서 centOS iso를 다운받을 수 있습니다.DVD ISO는 centOS 풀패키지이며 용량이 크며, Minimal ISO는 centOS 패키지중 minimal설치만 가능한 버전이며 용량이 작습니다.DVD ISO와 설치가 다른점이 있다면 중간에 설치방식을 묻는것이 생략이 됩니다. Cent OS 7 설치부팅이 진행된다면 아래와 같이 나타납니다. 여기서 커서를 이용하여 Install CentOS 7 을 선택하신 후에(기본 값으로 Test this media &amp; install CentOS 7 이 선택되어 있을 것입니다.) Install CentOS 7를 선택하시면 됩니다.I를 누르고 엔터를 치커나 화살표로 찾아가서 엔터를 치거나 하면됩니다. 설치 마법사의 언어를 선택하는 선택창 화면이 나타납니다.한국어 OS를 설치 하려면 한국어를 선택한 후 계속 진행을 클릭 합니다.(검색 입력창에 kor 정도만 쳐도 한국어 선택을 빠르게 찾을 수 있습니다.)영어에 자신있으시면 바로 continue 누르셔도 상관없습니다. 설치할때만 사용되는 언어이니 편한것으로 선택하세요. 설치 요약 화면이 나타납니다. 여기서부터 하나하나 설정해보도록 하겠습니다. 설치 대상 에서는 디스크 파티션 작업을 통해 운영체제에 대한 디스크 관리를 효율적으로 설정할 수 있습니다. 리눅스에서의 디스크 파티션 작업은 중요합니다. 추후에 파티션 변경이 어려울 뿐만 아니라 서버의 특정 디렉토리 마다 할당되어야 하는 디스크 크기가 다를 수 있기 때문입니다. 먼저 워크스테이션 용도인 경우 할당된 로컬 표준 디스크를 선택한 후 파티션 설정 항목의 파티션을 자동으로 설정합니다를 선택한 후 완료를 클릭합니다. 서버용으로 사용 시에도 파티션 자동 설정을 사용해도 추후 큰 영향을 끼치지는 않습니다. (자동 할당은 해당 운영체제의 권장 파티션 설정 내용과 비슷하게 맞추어질 것입니다.) 하지만 조금 더 효율적으로 관리하기 위해서 수동 설정을 하고 싶을 경우, 파티션을 설정합니다를 선택하고 완료를 클릭합니다. 첫번째로 &#x2F;boot 디렉토리에 대한 크기를 지정합니다. CentOS에서는 boot 디렉토리에 대한 권장 용량을 250~500MB로 안내하고 있습니다. 넉넉하게 500MB를 지정하겠습니다. 이 작업을 진행할 때, 디렉토리는 앞에 &#x2F;(최상위 경로)를 붙여야하며 용량은 M(MB), G(GB)와 같이 표기해야 합니다. 마운트 지점(P): &#x2F;boot 용량(D): 500M 지점 설정이 완료되면 마운트 지점 추가 를 클릭합니다. 만들어진 &#x2F;boot 파티션의 장치 유형을 ‘표준 파티션’으로, 파일 시스템을 ‘ext4’로 설정한 후 ‘+’ 버튼을 클릭하여 계속 진행합니다. [참고사항]SWAP은 일종의 메모리 확보라고 생각하시면 될 듯 합니다. 기존메모리가 부족할때 대신 swap 파티션을 잡아두었던 메모리를 사용합니다. 일반적으로 RAM 사용량의 2배이상 권고설정이라고 알고있는분들도 있으시겠지만 서버의 용도나 실서버 하드웨어에 들어가는 RAM 용량이 얼마냐에 따라 튜닝작업을 해야합니다. 테스트용이나 기본적으로 1~2GB RAM 으로 셋팅하므로 위와 동일하게 하시고 넘어가면 됩니다. 추가적으로 하드디스크의 용량을 사용하기때문에 충분히 용량을 확인하고 설정하시기 바랍니다. 만들어진 SWAP 파티션의 장치 유형을 표준 파티션으로, 파일 시스템이 SWAP인지 확인한 후 + 버튼을 클릭하여 계속 진행합니다. 이번에는 홈 디렉토리의 크기를 설정합니다. 마운트 지점에 ‘&#x2F;home’ 을 입력합니다. 홈 디렉토리는 사용자 전체의 개인 홈 디렉토리이며 일반적인 문서나 파일 등이 위치하는 곳이므로 용도에 따라 크거나 작게 설정해야 합니다. 서버용인 경우 특별히 홈 디렉토리의 크기를 크게 지정할 필요가 없습니다. 워크스테이션 용도로 사용할 것이라면 다운로드 파일이나 개인 파일 보관 용도로 홈 디렉토리가 자주 사용되므로 많은 공간을 할당해야할 수 있습니다. 여기서는 20GB(20G 입력)를 지정하겠습니다. 마운트 지점 추가를 클릭하여 계속 진행합니다. &#x2F;home 파티션의 장치 유형을 LVM으로, 파일 시스템이 ext4인지 확인한 후 + 버튼을 클릭하여 계속 진행합니다. [참고사항]파일시스템 : EXT4 , 장치 유형 LVM 설정하는 이유는 좀더 효율적으로 디스크를 사용 및 관리하기 위해서 입니다.이제 가상화 시스템에서도 많이 안정화되었으며 여러모로 특징이 많으므로 기본적으로 사용하는게 좋습니다. 마지막으로 남아있는 용량을 루트 디렉토리 경로(&#x2F;)에 지정합니다. 마운트 지점을 / 로 입력하고 용량은 비워둔 채로 마운트 지점 추가 를 클릭합니다. 마찬가지로 &#x2F; 파티션의 장치 유형을 LVM으로, 파일 시스템이 ext4 인지 확인합니다.이제 파티션 설정이 완료되었습니다. 상단의 완료 를 클릭하여 수동으로 파티션 설정을 마치겠습니다. 변경 요약에서 변경된 사항을 확인하시고 변경 사항 적용 을 클릭하여 적용을 완료합니다. 네트워크 &amp; 호스트 이름 에서는 현재 운영체제가 연결할 네트워크 어댑터 설정을 지정할 수 있습니다. 특별한 경우가 아니라면 네트워크 자동 설정(DHCP)을 위해 우측의 끔 을 켬 으로 스위칭만 해주시면 됩니다. 네트워크 수동 설정을 하려면 끔 상태에서 하단의 ‘설정’ 을 통해 네트워크 수동 설정을 진행하실 수 있습니다. 네트워크 설정은 운영체제가 설치된 이후에도 다시 지정할 수 있습니다. 마지막으로 SECURITY POLICY 에서는 보안 강화 리눅스에 대한 정책을 설정할 수 있는 항목입니다. 보안 강화 리눅스(SELinux : Security-Enhanced Linux)는 리눅스에 대한 보안 정책을 강화하여 읽기&#x2F;쓰기에 대한 치밀한 규칙을 적용하게 되어 외부 공격을 추가로 차단할 수 있도록 합니다. 특별한 경우가 아니라면 보안 강화 리눅스를 켜두시는 것을 권장하므로 켬 상태이라면 완료 를 클릭하여 다음 과정으로 진행합니다. 다만 일부 서버의 관리 방식에 따라 SELinux가 켜져있음으로서 발생하는 각종 오류나 권한 문제가 발생할 수 있습니다. 서버 자체의 보안 정책이 있거나 SELinux의 관리에 어려움이 있을 경우에는 끈 상태로 전환할 수 있습니다. 물론 활성화 여부와는 상관없이 설치 이후에도 SELinux 관련 정책을 설정할 수 있습니다. 이제 설치 옵션을 모두 검토한 후 설치 시작 을 눌러 본격적인 CentOS 7 설치를 시작합니다. 설치가 진행되는 중에 사용자 및 루트(Root) 계정을 지정할 수 있습니다. 사용자 생성을 하려면 사용자 생성을 클릭합니다. (선택) 리눅스의 주요 사용자를 생성합니다. 하단의 예시와 같이 정보를 입력한 후 완료 를 클릭합니다. 성명 : 사용자 이름입니다. 로그인 시 사용할 계정 아이디이므로 너무 짧거나 길면 안됩니다. 사용자 이름 : 위 계정 이름과는 다른 사용자의 실제 이름(또는 별칭)입니다. 이 사용자를 관리자로합니다 : 현재 사용자에게 관리자 권한(sudo)을 부여할 것인지에 대한 여부입니다. 이 계정을 사용하려면 암호가 필요합니다 : 현재 사용자가 로그인할 때 암호를 사용할 것인지 여부입니다. 보안을 위해 암호를 설정하는 것이 좋습니다. 암호 &#x2F; 암호 확인 : 현재 사용자의 암호를 입력합니다. ROOT 암호 에서는 Root 계정의 암호를 설정할 수 있습니다. root 암호는 보안을 위해 반드시 설정해야만 합니다. 사진에서는 테스트용으로 짧게 입력되었지만 8~10자 이상으로 길고 복잡한 암호로 설정하는 것을 권장합니다. (필수) 남은 설치 과정은 자동으로 진행될 것입니다. 잠시 기다리시면 모든 설치 작업이 완료될 것입니다. ‘CentOS이&#x2F;가 시스템에 성공적으로 설치되어 사용할 준비가 되어있습니다!’ 메세지가 나왔다면 ‘재부팅’ 을 클릭하여 설치를 마칩니다. 참조 https://www.centos.org/ https://aeac.tistory.com/11 https://jootc.com/p/201806031103","categories":[{"name":"OS","slug":"OS","permalink":"https://woonyzzang.github.com/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"https://woonyzzang.github.com/categories/OS/Linux/"},{"name":"CentOS","slug":"OS/Linux/CentOS","permalink":"https://woonyzzang.github.com/categories/OS/Linux/CentOS/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://woonyzzang.github.com/tags/linux/"},{"name":"centos","slug":"centos","permalink":"https://woonyzzang.github.com/tags/centos/"}]},{"title":"Descktop Web IE 브라우저 background-attachment fixed 버그 이슈","slug":"descktop-web-ie-background-attachment-fixed","date":"2019-08-09T08:14:44.000Z","updated":"2024-06-05T05:17:43.340Z","comments":true,"path":"2019/08/09/descktop-web-ie-background-attachment-fixed/","permalink":"https://woonyzzang.github.com/2019/08/09/descktop-web-ie-background-attachment-fixed/","excerpt":"","text":"IE 브라우저 background-attachment:fixed 버그 이슈background-attachment:fixed 속성 사용시 IE 브라우저에서 버그가 발생한다. edge에서 배경이 사라지는 현상 이였고, IE11(확인한 브라우저가 IE11이였지만 하위버전에서도 발생)에서 화면이동시(마우스 휠 또는 키보드 사용시) 버벅임? 또는 화면떨림이 발생하는 현상이다. 해결방안CSSie, edge에서 background attachment 속성 사용 했을때 튀는현상 해결방법(부분해결) 123html, body&#123;height:100%&#125;html&#123;overflow:hidden&#125;body&#123;overflow:auto&#125; 이를 임시방편으로 해결하는 방법은 아래와 같이 html, body 에 속성을 주는 것인데, 주의해야 할 점은 위 방법으로 속성을 주는 경우 문제점은 javascript에서 스크롤 이벤트가 동작하지 않게 된다. JavaScriptie background-fixed 튀는현상 현상 해결을 위한 스크립트 (마우스 휠이벤트를 제어하는방식) 123456789101112131415161718192021222324252627if (navigator.userAgent.match(/Trident\\/7\\./)) &#123; // IE 브라우저 분기 예외 처리 // 스크롤 이슈 대응 document.body.addEventListener(&#x27;mousewheel&#x27;, function() &#123; event.preventDefault(); var wheelDelta = event.wheelDelta; var currentScrollPos = window.pageYOffset; window.scrollTo(0, currentScrollPos - wheelDelta); &#125;); // 키보드 방향키 이슈 대응 document.body.addEventListener(&#x27;keydown&#x27;, function(e) &#123; e.preventDefault(); var currentScrollPos = window.pageYOffset; switch (e.which) &#123; case 38: // up window.scrollTo(0, currentScrollPos - 120); break; case 40: // down window.scrollTo(0, currentScrollPos + 120); break; &#125; &#125;);&#125;","categories":[{"name":"Web","slug":"Web","permalink":"https://woonyzzang.github.com/categories/Web/"},{"name":"Descktop","slug":"Web/Descktop","permalink":"https://woonyzzang.github.com/categories/Web/Descktop/"}],"tags":[{"name":"descktop","slug":"descktop","permalink":"https://woonyzzang.github.com/tags/descktop/"}]},{"title":"Descktop Web Input number 타입의 속성 maxlength 사용","slug":"descktop-web-input-number-maxlength","date":"2019-08-09T08:10:19.000Z","updated":"2024-06-05T05:18:37.789Z","comments":true,"path":"2019/08/09/descktop-web-input-number-maxlength/","permalink":"https://woonyzzang.github.com/2019/08/09/descktop-web-input-number-maxlength/","excerpt":"","text":"입력창 number 타입의 속성 maxlength 글자수 제한 설정input 엘리먼트에는 기본적으로 maxlength 속성이 존재하는데, 이는 value 속성의 값을 maxlength 속성 값 이하로 최대 글자 수를 제한하는 기능 이다. 1&lt;input type=&quot;text&quot; name=&quot;inputBox&quot; maxlength=&quot;10&quot;&gt; 그러나 type&#x3D;”number” 에서는 maxlength 속성 기능이 동작하지 않는다. 1&lt;input type=&quot;number&quot; name=&quot;inputBox&quot; maxlength=&quot;10&quot;&gt; 이유는 type이 number 인 input 엘리먼트는 기본적으로 maxlength 기능을 지원하지 않기 때문이다. 해결방안oninput 이벤트를 사용하여 별도의 스크립트로 처리oninput 이벤트는 html5에서 추가된 이벤트로 데이터를 입력받았을 경우 발생된다.onchange 이벤트 하고는 다르다. 12345function maxLengthCheck(selector) &#123; if (selector.value.length &gt; selector.maxLength) &#123; selector.value = selector.value.slice(0, selector.maxLength); &#125; &#125; 1&lt;input type=&quot;number&quot; pattern=&quot;[0-9]*&quot; maxlength=&quot;2&quot; oninput=&quot;maxLengthCheck(this)&quot;&gt; HTML custom data 속성 활용HTML5일 경우에는 커스텀 data 속성을 활용하여 처리하면 HTML Validator 검사 시 문제가 되지 않는다. 123456789101112131415161718function maxlengthNumber(selector, maxNum) &#123; maxNum = (maxNum) ? maxNum : selector.dataset.maxlength; maxNum = parseInt(maxNum, 10); if (&#x27;oninput&#x27; in document.createElement(&#x27;input&#x27;)) &#123; selector.addEventListener(&#x27;input&#x27;, function() &#123; if (this.value.length &gt; maxNum) &#123; this.value = this.value.slice(0, maxNum); &#125; &#125;, false); &#125; else &#123; if (maxNum) &#123; selector.setAttribute(&#x27;maxlength&#x27;, maxNum); &#125; else &#123; selector.setAttribute(&#x27;maxlength&#x27;, selector.dataset.maxlength); &#125; &#125;&#125; 123&lt;input type=&quot;number&quot; data-maxlength=&quot;2&quot; pattern=&quot;[0-9]*&quot; id=&quot;iptNumber&quot;&gt; &lt;!-- 패턴1 --&gt;&lt;input type=&quot;number&quot; pattern=&quot;[0-9]*&quot; id=&quot;iptNumber&quot;&gt; &lt;!-- 패턴2 --&gt; 123maxlengthNumber(document.querySelector(&#x27;#iptNumber&#x27;)); // 패턴1maxlengthNumber(document.querySelector(&#x27;#iptNumber&#x27;), 2); // 패턴2","categories":[{"name":"Web","slug":"Web","permalink":"https://woonyzzang.github.com/categories/Web/"},{"name":"Descktop","slug":"Web/Descktop","permalink":"https://woonyzzang.github.com/categories/Web/Descktop/"}],"tags":[{"name":"descktop","slug":"descktop","permalink":"https://woonyzzang.github.com/tags/descktop/"}]},{"title":"Docker Cluster (Linux)","slug":"docker-cluster","date":"2019-08-09T05:17:36.000Z","updated":"2025-03-29T04:58:20.258Z","comments":true,"path":"2019/08/09/docker-cluster/","permalink":"https://woonyzzang.github.com/2019/08/09/docker-cluster/","excerpt":"","text":"Docker cluster - swarmDocker 는 cluster를 구성 하기위해서 swarm 이란 기능을 사용합니다. 1. cluster란 무엇인가?1) 탄생 배경 서버의 부하를 줄이고 최대의 가용성을 뽑아내기 위해서 나온 기술 입니다. 2) 구현 방식 cluster를 구성 하기 위해서는 manager-node와 worker-node가 필요 합니다. manger-node: worker-node를 관리 합니다. worker-node: service를 제공합니다. cluster는 worker node를 묶어서 서비스를 제공 합니다. 3) 동작 원리 Web 서비스를 예를 들면 한개의 도메인(google.com)에 cluster로 묶인 서버(worker-node)를 사용하여 서비스를 제공할 경우 사용자는 매번 google.com에 접속시 cluster로 묶인 서버(worker-node) 중 한대를 접속 할 수 있게 됩니다. 2. Docker swarm 이란 무엇인가? Docker에서 제공하는 cluster 입니다. 제공하는 기능은 다음과 같습니다. 1) docker engine 통합 관리 docker manager-node에서 worker-node를 통합 관리 할 수 있습니다. 2) load balancing 부하 분산 기능으로 외부에서 worker-node 접속시 round robin 방식으로 worker-node의 task를 연결 해 줍니다. 3) task 개수 조절 기능 (scale) scale 옵션을 통하여 service할 task의 개수를 조절 합니다. task는 node에서 제공하는 docker swarm에서 생성한 service를 의미 하며 service는 container와 동일 한 역활을 합니다.단지 swarm에서 구분을 하기위 해서 task라고 사용 합니다. 4) multi-host-networking overlay network 를 통하여 task 간 사용할 수 있는 네트워크를 제공 5) 내장 DNS 서버 제공 service에서 DNS name을 할 당하여 swarm 내에있는 node에서는 내장 DNS 서버를 사용 할 수 있습니다. 3. Docker swarm의 종류1) docker warm mode manager-node와 worker-node가 한 host에 공존하는 모드, 즉 manager-node또 worker-node 기능을 수행 하는 모드 입니다. 2) docker swarm manager-node와 worker-node를 따로 구성 하는 모드(대규모 에서 사용합니다) 4. Docker swarm mode 물리 적인 구조 manager-node 및 worker-node는 docker warm생성시 제공하는 ingress(overlay network) 로 연결 되어 있습니다. ingress(overlay-network)는 task간의 통신 및 load balancing 할 때만 사용 이 됩니다. Load balancing은 IPVS 라는 기술을 사용하여 수행 됩니다. IPVS (IP Virtual Server) implement s transport-layer load balancing, usually called Layer 4 LAN switching, as part of the Linux kernel. It’s configured via the user-space utility ipvsadm tool. 5. Docker swarm mode의 Load Balancing 방식 외부에서 어떤 host에 접근 하더라도 IPVS와 ingress network를 사용하여 worker-node들이 제공하는 모든 task에 접속 가능 합니다. 6. Docker swarm mode 사용법1) swarm mode cluster 구축 1$ docker swarm init --advertise-addr 10.0.8.92 2) node 생성(1) manager node 생성 swarm init을 수행 곳이 manager node가 됩니다. (2) worker-node 생성 swarm mode cluster에 참여 하면 worker-node가 됩니다. 참여 방법은 docker swarm init 을 했을 때 나오는 명령어를 사용하여 cluster 참여가 가능 합니다. 1$ docker swarm join --token SWMTKN-1-2zrp09019pe22hd1tw7grbjbcdwhkzopw5bkk1jwvi6lzr6mkc-0faquay497st4jnsiru1ibuc1 10.0.8.92:2377 나중에 cluster 참가 token을 잊어버리는 경우에는 docker swarm join-token worker 명령어로 확인 가능 합니다. (3) node 제거 1$ docker swarm rm &#123;node name&#125; (4) cluster 종료 1$ docker swarm leave [--force] –force 는 manager node가 cluster를 떠날 때 사용 합니다. 3) cluster 상태 확인 1$ docker node ls MANAGER STATUS에서 Leader로 되어있는 node가 manager node 입니다. 4) node에 service 배포 하기 (manager-node에서만 가능) 1$ docker service create --name myweb --replicas 2 -p 80:80 nginx – name: service 이름 – replicas: 생서 할 task의 개수 -p: port mapping nginx: service할 image 파일 5) service 개수 조절 하기 1$ docker service scale myweb=4 scale: task 개수를 조절 하겠다는 의미 myweb &#x3D; 4: myweb service의 task를 4개로 한다. 6) service 삭제 하기 1$ docker service rm myweb myweb : 삭제할 service 이름 6. Docker swarm mode TEST manager-node 에서 service를 올렸지만 worker-node에 접속을 해도 잘 나오는 것을 확인 할수 있습니다. 10.0.8.92(master-node) 10.0.8.100(worker-node) docker swarm은 부하 분산을 하기위해서 web서비스에서 꼭 필요한 기능 입니다. 참조 https://doitnow-man.tistory.com/190","categories":[{"name":"Server","slug":"Server","permalink":"https://woonyzzang.github.com/categories/Server/"},{"name":"Docker","slug":"Server/Docker","permalink":"https://woonyzzang.github.com/categories/Server/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://woonyzzang.github.com/tags/docker/"}]},{"title":"Docker 네트워크 (Linux)","slug":"docker-network","date":"2019-08-09T04:18:39.000Z","updated":"2024-06-07T09:27:28.298Z","comments":true,"path":"2019/08/09/docker-network/","permalink":"https://woonyzzang.github.com/2019/08/09/docker-network/","excerpt":"","text":"Docker의 네크워크 구현 방식 네트워크 종류 설명 host 호스트이 네트워크 환경을 대로 사용하는 방식 bridge 새로운 bridge를 생성하여 container를 bridge에 연결하여 사용하는 방식 (Docker에서는 기본적으로 bridge 방식을 제공) overlay 물리적으로 떨어진 서버에서 Docker만의 네트워크를 구성하기 위한 네트워크 입니다. none 네트워크에 연결되어 있지 않은 상태. Docker의 네트워크 - bridge 방식(기본 방식)1. Docker 네트워크 구조 container 별로 가상의 NIC를 할당 받아 통신 할 수 있습니다. Docker는 독립 된 네트워크를 구성 하기위하여 3가지 기술을 사용 합니다. 1) network namespace contianer안의NIC와 Container의 NIC와 pair 되는 VNIC를 만드는데 사용 합니다. 2) bridge llinux에서 software로 구현 한 bridge bridge하나 당 개별 네트워크를 구성 할 수 있습니다. container에 bridge를 2개 할 당하면 Container는 2개의 NIC를 가질 수 있습니다. L2 통신만을 지원 합니다. 3) iptables Container가 외부 네트워크 통신을 하기 위해서 사용 됩니다. NAPT를 이용하여 통신을 한다. *NAPT 란 ? 내부 사설 IP와 Port를 공용 IP와 Port로 변경 시켜주는 기능입니다. 2. Docker 네트워크 통신 과정1) 내부 통신 container는 같은 bridge에한 해서L2 통신을 수행 합니다. bridge가 다른 container 끼리는 통신 할 수 없습니다.즉, container0 과 container2는 통신 불 가 합니다. 1) 외부 통신 (1) container -&gt; 외부 bridge까지는 L2 통신을 한 후 Iptables의 POSTROUTING 을 거쳐 MASQUERADE 되어 외부로 나갑니다. (2) 외부 -&gt; container Docker host에 들어온 패킷이 PREROUTING chain 을 통해 DOCKER Chain 으로 전달하고,Docker Chain에서는 DNAT로 8080 포트로 들어온 요청을 172.17.0.2 IP를 가진 container 의 80 포트로 포워딩 되는 것을 알 수 있다. 3. Docker 기본 Container 생성시 네트워크 정보1). 현재의 네트워크 확인 1$ docker network ls 2). 기본 으로 생성한 container의 네트워크 상태(1). 생성 1$ docker run -itd --name centos-original centos (3). container 네트워크 확인 1$ docker container inspect centos-original host(docker가 실행되고 있는 서버)에서 ping으로 IP 연결 상태 확인1$ ping 172.17.0.2 Docker의 네트워크 - 사용자 정의 네트워크1. Docker 사용자 정의 네트워크 관리 [bridge 방식] Docker에서는 사용자 정의 네트워크를 생성 할 수 있게 해주는 기능을 제공 합니다. 이 기능으로 Docker 자체만으로 다양한 네트워크 망을 구성 할 수 있습니다. 1) 사용자 정의 네트워크 생성 (network create)(1) 생성 1$ docker network create --driver=bridge &#123;생성할 bridge 이름&#125; driver옵션을 사용하여 생성할 네트워크를 지정 할 수 있습니다. brctl show를 통하여 bridge 정보 확인*brctl 이 없으면 yum install bridge-utils 로 설치 (2) docker에서 확인 1$ docker network ls // bridge 정보 확인 1$ docker network inspect &#123;생성한 bridge 명&#125; // 상세 내역 확인 2) 사용자 정의 네트워크 삭제 (rm)(1) 삭제 1$ docker network rm &#123;삭제 할 bridge 이름&#125; (2) 유의 사항 해당 bridge를 사용하고 있는 container가 구동 중이면 삭제가 되지 않습니다. Docker의 Container 네트워크1) container에 사용자 정의 네트워크 설정 (–net)(1) container를 생성시 기본 네트워크로 설정 {–net}옵션을 사용하여 사용자 정의 네트워크를 기본 네트워크로 설정 할 수 있습니다.1$ docker run -itd --net=mybridge --name=centos-network-1 centos (2) container의 네트워크 상태 확인 1$ docker container inspect centos-network-1 mybridge로 네트워크가 설정 된것을 확인 할 수 있습니다. 2) container에 사용자 정의 네트워크 추가 (connect) 핵심 : container에 할당 된 network 를 추가 시켜 주면 됩니다. (1) container에 네트워크 추가 123$ docker network create --driver=bridge mybridge$ docker network connect mybridge-1 centos-network-1 (2) container에 네트워크 추가된 네트워크 확인 123$ docker attach &#123;container이름&#125;$ docker attach centos-network-1 docker에 접속하여 ifconfig로 NIC가 2개 가된것을 확인 할 수 있습니다.*ifconfig가 없을 시”yum install net-tools” 로 설치 하시면 되십니다.(현재 테스트 하면서 캡쳐를 한거라 Network ID가 다릅니다. NAME으로 구분 하시면 되십니다.) 3) container에 사용자 정의 NIC 삭제 (disconnect) 핵심 : container에 할당 된 network 를 끊어 주면 됩니다. (1) NIC 삭제 123$ docker network disconnect &#123;삭제할 bridge 이름&#125; &#123;container이름&#125;$ docker network disconnect mybridge-1 centos-network-1 // ex (2)docker 로 Container Network 확인 1$ docker container inspect centos-network-1 Docker의 네트워크 주소 관리1) 네트워크 대역 관리 Docker는 Bridge에 할당된 네트워크 대역을 사용하여 Container에 IP가 할당 됩니다. Docker에서는 Bridge를 생성 할 때만다 네트워크 대역을 자동으로 1씩 증가 시킵니다.Ex)첫번째 brdige: 172.17.0.0&#x2F;24두번째 brdige: 172.18.0.0&#x2F;24 bridge에 container가 추가 될 떄 만다 자동으로 IP 번호가 증가 하여 할당 됩니다.Ex)첫번째 container: 172.17.0.2두번째 container: 172.17.0.3 2) 네트워크 대역 변경(1) 사용자 정의 네트워크를 생성시 IP 대역을 변경 할 수 있습니다. 1$ docker network create --driver=bridge --subnet=172.1.0.0/16 --ip-range=172.1.0.0/24 --gateway=172.1.0.1 mybridge 3) Container IP 설정(1) container 생성시 설정 1$ docker run -itd --ip 172.1.0.5 --net=mybridge --name=centos-network-1 centos –ip : container에 할당 할 IP 설정–net : container 할당 할 IP가 속해 있는 network 대역을 가진 bridge 설정 (2) container 생성 후 변경&lt;핵심&gt; container의 network를 삭제 후 다시 등록 &lt;정보&gt; contianer 명 : centos-network-1 &lt;절차&gt; container 종료 #docker container stop centos-network-1 container에서 네트워크 삭제 #docker network disconnect mybridge centos-network-1 container에 네트워크 추가 #docker network connect mybridge –ip&#x3D;172.1.0.10 centos-network-1 container 시작 #docker container start centos-network-1 참조 https://doitnow-man.tistory.com/183?category=768603","categories":[{"name":"Server","slug":"Server","permalink":"https://woonyzzang.github.com/categories/Server/"},{"name":"Docker","slug":"Server/Docker","permalink":"https://woonyzzang.github.com/categories/Server/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://woonyzzang.github.com/tags/docker/"}]},{"title":"Docker Container 관리 (Linux)","slug":"docker-container","date":"2019-08-09T04:17:02.000Z","updated":"2020-09-05T13:07:55.792Z","comments":true,"path":"2019/08/09/docker-container/","permalink":"https://woonyzzang.github.com/2019/08/09/docker-container/","excerpt":"","text":"1. Container 리스트 확인1$ docker ps -a 2. Container foreground생성 container 생성시 -i, -t 옵션을 주어 표준 입출력이 활성화 되어, 상호 작용이 가능한 상태로 실행 container를 생성 한다는 것은 image를 실행하여 가상의 공간을 만는 것이다. container 생성 방법은 2가지 존재 한다. 1) run 사용 하여 생성 생성후 바로 container에 접속 1$ docker run -i -t --name &#123;이미지 별칭&#125; &#123;이미지 이름:Tag명&#125; -i 옵션 : 상호 작용을 하겠다. -t 옵션 : 터미널을 사용하겠다. –name 옵션 : container에 별칭을 붙인다. 2) create 사용하여 생성 1$ docker ps -a *STATUS 정보 Create: Container 생성만 되고 실행 되지 않은 상태 Exit: Container가 종료된 상태 UP: Container가 실행 중 인 상태 3. Container background 생성 container 생성시 -d (–detach) 옵션을 주어 container를 background로 동작하게 합니다. background 모드에서는 container내에서 프로그램이 foreground로 실행 되고 있어야 합니다. 그렇지 않으면 container는 종료 됩니다. 그래서 ubuntu 이미지를 -d 옵션으로 실행 할 경우 바로 종료가 됩니다. 강제로 start해도 foreground로 실행되는 프로그램이 없어서 바로 종료 됩니다. 1) background 데몬 접속 하기 container가 -d 옵션으로 실행되어도 bash shell을 활성화 시켜 접속 할 수 있습니다. 1$ docker exec -i -t &#123;container 이름&#125; /bin/bash 4. Container 시작1$ docker container start &#123;Container ID 또는 NAMES&#125; 5. Container 종료1$ docker container stop &#123;Container ID 또는 NAMES&#125; 6. Container 재 시작1$ docker container restart &#123;Container ID 또는 NAMES&#125; 7. Container 접속1$ docker attach &#123;Container ID 또는 NAMES&#125; Container 빠져 나오기 exit container 접속 후 exit로 빠져 나오면 Container를 stop 시키고 빠져 나온다. container STATUS 정보가 Exitd (0) 이다. Ctrl + p, q container 접속 후 exit로 빠져 나오면 Container를 up 시킨 상태로 빠져 나온다. container STATUS 정보가 Up 이다. 9. Container 삭제1$ docker container rm &#123;Container ID&#125; 참조 https://doitnow-man.tistory.com/182?category=768603","categories":[{"name":"Server","slug":"Server","permalink":"https://woonyzzang.github.com/categories/Server/"},{"name":"Docker","slug":"Server/Docker","permalink":"https://woonyzzang.github.com/categories/Server/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://woonyzzang.github.com/tags/docker/"}]},{"title":"Docker Image 만들기 / 삭제 (Linux)","slug":"docker-image","date":"2019-08-09T04:12:19.000Z","updated":"2024-06-07T09:27:28.297Z","comments":true,"path":"2019/08/09/docker-image/","permalink":"https://woonyzzang.github.com/2019/08/09/docker-image/","excerpt":"","text":"Docker에서 Image란?1. 정의 Docker에서 Image란 컴퓨터의 CD와 같다고 볼 수 있습니다. 그래서 Docker의 Image는 수정 할 수 없습니다. 단, image에 추가로 무언가를 추가는 할 수 있습니다. 2. 구조 Docker의 Image지는 layer 구조로 되어 있습니다. 즉, 기본이 되는 image가 존재하고, 그 image에 계속해서 추가하는 방식으로 image를 생성 합니다. 아래는 image의 layer 구조를 설명 그림으로 그린 것입니다. 1$ docker inspect &#123;image 이름&#125; Container 이용한 Image 생성1. 핵심 실행 중인 container 수정 후, 수정된 container를 새로운 image로 만듭니다. 2. image 생성 형식123$ docker commit [OPTIONS] container [REPOSITORY[:TAG]]$ docker commit -a &quot;doitnowman&quot; -m &quot;modification&quot; webhttpd webhttpd:v1 // ex commit을 한번 할 때 마다 image에 layer가 추가 됩니다. 3. 수정된 image 생성 과정1) container 구동 1$ docker run -d -p 1443:80 --name=webhttpd httpd p : 외부로 공개 할 포트와 container의 Port를 binding 합니다[외부 공개용 host port]:[container port] d : detach 옵션 , container를 background로 실행 합니다.단, detach 모드로 container 실행시 container내부에는 무언가 항상 돌아 가고 있어야 합니다.그렇지 않으면 생성 후 바로 종료 됩니다. 2) 새로운 image 생성 1$ docker commit -a &quot;doitnowman&quot; -m &quot;modification&quot; webhttpd webhttpd:v1 3) 새로운 image로 container 구동 1$ docker run -d -p 3836:80 --name=webhttpdv1 webhttpd:v1 4. 수정된 image 생성 시 base image는 복사 하여 다시 생성되는가? 그렇지 않습니다,docker는 base image기반으로 수정된 image를 생성 시 수정된 부분만 관리 합니다.그렇기 때문에 수정된 image가 생성 되어도, 용량은 “image + 수정 된 부분” 만큼만 늘어 납니다. 즉 docker는 image생성시 변화되는 부분만을 관리 합니다. 5. 생성한 image를 파일로 만드는 방법 외부로 image 파일을 보내고 싶을때 사용 합니다. 1) docker 내부의 image를 외부 파일 image로 생성 방법 이미지를 묶은 파일로 생성 할 뿐 압축은 하지 않습니다. 별로도 압축 필요 1$ docker save -o &#123;image 파일 이름&#125;.tar &#123;image 명&#125; 2) 파일 image를 docker로 load하는 방법 상기 1)에서 만든 파일을 docker 내부로 load 합니다. 1docker load -i &#123;image 파일 이름&#125;.tar Dockerfile 을 이용한 image 생성1. Dockerfile 이란? image 파일을 만들기 위한 일련의 과정을 기술해 놓은 파일 입니다. Container를 통해서 할 수 있지만 image에 Commit하고 하는 과정이 번거로워 Dockerfile을 사용 합니다. Dockerfile사용시 이미지 파일 생성을 자동화 할 수 있고 이미지 관리를 할 수 있습니다. 2. Dockerfile 작성 방법 Web Server Docker Maker file Sample 123456789FROM centosMAINTAINER doitnowmanLABEL &quot;purpose&quot;=&quot;webdev&quot;RUN yum -y install httpdADD index.html /var/www/htmlWORKDIR /var/www/htmlRUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hi doitnowman &gt;&gt; index.html&quot;]EXPOSE 8888CMD apachectl -DFOREGROUND 3. Dockerfile 명령어 설명1) FROM 기본 base가 되는 image를 선정 합니다 2) MAINTAINER image 생성자 정보 3) LABEL image에 추가할 metadata metadata 부가적인 설명을 의미합니다. 4) RUN container 내부에서 실행 할 명령어 사용법 2가지(1) 한줄 명렁어로 사용 RUN yum -y install httpd(2) 배열 형태로 사용 배열 형태로 사용시 기본적으로 shell이 실행 되지 않기 떄문에 첫 인자로 shell을 지정해야 합니다. RUN [“실행 가능한 파일”, “명령줄 인자 1”, “명령줄 인자 2”, … ]Ex) RUN [“&#x2F;bin&#x2F;bash”, “-c”, “echo hello &gt;&gt; index.html”] 5) ADD container에 파일 추가 명령어 추가할 파일은 Dockerfile이 존재하는 경로의 파일을 사용 합니다. 6) WORKDIR container 내부에서 디렉토리 경로 변경 7) EXPOSE 외부에 공개할 포트 번호 docker run 의 -p 옵션 입니다. 8) CMD container가 실행 될때만다 실행 할 명령어 , 딱 한번 사용가능합니다. docker의 run 명령어의 image이름 뒤에 입력하는 command와 같은 열활을 합니다. 명령어 우선 순위docker의 run 명령어의 image이름 뒤에 입력하는 command 가 Dockerfile의 CMD 보다 높습니다. 9) ENTRYPOINT CMD와 거의 같으나 Container생서(run)이나 시작(start)될 때 실행 docker run 실행 시 실행되는 명령이라고 생각해도 좋을 것 같다.ENTRYPOINT[“.&#x2F;sample.sh”] 10) ENV 일반적으로 Linux에서는 로그인시 ~&#x2F;.bashrc 나 ~&#x2F;.profile을 실행하여 환경 변수를 자동으로 설정 합니다.그러나 Docker에서는 환경 변수를 자동으로 설정 하지 않습니다.그래서 필요시 ENV로 환경 변수를 지정해 줘야 합니다. docker run으로 실행 시 –env 옵션을 사용합니다. 11) USER 사용자 변경 test로 변경하는 예제USER tester 12) VOLUME 특정 디렉토리를 container 내부 디렉토리가 아닌 host의 물리 디렉토리에 맵핑 시킵니다. docker run 의 -v {host direcotry}:{container directory}옵션과 같습니다Ex)단일 디렉토리 맵핑 : VOLUME &#x2F;data다수 디렉토리 맵핑 : VOLUME [“&#x2F;data”, “&#x2F;var&#x2F;log&#x2F;hello”] 단, VOLUME으로는 호스트의 특정 디렉터리와 연결할 수는 없습니다.데이터 볼륨을 호스트의 특정 디렉터리와 연결하려면 docker run 명령에서 -v 옵션을 사용해야 합니다. 1$ docker run -v /root/data:/data example 그외의 명령어 https://docs.docker.com/engine/reference/builder/ 4. Dockerfile을 이용한 image build123$ docker build -t &#123;image 이름:tag 명&#125; ./$ docker build -t myweb:01 ./ // ex t 옵션 : image명을 지정 합니다. 마지막 .&#x2F; 이 사용된 이유는 Dockerfile을 현재 경로에서 찾겠다는 의미 입니다.추후에 URL을 통해서 받는 방법도 알아 보곘습니다. 5. Dockerfile을 이용한 image build 원리. Dockerfile은 base image를 이용하여 그위에 명령어 하나를 실행 한 후 image에 commit을 하여 image를 만들어 나갑니다. 그래서 각 명령어는 하나의 Step을 의미하면 Step은 하나의 commit이 됩니다.해당 작업 내용은 docker history {image명}에서 확인 가능합니다. 참고 (inspect로 확인시) docker inspect {image명} 의 맨 마지막 layer으로 보면 몇줄만 추가 된 것을 볼 수 있습니다. 이는 layer에서는 image에 변경된 사항만 추가하기 때문입니다. base image는 centos 입니다. 1$ docker inspect centos Docker에서 Image 삭제1. 삭제1$ docker rmi &#123;image 이름&#125; f: 강제로 image 삭제 1) 유의 사항 image를 사용 중인 container가 존재 할 때는 삭제 할 수 없다는 에러가 뜹니다.그러나 -f 옵을 주어 강제 삭제 시, image 명이 으로 변경 됩니다.이러한 image를 dangling image라고 합니다. 2) 수정된 image를 삭제 할때 base image도 삭제 될까? base image를 수정하여 만든 image를 삭제 시 base image는 지워지지 않고 수정된 부분만 삭제 합니다. 2. 사용 중이지 않는 dangling image 삭제1$ docker image prune 참조 https://doitnow-man.tistory.com/184","categories":[{"name":"Server","slug":"Server","permalink":"https://woonyzzang.github.com/categories/Server/"},{"name":"Docker","slug":"Server/Docker","permalink":"https://woonyzzang.github.com/categories/Server/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://woonyzzang.github.com/tags/docker/"}]},{"title":"Docker의 설치 방법 (Linux)","slug":"docker-install","date":"2019-08-09T04:10:33.000Z","updated":"2024-06-05T05:24:16.902Z","comments":true,"path":"2019/08/09/docker-install/","permalink":"https://woonyzzang.github.com/2019/08/09/docker-install/","excerpt":"","text":"1. Docker를 사용 환경 (CentOS 7 환경)(1) Linux 커널 버전 3.10 이상 및 64 bit에서 최정화 및 구동이 됩니다. 확인 방법1$ #uname -a (2) 설치 및 실행을 위해서는 root로 작업을 해야 합니다. 2. Docker에도 제품 군이 존재한다? Docker-CE(Community Edition) - (무료) Docker를 시작하고 컨테이너 기반 앱을 실험하려는 개발자 및 소규모 팀에 이상적 (무료) 두 가지 업데이트 채널 Stable : 분기마다 안정적인 업데이트 버전 Edge : 매월 새 기능 제공, 테스트가 아직 부족한 버전 Docker-EE(Enterprise Edition) (유료) 업무용 응용 프로그램 제작, 배송 및 실행하는 엔터프라이즈 개발 및 IT팀을 위한 설계 (유료) https://docs.docker.com/install/overview/ https://docs.docker.com/docker-for-mac/faqs/ 3. yum을 이용한 설치사전 확인 작업 docker가 설치된 host에 ipv4 forwarding기능이 설정되어야 합니다. 확인 방법1$ /sbin/sysctl net.ipv4.conf.all.forwarding 설정 방법1$ /sbin/sysctl -w net.ipv4.conf.all.forwarding=1 이렇게 했는데도 안되면 docker 데몬을 재시작 합니다. 1$ systemctl restart docker Docker 설치 1234567891011$ yum install -y yum-utils // yum 패키지매니저 관련 유틸리티 모음 설치$ yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo // yum 저장소 리스트에 docker 저장소 추가$ yum install -y docker-ce // 무료버전 docker 설치$ systemctl start docker // docker 시작$ systemctl enable docker.service // 부팅(Boot) 시에 실행 하도록 (systemctl)에 등록$ systemctl start docker.service // Docker 실행$ systemctl status docker.service // systemctl 사용 Docker 스테이터스 확인 Docker image 구하기 - 리눅스(CentOS 7)1. Docker image 검색하기 다음 2가지 방법으로 구할 수 있습니다. 웹에서 이미지 찾기 https://hub.docker.com/ 여기서 다운로할 image를 확인한다. docker search 커맨드 명령어로 이미지 찾기 1docker search &#123;이미지&#125; 2. Docker image 다운받기1docker pull &#123;이미지&#125; 3. Docker image 목록확인1docker images 4. Docker image 삭제1docker rmi &#123;id&#125; 5. Docker 컨테이너 생성 및 실행1$ docker run -dit --name &#123;name&#125; -p 80:80 &#123;image or id&#125; -v /sys/fs/cgroup:/sys/fs/cgroup:ro 6. Docker 컨테이너 접근123$ docker exec -it &#123;name or id&#125; bash // 컨테이너 내부 접속$ exit // 컨테이너 나오기 7. Docker 컨테이너 삭제1$ docker rm &#123;name&#125; 8. 구동중인 리스트 확인123$ docker ps$ docker ps -a 9. Docker 컨테이너 시작 및 중지12345$ docker start &#123;name&#125; // 시작 $ docker stop &#123;name&#125; // 중지$ docker restart &#123;name&#125; // 재시작 참조 https://docs.docker.com/install/linux/docker-ce/centos/ https://doitnow-man.tistory.com/181","categories":[{"name":"Server","slug":"Server","permalink":"https://woonyzzang.github.com/categories/Server/"},{"name":"Docker","slug":"Server/Docker","permalink":"https://woonyzzang.github.com/categories/Server/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://woonyzzang.github.com/tags/docker/"}]},{"title":"Docker 가상화 서버 개념","slug":"docker","date":"2019-08-09T04:05:40.000Z","updated":"2025-03-29T05:00:29.561Z","comments":true,"path":"2019/08/09/docker/","permalink":"https://woonyzzang.github.com/2019/08/09/docker/","excerpt":"","text":"1. Docker 란? vmware와 유사한 가상화 시스템이다. OS 레벨의 가상화 이다. OS에서 가상화를 관리 하기 떄문이다. 도커는 리눅스에서만 사용 가능한 가상화 컨테이너이다. 윈도우에서 사용하기 위한 방법(구글에 검색하면 많이 나와있습니다. 윈도우 10 Pro를 사용 할시 윈도우에서 제공하는 hyper-v 를 사용하여 Docker만 설치하면 사용 가능 윈도우 10 home 이하에서는 Docker에서 제공하는 Docker Toolbox(Legacy desktop solution) 를 사용 2. Docker 지원하는 가상화 방식? Host OS에 “격리된 가상화 공간”을 만드는 방법으로 가상화를 지원한다. “격리된 가상화 공간”에는 Guest OS가 필요가 없다. “격리된 가상화 공간”은 리눅스 자체 기술인 cgroup(control groups), namespace를 사용하여 만듭니다. “격리된 가상화 공간”은 독립된 파일시스템을 제공 받는다. 3. Docker 의 장점1) Docker 빠르다 Docker가 빠른 이유는 “격리된 가상화 공간”에서 동작하는 프로세스들은 Host OS의 커널 및 System call을 공유하여 사용하기 때문이다.즉, 실제 OS를 공유하여 사용하기 때문에 빠르다. 2) Docker는 가볍다. Docker는 “격리된 가상화 공간”에서 사용할 “실행 파일”과 “library”를 묶어 놓은 이미지만 있으면 바로 “격리된 가상화 공간”를 만들 수 있기 때문이다. 4. Docker 의 핵심 용어- 이미지와 컨테이너 이미지 (실행파일 + library + 설정 값) 을 묶어 놓은 실행 가능한 해키지 이다. 읽기만 가능 하다. iso 파일과 같다고 볼수 있다. 컨테이너 이미지가 실행된 “격리된 가상화 공간”이다. 이미지의 변경 사항을 저장 할 수 있다. 컨테이너는 각기 독립 적으로 동작한다. 단, Host OS의 커널은 공유한다. 5. Docker 의 철학 한 컨테이너에 프로세스 하나만 실행하는 것이다. 6. Docker 의 전체 구조 https://docs.docker.com/engine/docker-overview/ 참조 Docker 시스템으 크게 내부(리눅스 Server에 설치된 Docker)와 외부(Docker Hub)의 구조 입니다. Docker 자체는 Client &#x2F; Server 되어있습니다. 1) client [내부] 사용자와 상호작용을 하는 프로그램 docker damond 에 명령을 보낸다. 2) docker host - Docker Dameon [내부] Docker API Request를 수신 대기 한다. image, container, networks, volumns 등을 관리 한다. docker 서비를 관리 하기 위해서 다른 데몬과 통신을 수행한다. 3) registry [외부] docker에서 사용 할 수 있는 공용 image를 보관 한다. client에서 pull(다운로드), push(업로드)를 사용 할시 registry에 pull 및 push 를 한다. Docker 엔진 동작 방식 파악 하기1. Docker와 기존 가상화와 비교 “일반 적인 가상화”는 Guest OS가 필수로 필요 Docker는 Host OS를 공유하여 사용하기 때문에 Guest OS가 불 필요 2. Docker engine 내부 구조 1) Docker에서 Container 관리를 위해서 사용 하는 주요 기술(1) libcontainer Docker Version 0.9 이후 부터 기본으로 지원 OS에서 독립 적이기 위해서 Docker에서 제공하는 Driver 입니다. Linux 플랫폼에 의존적인 LXC(LinuX Contianer)를 대체 하기위 Docker에서만든 컨테이너 관리 기술 입니다. docker에서 container list를 봤을 때 native면 libcontainer를 사용하는 container이고 lxc 리면 LXC를 사용하면 container 입니다. 기본적으로사용 Docker에서 사용 합니다. Host OS의 의존성을 제거하고 다양한 플랫 폼 지원(Red Hat, Microsoft Window, Etc ..) (2) Cgroup OS가 관리하는 다양한 리소스를 중앙에서 제어하기 위한 도구입니다 cgroups에서 관리하는 대상은 파일 시스템이나 프로세스뿐만 아니라 CPU 리소스와 메모리, 각종 디바이스, 네트워크 패킷, 네트워크 인터페이스 등 입니다. (3) namespace namespace 란, 시스템 리소스를 프로세스의 전용 자원처럼 보이게 하고, 다른 프로세스와 격리시키는 기능입니다. namespace 에는 총 6가지 namespace 가 있습니다. 종류 설명 Mount namespacaes 파일시스템의 Mount 를 분할하고 격리합니다. PID namespacaes 프로세스를 분할 관리합니다. Network namespacaes Network 관련된 정보를 분할 관리합니다. IPC namespacaes 프로세스간 통신을 격리합니다. UTS namespacaes 독립적인 hostname 할당합니다. USER namespacaes 독립적인 UID를 할당합니다. 3. Docker는 어떻게 컨테이너를 관리 할까?? 정답은 리눅스에서 제공하는 Cgroup을 이용해서 시스템 자원을 제한 하고 namespace 를 이용하여 각 프로세스를 격리하여 프로세스별로 각각의 가상머신을 운영하는 것과 같은 격리 효과를 주어 가상황를 구현 합니다. 4. Docker는 어떻게 Host OS를 공유 할 수 있는가? docker는 cgroup과 namespace를 이용하여 프로세스를 격리 시키는 것 뿐이기 때문에 격리된 모든 프로세는 Host OS에서 동작 합니다. 5. Docker는 어떻게 다른 OS를 컨테이너에 올릴 수 있는 것인가?? Docker는 리눅스에서만 실행 가능하다고 하였습니다. 그런데 어떻게 다른 OS를 올리수 있는 것일까요??그 답은, libcontainer 를 사용하여 Docker의 단점인 Host OS 종속성을 제거 하였기 때문에 가능 합니다. 참조 https://www.docker.com/why-docker https://doitnow-man.tistory.com/180","categories":[{"name":"Server","slug":"Server","permalink":"https://woonyzzang.github.com/categories/Server/"},{"name":"Docker","slug":"Server/Docker","permalink":"https://woonyzzang.github.com/categories/Server/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://woonyzzang.github.com/tags/docker/"}]},{"title":"Windows VisualSVN Commit 자동 deploy 연동","slug":"windows-visualsvn-webserver-deploy","date":"2019-08-09T02:20:17.000Z","updated":"2024-06-05T07:07:47.789Z","comments":true,"path":"2019/08/09/windows-visualsvn-webserver-deploy/","permalink":"https://woonyzzang.github.com/2019/08/09/windows-visualsvn-webserver-deploy/","excerpt":"","text":"SVN commit 하면 로컬 웹서버 경로 update 해주는 설정법SVN 저장소는 고유의 형태로 SVN서버에 저장되고 Update 받지 않으면 웹서버의 소스 디렉토리는 갱신되지 않는다. VisualSVN 안에 post-commit hook 기능을 활용해서 자동으로 웹 서버에도 반영 되도록 하는 방법을 살펴 보겠다. 1. VisualSVN Server을 실행 2. VisualSVN 관리자에서 Repository(저장소)를 생성 3. 자동업데이트를 위한 계정 생성(webUpdater svn 사용자 계정 add) 4. 저장소에서 마우스오른쪽을 누른 뒤 위 스샷과 같이 Manage Security 선택 5. (2)에서 만들었던 자동업데이트 계정을 Add 하고 Read&#x2F;Write 권한 부여 6. 탐색기(Win+E)에서 웹서버 경로를 SVN 저장소 Checkout 경로로 설정 후 보안 설정.(이미 웹서버 경로이면서 동시에 SVN workout 경로이면 보안 설정만 하면 된다.)웹 서버 루트에 레파지토리의 저장소를 체크아웃을 받음 ex) 1svn checkout http://localhost:8443/svn/test/ C:\\inetpub\\wwwroot\\test 7. 위 스샷에서 보여지는것과 같이 Network Service 에 수정 권한 부여(VisualSVN 사용 계정 &#x3D; Network Service)웹 루트 디렉토리에 아래 보안 설정 NETWORK SERVICE 추가공유 및 보안 &gt; 보안 &gt; 수정 &gt; 추가 &gt; 고급 &gt; 지금 찾기 &gt; NETWORK SERVICE 선택 추가수정 권한 필시 체크 8. VisualSVN 관리자로 돌아가서 저장소 마우스 오른쪽 후 Manage Hooks 선택 9. 이후 뜨는 창에서 Post-commit hook 더블클릭 또는 아래 Edit 버튼 클릭 10. 아래와 같이 .bat 커맨드 입력SVN과 웹 동일 서버 상에서 Repositery경로&#x2F;hooks&#x2F;post-commit.cmd 를 텍스트 편집기로 아래와 같이 수정 후 저장. 1234567@echo offSET WORKING_COPY=&quot;C:\\inetpub\\wwwroot\\test&quot;&quot;VisualSVN Server 경로\\bin\\svn.exe&quot; update %WORKING_COPY% --username webUpdater --password 암호 --non-interactive --trust-server-certREM --trust-server-cert 옵션은 https 인증 오류시 붙임. 인증서 설치된 서버는 생략. WORKING_COPY 경로는 (개발) 웹사이트 루트인데 저 경로에서 최초 SVN import 후 checkout 해 놓은 후 위 post-commit hook 내용과같이 svn update 하면 클라이언트에서 svn commit 을 수행하면 svn repositery 에 전달되고 수정본이 WORKING_COPY 경로에 반영되어 수정된 웹페이지를 곧바로 볼 수 있다. (FTP 접속하여 수정한 파일을 덮어쓴 효과) 11. OK 버튼 누르면 완료 만약 commit 후 cleanup 하라는 오류 뜨면 (10)에서 update 커맨드 위에 1&quot;VisualSVN Server 경로\\bin\\svn.exe&quot; cleanup %WORKING_COPY% --username webUpdater --password 암호 --non-interactive --trust-server-cert 참조 https://itzone.tistory.com/248 https://rosagigantea.tistory.com/m/391 https://sacstory.tistory.com/entry/SVN-활용","categories":[{"name":"OS","slug":"OS","permalink":"https://woonyzzang.github.com/categories/OS/"},{"name":"Windows","slug":"OS/Windows","permalink":"https://woonyzzang.github.com/categories/OS/Windows/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://woonyzzang.github.com/tags/windows/"},{"name":"visualsvn","slug":"visualsvn","permalink":"https://woonyzzang.github.com/tags/visualsvn/"}]},{"title":"AWS 아마존 웹 서비스 EC2 윈도우 서버 환경 구축","slug":"aws-ec2-windows","date":"2019-08-09T00:25:08.000Z","updated":"2024-06-05T04:32:55.968Z","comments":true,"path":"2019/08/09/aws-ec2-windows/","permalink":"https://woonyzzang.github.com/2019/08/09/aws-ec2-windows/","excerpt":"","text":"아마존 EC2 기반으로 윈도우 서버 환경 구축아마존 EC2란?아마존 EC2는 클라우드 기반으로 서버 인프라를 제공한다. 웹 페이지를 이용해 필요한 플랫폼과 용량을 선택해 서버 인스턴스를 실행하고 접속해 테스트 및 서비스를 할 수 있다.-[아마존 EC2 자세히보기] 아마존 EC2를 사용하는 이유AWS 프리 티어를 이용해 12개월 동안 무료로 체험을 할 수 있다.-[AWS 프리 티어 자세히보기] 이 글에서 다루는 내용은 아래와 같다. Windows 2012 R2 인스턴스 생성 보안설정(서버에서 사용하는 포트번호 오픈) 원격 데스크탑으로 연결 준비AWS 가입(게정생성)EC2를 사용하기 위해서는 AWS 계정이 필요하다.가입 절차는 아래 링크를 참조해서 가입하면 된다.(참고로 가입 시 마스터 또는 비자 카드가 필요합니다.) 인스턴스 생성윈도우즈 서버 인스턴스를 추가하는 과정을 설명한다. 아마존 웹서비스 로그인 아마존 웹서비스(https://aws.amazon.com/ko/)에 접속 내 계정 &gt; AWS Management Console 메뉴 선택 후 로그인 EC2 서비스 선택 필터에 ec2 입력 후 선택 인스턴스 목록 표시 왼쪽 메뉴 중 Instances 항목 선택 가까운 지역 선택 상단 우측의 지역을 누르고, 가까운 지역 선택(Asia Pacific(Seoul)을 선택) 새로운 인스턴스 추가 [Launch Instance] 버튼 클릭 인스턴스 이미지 선택-적합한 항목의 [Select] 버튼 클릭(“Microsoft Windows Server 2012 Base”(64 - bit)를 선택) 인스턴스 유형 선택 적합한 인스턴스 유형 선택 [Review and Launch] 버튼 클릭 내용 확인 내용 확인 후 [Launch] 버튼 클릭 주의 문구는 무시합니다. (보안설정은 뒤에서 다시 진행) Key Pair 생성 및 다운로드중요: 인스턴스(서버) 접속 시 비밀번호 인증에 사용할 키파일을 로컬 저장소에 저장한다. (해당 파일을 분실하지 않도록 주의) Create a new key pair 항목 선택 Key pair name 입력 [Download key Pair] 버튼 클릭 해 다운로드 보안설정애플리케이션 서버에서 사용할 포트번호를 Inbound 규칙에 추가하는 절차를 설명한다. 인스턴스의 Security Group 확인 인스턴스 목록 항목 중 가장 오른쪽 항목에서 Security Group을 확인한다. (여기서는 launch-wizard-1 이다.) Security Groups 메뉴 선택 왼쪽 메뉴에서 Network &amp; Security &gt; Security Groups 메뉴 클릭 Security Group 선택 인스턴스에 설정된 Security Group을 선택한다. (여기서는 launch-wizard-1을 선택) Inbound 탭에서 Inbound 규칙 수정 아래 탭 중 Inbound 탭 선택 [Edit] 버튼 클릭 Inbound 규칙 편집 [Add Rule] 버튼 클릭 필요한 규칙을 추가합니다. 데이터스냅 TCP&#x2F;IP의 경우 “Custom TCP Rule &#x2F; TCP &#x2F; 211” 규칙 추가 EMS 서버, 데이터스냅 HTTP, WebBroker의 경우 “Custom TCP Rule &#x2F; TCP &#x2F; 8080” 규칙 추가 기타 서버에서 사용하는 포트번호를 추가한다. 원격 데스크탑 연결윈도우즈 서버 인스턴스에 원격 데스크탑 연결하는 절차를 설명한다. 인스턴스 선택 후 연결 인스턴스 목록에서 인스턴스 선택 [Connect] 버튼 클릭 Connect To Your Instnace 팝업창 표시 비밀번호 가져오기 [Get Password] 버튼 클릭 Key pair 파일 선택 인스턴스 생성 시 다운로드 받은 Key Pair 파일을 로컬 저장소에서 선택 [Decrypt Password] 버튼 클릭 접속 정보 확인 화면에 표시된 접속 정보 확인 원격 데스크톱 연결 원격 데스크톱 연결 실행 컴퓨터 항목에 Public DNS 항목 입력(복사 &gt; 붙여넣기) 사용자 자격 증명 입력 User name, Password 입력 [확인] 버튼 클릭 서버 접속 확인 윈도우즈 방화벽 규칙 추가 애플리케이션 에서 사용하는 포트번호를 윈도우즈 방화벽 규칙을 추가한다. [참고링크] 윈도우즈 2012 R2 방화벽 규칙 추가 https://technet.microsoft.com/ko-kr/library/cc753558(v=ws.11).aspx https://wiki.mcneel.com/ko/zoo/window7firewall 참조 http://tech.devgear.co.kr/delphi_news/432246","categories":[{"name":"Server","slug":"Server","permalink":"https://woonyzzang.github.com/categories/Server/"},{"name":"AWS","slug":"Server/AWS","permalink":"https://woonyzzang.github.com/categories/Server/AWS/"}],"tags":[{"name":"aws","slug":"aws","permalink":"https://woonyzzang.github.com/tags/aws/"}]},{"title":"ASP IIS Server Side Include","slug":"asp-iis-ssi","date":"2019-03-04T11:19:19.000Z","updated":"2024-06-07T09:27:28.261Z","comments":true,"path":"2019/03/04/asp-iis-ssi/","permalink":"https://woonyzzang.github.com/2019/03/04/asp-iis-ssi/","excerpt":"","text":"IIS7 에서 SSI(server side include) 사용하기SSI란? Server Side Include의 약어로, 웹서버에서 직접 제공하는 서버사이드 스크립트 언어다. IIS 7 기본 셋팅에서는 include 를 해도 인클루드 기능이 적용이 되지 않는다. 1&lt;!--#include file=&quot;/inc/xxx.xxx&quot;--&gt; IIS7 에서 SSI를 적용하려면 다음과 같다. IIS 역할 서비스 추가 &gt; 응용 프로그램 개발 &gt; SSI(Server Side Include)의 기능을 설치해야 한다. 설치가 완료되면 IIS 관리자 &gt; Handler Mappings 메뉴를 선택한다. 우측 Actions 패널의 Add Module Mapping... 메뉴를 선택한다. IIS 처리기 맵핑에 해당 모듈을 추가한다.1234요청경로: *.html모듈: ServerSideIncludeModule실행파일: 빈값이름: inc_html (임의의 값..) 참조 http://www.uhoon.co.kr/nt/966","categories":[{"name":"Server","slug":"Server","permalink":"https://woonyzzang.github.com/categories/Server/"},{"name":"IIS","slug":"Server/IIS","permalink":"https://woonyzzang.github.com/categories/Server/IIS/"}],"tags":[{"name":"server","slug":"server","permalink":"https://woonyzzang.github.com/tags/server/"},{"name":"asp","slug":"asp","permalink":"https://woonyzzang.github.com/tags/asp/"}]},{"title":"Mac 시스템 설정","slug":"mac-system-setting","date":"2018-11-26T11:14:37.000Z","updated":"2024-06-07T09:27:28.343Z","comments":true,"path":"2018/11/26/mac-system-setting/","permalink":"https://woonyzzang.github.com/2018/11/26/mac-system-setting/","excerpt":"","text":"macOS 유용한 시스템 설정macOS 환경에서 몇 가지 유용한 시스템 설정을 알아보자.macOS High Sierra를 기준으로 하였으나 다른 버전들도 크게 별 다른 부분 없이 비슷하다. 반드시 동일하게 설정할 필요는 없으며 원하는 항목만 적용하면 된다. 키보드 기호 설명 단축키 입력과 관련해서 기호를 사용한다. 기호 설명 ⌘ Command ⌥ Option ⌃ Control ⇧ Shift + 동시 입력 , 키를 떼고 다시 입력 예) ⌃ + b, c 는 control키를 누른 상태에서 b를 누르고 control키와 b에서 모두 손을 뗀 다음에 c를 입력하라는 의미이다. System Preferences상단 메뉴의 apple 로고를 누르고 System Preferences…를 선택한다. [미션 컨트롤 창 순서 고정] Mission Control &gt; Automatically rearrange Spaces based on most recent use: 체크 안함 미션 컨트롤 창 순서가 기본적으로 최근 사용 순으로 설정되어 있어 의도하지 않게 순서가 변경되는 것을 막는다. [언어 설정 영어 우선순위로 변경] Language &amp; Region &gt; Preferred languages: English &gt; 한국어 (드래그로 순서 조정) 간혹 locale 설정 때문에 오류가 발생하는 걸 방지해주고 영어 오류 메시지가 구글검색이 잘된다. [패스워드 즉시 설정] Security &amp; Privacy &gt; General &gt; Require password: immediately 잠자기 모드나 화면 보호기가 켜지면 즉시 패스워드 입력을 활성화하여 보안을 최대한 안전하게 유지한다. [분실대비 패스워드 메시지 설정] Security &amp; Privacy &gt; General &gt; Show a message when the screen is locked: 전화번호 &#x2F; 이름 혹시 분실했을 경우를 대비하여 전화번호, 이름 등을 알려준다. [디스크 암호화] Security &amp; Privacy &gt; FileVault: Turn On FileVault 분실 시 복구 불가능하게 디스크를 암호화 파일 읽기&#x2F;쓰기 퍼포먼스가 걱정되지만 최신 CPU와 SSD에서는 거의 성능 차이가 없다고 한다. [모든 텍스트 자동 변경 옵션 끄기] Keyboard &gt; Text: 모든 자동 변경 옵션 끄기 입력한 단어를 컴퓨터 마음대로 바꾸는 걸 방지 특히 Use smart quotes and dashes는 코드를 복사하면 따옴표가 자동으로 변경되어 불편할 수 있다. [트랙패드 클릭을 터치로 변경] Trackpad &gt; Point &amp; Click &gt; Tab to click: 체크함 트랙패드 클릭 시 패드를 누를 필요 없이 터치만으로 클릭이 가능하다. [트랙패드 드래그는 세손가락으로 변경] Accessibility &gt; Mouse &amp; Trackpad &gt; Trackpad options...: Enable dragging - three finger drag 창 또는 아이콘을 이동할 때 트랙패드를 누른 상태로 이동할 필요 없이 세 손가락으로 드래그 할 수 있다. Finder PreferenceFinder를 실행하고 ⌘ + , (Finder &gt; Preferences...)를 선택한다. [파인더 기본 폴더 설정] General &gt; New Finder windows show: subicura (home folder) 파인더 최초 실행 시 버벅임이 없도록 기본 폴더를 홈 폴더로 설정 [파일 확장자 보여주기] Advanced &gt; Show all filename extensions: 체크함 모든 파일의 확장자를 보여준다. Download Folder OptionDownloads 폴더로 이동하고 ⌘ + J (View &gt; Show View Options)를 선택한다. 날짜그룹 + 이름 정렬 Arrange By:Date added, Sort By:Name 파일 목록을 보여줄 때 날짜별로 그룹화 하고 그룹 내에서 이름으로 다시 정렬 다운로드 폴더 특성상 최근에 받은 파일들을 찾는 경우가 많으므로 유용하다. 참조 https://subicura.com/2017/11/22/mac-os-development-environment-setup.html","categories":[{"name":"OS","slug":"OS","permalink":"https://woonyzzang.github.com/categories/OS/"},{"name":"Mac","slug":"OS/Mac","permalink":"https://woonyzzang.github.com/categories/OS/Mac/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://woonyzzang.github.com/tags/mac/"}]},{"title":"CSS3 Skeleton Screen","slug":"css3-skeleton-screen","date":"2018-11-23T15:14:12.000Z","updated":"2024-06-07T09:27:28.279Z","comments":true,"path":"2018/11/24/css3-skeleton-screen/","permalink":"https://woonyzzang.github.com/2018/11/24/css3-skeleton-screen/","excerpt":"","text":"linear-gradient로 skeleton screen 만들어보기페이스북이나 유튜브의 첫 화면을 보면, 아주 잠깐 프레임을 그려주는 빈 페이지를 확인할 수 있다.이러한 페이지를 개발에서 skeleton screen(스켈레톤 스크린) 이라고 한다.참고로 skeleton은 뼈대를 의미의 단어를 뜻한다. skeleton screen을 적용하면 사용자가 “대기중”이라는 느낌을 전달하면서 빠르게 로드되고 있다고 인식하게 합니다. 그럼 이러한 UI는 어떤 방법으로 구현할 수 있을까?CSS의 linear-gradient 속성과 :empty 선택자를 활용하여 이를 구현해 보도록 하겠다. 1. linear-gradient 원리 linear-gradient의 기본 문법은 아래와 같다. 12linear-gradient(angle, color-stop1, color-stop2); /* 선형 */radial-gradient(shape size at position, start-color, ..., last-color); /* 원형 */ 선형을 적용해보면, 방향과 적용 컬러를 순서대로 선언하게 된다. 방향 to bottom은 기본 값으로 생략이 가능하다. 1linear-gradient(to bottom, yellow 20%, steelblue 50%) 보통은 부드럽게 컬러가 변할 때 많이 쓰는 속성이지만, 경계면이 매끄럽게 떨어지도록 만드는 방법도 있다.첫 번째와 두 번째 위치값이 동일할 경우, 경계선이 만나면서 그라데이션 영역이 사라지므로 아래와 같이 단색 면이 된다. 1linear-gradient(yellow 50%, steelblue 50%) 또한 두 번째 값이 첫 번째의 값보다 클 때(더 위쪽에 위치할 때) 도 브라우저는 동일하게 동작하는데,두 번째 위치를 0으로 잡았다면 그 위치는 브라우저에 의해 이전 색상 정지의 위치와 같게 그 위치가 조정된다. 1linear-gradient(yellow 50%, steelblue 0) = linear-gradient(yellow 50%, steelblue 50%) 두 번째 값이 투명할 경우에는? 첫 번째 색으로만 표현된다. 1linear-gradient(yellow 50%, transparent 0) 이러한 속성을 활용하면 하나의 div에 background-image로 도형을 드로잉해 볼 수 있다. 2. linear-gradient를 활용한 도형 드로잉 background-image 속성은 &lt;image&gt; &lt;position&gt; &lt;size&gt;의 값을 주어서 컨트롤할 수 있다. 1) background-image : 멀티 배경 지정 background-image 속성은 여러 배경 이미지를 추가할 수 있다 .서로 다른 배경 이미지는 쉼표로 구분되며 이미지는 서로 위에 겹쳐서 표시된다.원형 1개, 사각형 4개를 그리기 위해서 5번 선언해 주었고, y축으로 반복할 수 있게 repeat-y를 주었다. 12345678background-image: radial-gradient( circle 50px at 50px 50px, gray 99%, transparent 0 ), /* 원형 */ linear-gradient( lightgray 20px, transparent 0 ), /* 사각1 */ linear-gradient( lightgray 20px, transparent 0 ), /* 사각2 */ linear-gradient( lightgray 20px, transparent 0 ), /* 사각3 */ linear-gradient( lightgray 20px, transparent 0 ); /* 사각4 */ background-repeat: repeat-y; 샘플) sceleton-step1 1&lt;div class=&quot;skeleton-screen&quot;&gt;&lt;/div&gt; 1234567891011121314151617181920.skeleton-screen&#123; margin: auto; width: 500px; height: 500px; background-image: radial-gradient( circle 50px at 50px 50px, lightgray 100%, transparent 0 ), linear-gradient( lightgray 20px, transparent 0 ), linear-gradient( lightgray 20px, transparent 0 ), linear-gradient( lightgray 20px, transparent 0 ), linear-gradient( lightgray 20px, transparent 0 ); background-image: -webkit-radial-gradient( 50px 50px, circle cover, lightgray 50px, transparent 0 ), -webkit-linear-gradient( lightgray 20px, transparent 0 ), -webkit-linear-gradient( lightgray 20px, transparent 0 ), -webkit-linear-gradient( lightgray 20px, transparent 0 ), -webkit-linear-gradient( lightgray 20px, transparent 0 ); background-repeat: repeat-y;&#125; 2) background-position : 위치 지정 겹쳐 있는 각 도형의 위치를 x축, y축으로 재지정 해준다. 123456background-position: 0 0, /* 원형 */ 120px 0, /* 사각1 */ 120px 40px, /* 사각2 */ 120px 80px, /* 사각3 */ 120px 120px; /* 사각4 */ 3) background-size : 사이즈 지정 각 도형에 원하는 사이즈 width, height 값을 지정해다. 123456background-size: 100px 200px, /* 원형 */ 150px 200px, /* 사각1 */ 350px 200px, /* 사각2 */ 300px 200px, /* 사각3 */ 250px 200px; /* 사각4 */ 샘플) sceleton-step2 1&lt;div class=&quot;skeleton-screen&quot;&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435.skeleton-screen&#123; margin: auto; width: 500px; height: 500px; background-image: radial-gradient( circle 50px at 50px 50px, lightgray 100%, transparent 0 ), linear-gradient( lightgray 20px, transparent 0px ), linear-gradient( lightgray 20px, transparent 0 ), linear-gradient( lightgray 20px, transparent 0 ), linear-gradient( lightgray 20px, transparent 0 ); background-image: -webkit-radial-gradient( 50px 50px, circle cover, lightgray 50px, transparent 0 ), -webkit-linear-gradient( lightgray 20px, transparent 0 ), -webkit-linear-gradient( lightgray 20px, transparent 0 ), -webkit-linear-gradient( lightgray 20px, transparent 0 ), -webkit-linear-gradient( lightgray 20px, transparent 0 ); background-repeat: repeat-y; background-size: 100px 200px, 150px 200px, 350px 200px, 300px 200px, 250px 200px; background-position: 0 0, 120px 0, 120px 40px, 120px 80px, 120px 120px; &#125; 4) animation 레이어 추가 빛이 지나가는 듯한 움직임을 위해 흰색 그라데이션의 이미지와 keyframe animation을 추가하면 효과를 표현할 수 있다.다만 주의할 점은, multi background의 경우에 쌓임맥락은 z-index와 약간 다르다는 점이다. (참고 : stacking-order-of-multiple-backgrounds)하나의 요소 안에서 이루어지기 때문에 먼저 선언할수록 위쪽으로 쌓이게 되는데, 지금까지 만든 도형보다 위쪽에 레이어를 선언해주면 된다. 1234567891011121314151617181920212223background-image: linear-gradient( 100deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.5) 50%, rgba(255, 255, 255, 0) 80% ), /* animation */ radial-gradient( circle 50px at 50px 50px, gray 99%, transparent 0 ), /* 원형 */ linear-gradient( lightgray 20px, transparent 0 ), /* 사각1 */ linear-gradient( lightgray 20px, transparent 0 ), /* 사각2 */ ... background-size: 50px 200px, /* animation */ 100px 200px, /* 원형 */ 150px 200px, /* 사각1 */ 350px 200px, /* 사각2 */ ...``` **5) :empty 선택자 활용**데이터가 들어오기 전에 빈 태그 상태를 :empty 선택자로 선택할 수 있다.:empty는 자식(텍스트 노드 포함)이 전혀 없는 요소에 적용하는 선택자이다.데이터 로딩 이전에 태그를 그리지 않은 상태일 경우에 활용 가능하다.``` css.skeleton-screen:empty &#123;&#125; 샘플) sceleton-step3 1&lt;div class=&quot;skeleton-screen&quot;&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253.skeleton-screen:empty&#123; margin: auto; width: 500px; height: 500px; background-image: linear-gradient( 100deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.5) 50%, rgba(255, 255, 255, 0) 80% ), /* highlight */ radial-gradient( circle 50px at 50px 50px, lightgray 100%, transparent 0 ), linear-gradient( lightgray 20px, transparent 0 ), linear-gradient( lightgray 20px, transparent 0 ), linear-gradient( lightgray 20px, transparent 0 ), linear-gradient( lightgray 20px, transparent 0 ); background-image: -webkit-linear-gradient( 100deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.5) 50%, rgba(255, 255, 255, 0) 80% ), -webkit-radial-gradient( 50px 50px, circle cover, lightgray 50px, transparent 0 ), -webkit-linear-gradient( lightgray 20px, transparent 0 ), -webkit-linear-gradient( lightgray 20px, transparent 0 ), -webkit-linear-gradient( lightgray 20px, transparent 0 ), -webkit-linear-gradient( lightgray 20px, transparent 0 ); background-repeat: repeat-y; background-size: 50px 200px, /* highlight */ 100px 200px, 150px 200px, 350px 200px, 300px 200px, 250px 200px; background-position: 120px 0, /* highlight */ 0 0, 120px 0, 120px 40px, 120px 80px, 120px 120px; animation: shine 1s infinite;&#125;@keyframes shine &#123; to &#123; background-position: 100% 0, /* move highlight to right */ 0 0, 120px 0, 120px 40px, 120px 80px, 120px 120px; &#125;&#125; 3. 장점 및 활용범위 단 하나의 태그에서 CSS 만으로 그려질 수 있다는 점에서 코드가 간단하며 변형 및 확장이 용이하다.또한 background-image 속성은 렌더링 시, layout 변동 없이 paint, composite 과정만 거치기 때문에 성능적으로도 이점이 있을 것으로 보인다.이를 응용하면 CSS를 활용한 패턴 제작 및 로딩아이콘, 차트 등의 다양한 드로잉도 시도해 볼 수 있다.background-image 속성의 브라우저 범위는 IE10 이상으로, 대응 범위를 확인하여 문법을 작성해야 하며 -webkit-, -moz-, -ms- and -o-의 벤더 프리픽스를 필요로 한다. 참조 http://wit.nts-corp.com/2018/11/19/5371","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"CSS","slug":"Frontend/CSS","permalink":"https://woonyzzang.github.com/categories/Frontend/CSS/"}],"tags":[{"name":"css","slug":"css","permalink":"https://woonyzzang.github.com/tags/css/"},{"name":"css3","slug":"css3","permalink":"https://woonyzzang.github.com/tags/css3/"}]},{"title":"CSS3 Custom Properties","slug":"css3-custom-properties","date":"2018-11-22T12:32:14.000Z","updated":"2024-06-07T09:27:28.277Z","comments":true,"path":"2018/11/22/css3-custom-properties/","permalink":"https://woonyzzang.github.com/2018/11/22/css3-custom-properties/","excerpt":"","text":"CSS Custom Properties (커스텀 속성) (https://www.smashingmagazine.com/2017/04/start-using-css-custom-properties/ 문서를 토대로 번역하고, 다른 문서들을 조합해 정리하였다.) 1. 전처리기 변수와 CSS 커스텀 속성 CSS 전처리기는 웹 개발에서 중요한 역할을 수행하고 있다. (Sass, Stylus, Less, PostCSS 등)전처리기의 주요 장점 중 하나는 변수를 사용할 수 있다는 것인데, 변수를 사용하면 반복적인 코드를 피할 수 있고, 개발과 리팩토링이 간단해질 수 있다. 그러나, 전처리기 변수에는 다음과 같은 몇가지 한계가 있다. 동적으로 변경할 수 없다. DOM 구조를 알지 못한다. JavaScript에서 읽거나 변경할 수 없다. 이러한 문제를 해결하기 위해 CSS 커스텀 속성이 개발되었다. 전처리기와 CSS 커스텀 속성 두 가지가 어떤 점이 다른지는 아래에서 더 자세히 알아보도록 하겠다. 2. CSS 커스텀 속성 CSS 커스텀 속성은 작성자가 정의한 속성의 집합이다. 작성자는 임의로 정한 이름의 속성에 임의의 값을 할당할 수 있다. “CSS 변수”라고 부르기도 하지만 올바른 이름은 “CSS 커스텀 속성” 이다. CSS 커스텀 속성은 아래와 같이 정의할 수 있다. 123:root &#123; --var-name: value;&#125; root&#123;&#125;: 커스텀 속성을 전역으로 사용하고자 할 때, :root {} 에 커스텀 속성을 정의한다. 커스텀 속성은 CSS 변수처럼 [속성]: [값]; 의 구문을 따르기 때문에 반드시 범위(중괄호) 내에 정의되어야 한다. --var-name: 커스텀 속성의 이름입니다. 이름은 –(이중 하이픈)로 시작하며, 속성 이름은 작성자가 정의한다. CSS 커스텀 속성은 CSS 변수처럼 보이고 작동하며, 보통은 속성 이름에 작동 방식을 반영한다. 그리고 다른 CSS 속성들과는 달리 CSS 커스텀 속성은 대소문자를 구분한다. value: 커스텀 속성의 값이다. 값에는 모든 CSS 값이 들어갈 수 있다.(색상, 문자열, 레이아웃값, 표현식 등) 12345678910111213141516:root &#123; --main-color: #f00; --main-bg: #0f0; --border-color: #ff0; --header-height: 70px; --content-padding: 10px 20px; --base-line-height: 1.5; --transition-duration: 0.5s; --external-link: &quot;external link&quot;; --margin-top: calc(2vh + 20px); /* 유효 커스텀 속성은 후에 JavaScript에서 재사용될 수 있다. */ --foo: if(x &gt; 5) this.width = 10;&#125; 3. CSS 커스텀 속성 사용하기 커스텀 속성을 사용하려면 var() 함수 안에 속성 이름을 적어 사용한다. 123.foo &#123; color: var(--var-name);&#125; var() 함수는 fallback을 제공한다.이는 쉼표로 구분되는데, var() 함수 안에서 첫 번째 쉼표 뒤의 값이 fallback으로 간주된다. var() 함수 문법: var( &lt;custom-property-name&gt; [, &lt;declaration-value&gt; ]? )첫번째 인수는 대체할 커스텀 속성 이름을 적는다. 두번째 인수는 대체 값으로, 커스텀 속성이 유효하지 않을 경우 사용된다. 123&lt;div class=&quot;box&quot;&gt; CSS Custom Property&lt;/div&gt; 123456789101112.box &#123; /* --box-margin은 정의되지 않았기 때문에 20px이 사용돤다. */ margin: var(--box-margin, 20px); /* --box-color가 정의되지 않았다면 --main-color 변수가 사용된다. */ --main-color: gold; background: var(--box-color, var(--main-color)); /* common style */ width: 300px; font-size: 15px;&#125; (1) 연산자 커스텀 속성 사용시 기본 연산자를 사용 하고자 할때는 CSS가 제공하는 calc() 함수를 사용한다. 이는 커스텀 속성의 값을 변경한 후 브라우저가 표현식을 재계산하게 한다. 아래와 같이 사용할 수 있다. 123456789101112131415&lt;div class=&quot;box1&quot;&gt; indent-size&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt; indent-xl&lt;/div&gt;&lt;div class=&quot;box3&quot;&gt; indent-l&lt;/div&gt;&lt;div class=&quot;box4&quot;&gt; indent-s&lt;/div&gt;&lt;div class=&quot;box5&quot;&gt; indent-xs&lt;/div&gt; 123456789101112:root &#123; --indent-size: 20px; --indent-xl: calc(2 * var(--indent-size)); --indent-l: calc(var(--indent-size) + 2px); --indent-s: calc(var(--indent-size) - 2px); --indent-xs: calc(var(--indent-size) / 2);&#125;.box1 &#123;font-size:var(--indent-size);&#125;.box2 &#123;font-size:var(--indent-xl);&#125;.box3 &#123;font-size:var(--indent-l);&#125;.box4 &#123;font-size:var(--indent-s);&#125;.box5 &#123;font-size:var(--indent-xs);&#125; 단위가 없는 경우, calc() 함수가 없다면 작동하지 않을 것이다. 12345678:root &#123; --spacer: 10;&#125; .box &#123; padding: var(--spacer)px; /* 작동하지 않음 */ padding: calc(var(--spacer)*1px) 0; /* 작동함 */&#125; 123456&lt;div class=&quot;box1&quot;&gt; padding: var(--spacer)px;&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt; padding: calc(var(--spacer) * 1px) 0;&lt;/div&gt; 1234567891011121314151617:root &#123; --spacer: 20;&#125;.box1 &#123; padding: var(--spacer)px; /* 작동하지 않음 */&#125;.box2 &#123; padding: calc(var(--spacer) * 1px) 0; /* 작동함 */&#125;/* common style */div &#123; width: 300px; font-size: 15px; background: gold; margin: 10px;&#125; (2) 키워드 CSS 커스텀 속성은 일반적인 CSS 속성과 같은 규칙을 가지고 있기때문에, inherit, iniial, unset, revert와 같은 일반적인 CSS 키워드를 지정할 수 있다. inherit 부모 요소의 값을 적용한다. initial CSS 스펙에 정의된 초기값을 적용한다. (CSS 커스텀 속성의 일부 경우, 초기값이 빈 값이거나 없다.) unset 속성이 상속되었으면 커스텀 속성의 경우처럼 상속된 값을 적용하고, 속성이 상속되지 않았으면 초기값을 적용한다. revert 속성을 user agent’s style sheet에 의해 초기값으로 리셋한다.(CSS 커스텀 속성의 경우, 초기값은 빈 값이다.) 123456.common-values &#123; --border: inherit; --bgcolor: initial; --padding: unset; --animation: revert;&#125; 요소에 모든 스타일을 리셋하기 위해서는 all 키워드를 사용할 수 있다. 123.my-component&#123; all: initial;&#125; 안타깝게도, all 키워드는 커스텀 속성은 리셋하지 못하며 모든 CSS 커스텀 속성을 리셋하는 – 접두사를 추가할지에 대한 논의가 진행되고 있다. 추후에는 다음과 같이 전체 리셋이 가능할지도 모른다. 1234.my-component&#123; --: initial; /* 모든 CSS 커스텀 속성 리셋 */ all: initial; /* 모든 CSS 스타일 리셋 */&#125; 4. 스코프(scope)와 상속 CSS 커스텀 속성의 스코프를 설명하기에 앞서, 자바스크립트와 전처리기의 스코프에 대해 알아보자. (1) 자바스크립트 자바스크립트는 지역변수와 전역변수가 있으며, 변수(var)는 함수에 제한된다. 하지만 자바스크립트에는 클로저(closure)라는 개념이 있어서, 자신을 감싸는 외부 함수의 변수에 접근 가능하다. (스코프 체인)클로저에는 세 개의 스코프 체인이 있으며, 다음과 같은 항목에 접근할 수 있다. 자신의 스코프 (중괄호 사이에 정의된 변수) 외부 함수의 변수 전역 변수 123456789101112window.globalVar = 10; function enclosing() &#123; var enclosingVar = 20; function closure() &#123; var closureVar = 30; return globalVar + enclosingVar + closingVar; &#125; return closure();&#125;console.log(enclosing()); // 60 (2) 전처리기 대표적인 전처리기인 Sass는 지역변수와 전역변수가 있다. (mixin과 같이 선택자 밖에 선언될 경우 전역변수 &#x2F; 그렇지 않으면 지역변수) Sass는 중첩된 코드 블록에서 자신을 감싸는 블록의 변수에 접근 가능하다. Sass에서 변수의 스코프는 코드 구조에 완전히 의존한다. 1234567global&lt;div class=&quot;enclosing&quot;&gt; enclosing &lt;div class=&quot;closure&quot;&gt; closure &lt;/div&gt;&lt;/div&gt; 1234567891011$globalVar: 10px;.enclosing &#123; $enclosingVar: 20px; .closure &#123; $closureVar: 30px; font-size: $closureVar + $enclosingVar + $globalVar; // 60px &#125;&#125; (3) CSS 커스텀 속성 커스텀 속성은 선택자 외부에서 선언할 수 없으며, :root 스코프 내에 정의된 경우만 전역으로 사용할 수 있다. CSS 커스텀 속성은 기본적으로 상속되며, 다른 CSS 속성과 같이 캐스케이딩 한다. 1234567global&lt;div class=&quot;enclosing&quot;&gt; enclosing &lt;div class=&quot;closure&quot;&gt; closure &lt;/div&gt;&lt;/div&gt; 1234567891011:root &#123; --globalVar: 10px;&#125;.enclosing &#123; --enclosingVar: 20px;&#125;.enclosing .closure &#123; --closureVar: 30px; font-size: calc(var(--closureVar) + var(--enclosingVar) + var(--globalVar)); /* 60px */&#125; 5. 전처리기 vs CSS 커스텀 속성 (1) 커스텀 속성을 바꾸면 모든 인스턴스에 즉시 적용된다. 위의 예시로 볼때, CSS 커스텀 속성은 Sass 변수와 다른 점이 없어보인다. 이번에는 변수를 사용한 후에 다시 할당해보자. 먼저 Sass를 사용해보겠다. 1234567global&lt;div class=&quot;enclosing&quot;&gt; enclosing &lt;div class=&quot;closure&quot;&gt; closure &lt;/div&gt;&lt;/div&gt; 123456789101112$globalVar: 10px; .enclosing &#123; $enclosingVar: 20px; .closure &#123; $closureVar: 30px; font-size: $closureVar + $enclosingVar + $globalVar; // 60px $closureVar: 50px; // 60px &#125;&#125; 아래는 CSS 커스텀 속성을 사용한 경우이다. 1234567global&lt;div class=&quot;enclosing&quot;&gt; enclosing &lt;div class=&quot;closure&quot;&gt; closure &lt;/div&gt;&lt;/div&gt; 123456789101112:root &#123; --globalVar: 10px;&#125;.enclosing &#123; --enclosingVar: 20px;&#125;.enclosing .closure &#123; --closureVar: 30px; font-size: calc(var(--closureVar) + var(--enclosingVar) + var(--globalVar)); /* 60px */ --closureVar: 50px; /* 80px */&#125; 여기서 전처리기와 CSS 커스텀 속성의 첫번째 차이를 알 수 있다. Sass는 변수를 다시 할당해도 결과에 아무 영향이 없지만, CSS 커스텀 속성 사용시 변수 값을 다시 할당하면 브라우저는 모든 변수와 calc() 함수를 재계산한다. (2) 전처리기는 DOM 구조를 알지 못한다. 아래와 같이 highlighted 클래스를 제외하고는 기본 폰트사이즈를 사용하는 예를 생각해보자. 먼저 CSS 커스텀 속성을 사용해보겠다. 123456&lt;div class=&quot;default&quot;&gt; default&lt;/div&gt;&lt;div class=&quot;default highlighted&quot;&gt; default highlighted&lt;/div&gt; 123456789.highlighted &#123; --highlighted-size: 30px;&#125;.default &#123; --default-size: 10px; /* highlighted-size가 주어진 경우를 제외하고는 default-size를 사용한다. */ font-size: var(--highlighted-size, var(--default-size));&#125; 위의 예에서 두번째 div는 default 외에도 highlighted 클래스를 가지고 있기 때문에 –highlighted-size와 –default-size 커스텀 속성 모두 선언된 상태이다. 따라서 font-size는 –highlighted-size인 30px이 적용된다. CSS 커스텀 속성은 DOM 구조를 이해하며, 다른 CSS 속성과 같은 규칙을 따라 캐스케이딩할 수 있다. 브라우저 동작 원리: (참고: http://d2.naver.com/helloworld/59361)렌더링 엔진은 HTML 문서를 파싱하고 ‘콘텐츠 트리’ 내부에서 태그를 DOM 노드로 변환한다. 그 다음 외부 CSS 파일과 함께 포함된 스타일 요소도 파싱한다. 스타일 정보와 HTML 표시 규칙은 ‘렌더트리’라고 부르는 또 다른 트리를 생성한다. 이번에는 Sass를 사용해봅시다. 아래에서 사용된 ‘variable-exists’ 함수는 주어진 이름의 변수가 현재 범위 또는 지역 범위에 있는지 확인한다. 123456&lt;div class=&quot;default&quot;&gt; default&lt;/div&gt;&lt;div class=&quot;default highlighted&quot;&gt; default highlighted&lt;/div&gt; 123456789101112131415.highlighted &#123; $highlighted-size: 30px;&#125;.default &#123; $default-size: 10px; /* highlighted-size가 주어진 경우를 제외하고는 default-size를 사용한다. */ @if variable-exists(highlighted-size) &#123; font-size: $highlighted-size; &#125; @else &#123; font-size: $default-size; &#125;&#125; 지역 변수는 범위 내에서만 사용 가능하기 때문에, default 클래스의 범위 내에서 highlighted-size 변수는 접근 불가하며, default-size 변수만 사용 가능하다. 따라서 default highlighted 클래스를 가진 요소더라도 font-size는 default-size인 10px이 적용된다. 여기서 중요한 것은 전처리기는 컴파일 과정을 거치기 때문에 모든 계산과 처리가 동시에 일어난다는 것이다. 그렇기 때문에 전처리기는 컴파일하기 이전의 코드 구조에 완전히 의존하고, DOM의 구조는 전혀 알지 못한다. 컴파일 과정:CSS 전처리기는 코드를 작성한 뒤, CSS 문법으로 컴파일 해주는 방식을 취한다. 이것이 전처리기와 CSS 커스텀 속성의 두번째 차이 이다. CSS 커스텀 속성은 DOM 구조를 인식하고, 동적이기 때문에 변수 스코프 지정시 이점을 가진다. 6. 자바스크립트와 함께 사용하기 이전에 CSS에서 자바스크립트로 데이터를 보내기위해서는 CSS 출력에서 JSON을 통해 CSS 값을 작성한 후, 자바스크립트에서 읽어야 했다. 이제는 .getPropertyValue() 와 .setProperty() 메소드를 사용하여 자바스크립트에서 CSS 커스텀 속성을 읽고 쓸 수 있다. 아래는 CSS 커스텀 속성을 읽어오고, 내보내는 메서드 이다. 1&lt;div class=&quot;box&quot;&gt;with JavaScript&lt;/div&gt; 123456789.box &#123; --my-color: red; background: var(--my-color); /* common style */ width: 300px; font-size: 15px; margin: 10px;&#125; 1234567891011function writeCssVar(element, varName, value) &#123; return element.style.setProperty(`--$&#123;varName&#125;`, value);&#125;function readCssVar(element, varName) &#123; const elementStyles = getConputedStyle(element); return elementStyle.getPropertyValue(`--$&#123;varName&#125;`).trim();&#125;writeCssVar(document.querySelector(&#x27;.box&#x27;), &#x27;my-color&#x27;, &#x27;gold&#x27;);readCssVar(document.querySelector(&#x27;.box&#x27;), &#x27;my-color&#x27;); 7. CSS 커스텀 속성 활용하기 CSS 커스텀 속성을 사용한 사례가 많으나, 그 중 가장 많이 사용하고, 흥미로운 사례들을 소개한다. (1) 존재하지 않는 CSS 규칙 생성 CSS “커스텀” 속성이므로 존재하지 않는 속성을 만들 수 있다. 예를 들면, translateX&#x2F;Y&#x2F;Z, background-repeat-x&#x2F;y, box-shadow-color등이 있다. 그 중 box-shadow-color 커스텀 속성을 만들어 보자. 1&lt;div class=&quot;test&quot;&gt;--box-shadow-color&lt;/div&gt; 12345678910111213141516.test &#123; --box-shadow-color: gold; box-shadow: 0 0 30px var(--box-shadow-color);&#125;.test:hover &#123; --box-shadow-color: blue; /* box-shadow: 0 0 30px blue; 사용 */&#125;/* common style */.test &#123; width: 300px; margin: 20px; border-radius: 10px; font-size: 15px;&#125; 이처럼 box-shadow의 전체 값을 다시 입력하는 대신, 원하는 부분만 대체할 수 있다. (2) 컬러 테마 컬러 테마는 CSS 커스텀 속성을 사용하는 가장 일반적인 사례 중 하나이다. 간단한 컬러 테마를 적용해보자. 12345678.btn &#123; --shadow-color: #777; --color: #fff; text-shadow: 1px 1px 3px var(--shadow-color); box-shadow: 0px 1px 3px var(--shadow-color); color: var(--color);&#125; body 요소에 클래스명을 추가한 경우에 다른 스타일을 주고싶다면 아래와 같이 override할 수 있다. 1234body.inverted .btn&#123; --shadow-color: #888; --color: #000;&#125; CSS 전처리기는 이 작업을 수행하기 위해서는 CSS 코드를 중복하는 오버헤드가 필요하다. 하지만 CSS 커스텀 속성을 사용하면 한가지 값만 재정의하면 되기 때문에 명확하고, 복사&#x2F;붙여넣기를 피할 수 있다. CSS 커스텀 속성을 사용하면, 아래와 같이 사용자가 직접 테마 색상을 선택하는 코드도 구현할 수 있다. 12345678910111213&lt;header&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;div class=&quot;subtitle&quot;&gt; Subtitle &lt;/div&gt;&lt;/header&gt;&lt;main&gt; 테마 색상을 선택하세요 : &lt;input type=&quot;color&quot; id=&quot;input-color&quot;&gt;&lt;/main&gt;&lt;footer&gt; Footer &lt;/footer&gt; 123456789101112131415161718192021222324252627282930313233343536373839:root &#123; --mainColor: orange; --paddingValue: 10px; --textColor: white;&#125;h1 &#123; background: var(--mainColor); padding: var(--paddingValue); color: var(--textColor);&#125;.subtitle &#123; padding: var(--paddingValue); background: linear-gradient( to top, rgba(0,0,0,0.3), rgba(0,0,0,0.3) ) var(--mainColor);&#125;main &#123; flex: 1; padding: var(--paddingValue);&#125;footer &#123; background: var(--mainColor); padding: var(--paddingValue); color: var(--textColor);&#125;/* common style */* &#123; margin: 0;&#125;body &#123; display: flex; flex-direction: column;&#125;html, body &#123; height: 100%;&#125; 123456var colorInput = document.querySelector(&quot;#input-color&quot;);colorInput.addEventListener(&quot;change&quot;, function() &#123; // 사이트의 테마 색상을 바꿉니다. document.documentElement.style.setProperty(&quot;--mainColor&quot;, this.value);&#125;); (3) 미디어쿼리 커스텀 속성을 사용하여 미디어쿼리를 작성해보자. 123456789101112131415161718:root &#123; --gutter: 1rem; @media (min-width: 40em) &#123; --gutter: 1.5rem; &#125; @media (min-width: 70em) &#123; --gutter: 2rem; &#125;&#125; div &#123; padding: var(--gutter);&#125;h2 &#123; margin-bottom: var(--gutter);&#125; CSS 출력은 아래와 같다. 123456789101112131415161718192021222324div &#123; padding: 1rem;&#125;h2 &#123; margin-bottom: 1rem;&#125; @media (min-width: 40em) &#123; div &#123; padding: 1.5rem; &#125; h2 &#123; margin-bottom: 1.5rem; &#125;&#125; @media (min-width: 70em) &#123; div &#123; padding: 2rem; &#125; h2 &#123; margin-bottom: 2rem; &#125;&#125; 일반적으로 작성하는 것과 CSS 결과는 동일하지만, CSS 커스텀 속성을 사용하면 훨씬 간단하며 이해하기 쉽다. 커스텀 속성을 사용하면 모든 요소의 전환점마다 새로운 속성을 지정할 필요가 없다. 8. 브라우저 지원 CSS 커스텀 속성을 지원하는 브라우저는 아래와 같다. (참고: http://caniuse.com/#search=Custom%20Properties) (1) @supports 만약 하위 브라우저를 지원해야 하는 경우, @supports를 사용한다. @supports:@supports는 지원하는 경우에만 적용되고, 지원하지 않으면 넘어갑니다.즉, 이해하지 못하는 소스는 무시하기 때문에 대체 기능을 제공할 수 있습니다. 괄호 안에는 커스텀 속성과 값을 넣는다. (ex. --color: red) 1234567@supports ((--a: 0)) &#123; /* 지원하는 경우 */&#125; @supports (not (--a: 0)) &#123; /* 지원하지 않는 경우 */&#125; 자바스트립트에서도 CSS.supports() 메소드를 사용할 수 있다. 1234567const isSupported = window.CSS &amp;&amp; window.CSS.supports &amp;&amp; window.CSS.supports(&#x27;--a&#x27;, 0); if (isSupported) &#123; /* 지원하는 경우 */&#125; else &#123; /* 지원하지 않는 경우 */&#125; 위와 같이 @supports를 사용할 경우, 제대로 작동하고 바로 수행할 수 있다는 장점이 있지만, 코드가 복잡해질 수 있다. 그렇기 때문에 자동으로 CSS 결과를 처리하는 플러그인을 사용하는 방법도 있다. (PostCSS에서 제공하는 postcss-custom-properties) (2) 중복 사용하기 하위 브라우저를 지원하기 위해, CSS의 특징을 활용할 수 있다. 12345div &#123; --color: red; color: red; color: var(--color);&#125; 위와 같이 사용하면, 먼저 color: red 가 적용된 다음, CSS 커스텀 속성이 적용된다. 비록 속성을 중복 사용하지만, 기존에 사용하는 코드 내에서 CSS 커스텀 속성을 쉽게 사용할 수 있다. 즉, 브라우저가 CSS 커스텀 속성을 지원하지 않더라도 쉽게 리팩토링할 수 있다. 9. 결론 지금까지 CSS 커스텀 속성에 대해 알아보았으며, 전처리기와 어떤 점이 다른지 살펴보았다. 이 둘의 장점을 비교해보면 아래와 같다. CSS 커스텀 속성 전처리기 전처리기 없이 사용 가능하다 브라우저 지원을 고려할 필요가 없다 캐스케이딩 한다 단위를 제거할 수 있다 값이 바뀌면 브라우저가 재계산 한다 - 자바스크립트에서 다룰 수 있다 - 그동안 CSS 전처리기를 사용해왔지만, CSS 커스텀 속성의 장점도 많기 때문에 사용해보아도 좋을 것 같다. 참조 http://wit.nts-corp.com/2017/06/27/4731– https://www.smashingmagazine.com/2017/04/start-using-css-custom-properties/ (CSS 커스텀 속성)– https://www.mikestreety.co.uk/blog/css-custom-properties-everyday-applications (CSS 커스텀 속성)– https://css-tricks.com/css-custom-properties-theming/ (CSS 커스텀 속성과 테마 적용하기)– https://css-tricks.com/difference-between-types-of-css-variables/ (CSS 변수와 전처리기 변수의 차이)– https://csswizardry.com/2016/10/pragmatic-practical-progressive-theming-with-custom-properties/ (실용적이고 진보적인 CSS 커스텀 속성)– https://www.w3.org/TR/css-variables/– &lt;https://developer.mozilla.org/– http://caniuse.com/&gt;– https://una.im/local-css-vars/?utm_source=CSS-Weekly&amp;utm_campaign=Issue-269&amp;utm_medium=web (지역범위 CSS 커스텀 속성)","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"CSS","slug":"Frontend/CSS","permalink":"https://woonyzzang.github.com/categories/Frontend/CSS/"}],"tags":[{"name":"css","slug":"css","permalink":"https://woonyzzang.github.com/tags/css/"},{"name":"css3","slug":"css3","permalink":"https://woonyzzang.github.com/tags/css3/"}]},{"title":"Mobile Web iPhone Hover Click","slug":"mobile-web-iphone-hover-click","date":"2018-04-28T14:16:19.000Z","updated":"2024-06-07T09:27:28.345Z","comments":true,"path":"2018/04/28/mobile-web-iphone-hover-click/","permalink":"https://woonyzzang.github.com/2018/04/28/mobile-web-iphone-hover-click/","excerpt":"","text":"iPhone Safari 에서 클릭을 두 번 해야만 동작 이슈먼저 자세한 증상 및 원인과 해결방법은 아래와 같다. 증상 : 클릭시 첫번째 클릭은 동작안함(두번째부터 동작함)원인 : css의 허위클래스 :hover 선언시 문제발생으로 마우스 오버시 클릭하면 이벤트가 동작안함디바이스 : 아이폰 safari 브라우저 왜 두 번 클릭해야 하는 현상이 생기는 것인가? 왜 두 번 클릭해야 하나?먼저, hover 효과가 적용된 엘리먼트에서 두 번 클릭이 필요한 이유에 대해 자세히 알아보자.모바일 사파리에서 터치를 시도하면 아래와 같은 이벤트가 순서대로 발생한다. 1touchstart - touchend - mouseover - mousemove - mousedown - mouseup - click 마우스가 존재하진 않지만, 내부적으로는 터치 이벤트 뿐만 아니라 마우스 이벤트도 발생하는 것을 볼 수 있다. 중요한 건, mouseover 시점에서 화면이 변경될 경우, 이벤트가 멈춘다는 것이다.(이벤트 발생 프로세스의 자세한 내용은 Safari Developer Library의 Handling Events 챕터를 참고.) 위 문서에는 화면이 변경(if the contents of page changes)되는 것에 대한 명확한 정의는 없다.테스트 해본 결과, ‘화면이 변경’된다는 것은 정확하게는 ‘레이아웃이 변경(reflow)’되는 것에 가까운 것 같다.백그라운드가 변경된다거나, 레이아웃에 영향을 끼치지 않는 정도의 margin&#x2F;padding이 변경되는 경우(repaint)에는 이벤트가 종료되지 않는다. 따라서, 두 번 클릭해야 실행되는 문제를 해결하기 위해서는, 터치 인터페이스에서는 mouseover 이벤트가 발생했을 때 화면 변경이 되지 않도록 해야 한다. 마우스 이벤트를 터치 인터페이스로 바꾸면 어떨까? 마우스 이벤트와 상응하는 이벤트를 터치 이벤트와 매칭시켜주면 어떨까? 12345mouseover -&gt; touchstartmousemove -&gt; touchmovemousedown -&gt; touchendmouseup -&gt; ? mouseout -&gt; ? 터치 이벤트와 정확하게 매칭되지도 않을 뿐더러, 몇몇 모듈에 테스트해본 결과 기대했던 대로 동작하지도 않았다. 터치 디바이스일 경우엔, mouse 이벤트를 모두 무시하면 어떨까? 현재 서비스에서는 모든 이벤트를 특정 라이브러리를 통해서 바인딩하고 있다. 이벤트를 바인딩하는 해당 메서드를 오버라이드해서, 터치 디바이스에서 mouse를 포함한 이벤트를 바인딩하려는 경우 모두 무시하면 어떨까?대부분의 문제가 해결됐다. 다만, click이 아닌 mousedown을 사용하는 몇몇 컴포넌트(drag&#x2F;drop 같은)는 전혀 작동하질 않는다. 일단은 해결책 중의 하나가 될 수 있겠지만, 의도하지 않은 부분까지도 전혀 작동되지 않는 건 문제가 있다.화이트 리스트 방식의 적용이 필요하다. CSS로 hover 효과를 내는 건 어떻게? 마우스 이벤트로 hover를 주는 건은 마우스 이벤트를 제거하는 걸로 해결이 된다 치더라도, CSS로 hover 효과를 주는 경우엔 제어가 되지 않는다.스크립트를 사용해서 CSS 파일을 분기하면 처리할 수 있겠으나, 이건 배보다 배꼽이 크다는 판단이다.보통은 클릭 이벤트를 강제로 발생하도록 하는 방법으로 처리할 수 있다고 한다. 클릭 이벤트를 강제로 발생한다? CSS로 hover가 적용된 경우라면, mouseover 이벤트에서 이벤트를 중지하고 강제로 한 번 더 click 이벤트를 발생하도록 처리하는 방법이 있다.마찬가지로, 이벤트 바인딩 메서드를 오버라이드 해서 구현해봤다. 대부분이 문제 없이 잘 실행된다. 하지만, 역시 몇 가지 문제가 있다.&#96;overflow: scroll 속성을 가지고 있는 엘리먼트 내에서 one-finger 스크롤 시, 예기치 않은 이벤트가 계속 발생한다.또한, 스크립트로 hover 효과가 적용된 경우라면, mouse 이벤트를 없애는 경우보다 비효율적이다. 터치 때마다 페이지 변경이 계속 발생하기 때문이다. 그리고 mouse 이벤트를 모두 제거했을 때와 마찬가지로 화이트 리스트 방식의 접근이 필요한다. 해결방법1 아래와 같은 방법으로 해결할 수 있다. 1.특정 클래스 클래스를 가지고 있는 엘리먼트의 경우, 마우스 이벤트를 할당하지 않는다. 스크립트로 hover 효과를 적용한 경우에 적합하다. 이벤트를 바인딩하는 메서드를 오버라이드 한다. ignore-mouse-event 클래스를 가진 경우, 마우스 이벤트를 할당하지 않는다. mouseover 효과 제거가 필요한 엘리먼트에 해당 클래스를 추가한다. 2.특정 클래스를 가지고 있는 엘리먼트의 경우, mouseover 이벤트 발생 시 이벤트를 멈추고 강제로 click 이벤트를 발생한다. CSS로 hover 효과를 적용한 경우에 적합하다. document에 mouseover 이벤트를 바인딩한다. touch-force-click 클래스를 가지고 있는 경우, 이벤트를 멈추고 click 이벤트를 발생한다. css로 hover가 적용된 엘리먼트에 해당 클래스를 추가한다. 해결방법2 해결방법은 간단하다. 모바일 환경인 경우 css의 :hover가 동작하지 않도록 설정하는 방법이다. 이 경우 미디어 쿼리를 사용할 수 있을 것이다. 몇 가지 해결방법들에 대하여 알아보자. 1. 모바일인 경우 touch와 같은 클래스 추가하여 해결하기 hover 이벤트를 막는 방법으로 모바일 환경인 경우 이를 인지할 수 있는 클래스를 선언하여 :hover인 경우 아무 동작이 없도록 하는 방법이 있다. 예를들어 모바일 환경이면 스크립트를 사용하여 body 태그에 touch 라는 클래스를 추가할 수도 있다.아니면 미디어쿼리(media-query)를 사용해서 모바일 환경에서는 마우스 오버 스타일을 동작하지 않도록 코드를 추가한다. 123@media only screen and (min-width: 768px) &#123; button &#123;&#125;&#125; 2. :hover는 반드시 mobile이 아닌 경우에만 동작하도록 하기 이 역시 데스크탑에서만 가능한 미디어쿼리를 적용할 수 있다. 마우스 오버의 스타일 정의는 오직 모바일이 아닌 경우만 가능하도록 한다. 123@media only screen and (max-width: 768px) &#123; button:hover &#123;&#125;&#125; 3. 모바일 전용 페이지인 경우 모든 hover 제거하기 만약 반응형이 아닌 모바일 페이지라면 :hover를 사용할 필요가 없을 것이다. 이런 이유로 모바일 전용 페이지의 마우스 오버 스타일코드를 제거한다. 참조 https://webisfree.com/2017-11-02/safari-mobile%EC%97%90%EC%84%9C-%ED%81%B4%EB%A6%AD%EC%9D%84-%EB%91%90-%EB%B2%88-%ED%95%B4%EC%95%BC%EB%A7%8C-%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94-%EB%AC%B8%EC%A0%9C http://ohgyun.com/350","categories":[{"name":"Web","slug":"Web","permalink":"https://woonyzzang.github.com/categories/Web/"},{"name":"Mobile","slug":"Web/Mobile","permalink":"https://woonyzzang.github.com/categories/Web/Mobile/"}],"tags":[{"name":"mobile","slug":"mobile","permalink":"https://woonyzzang.github.com/tags/mobile/"}]},{"title":"jQuery Performance","slug":"jquery-performance","date":"2018-04-28T12:07:55.000Z","updated":"2024-06-07T09:27:28.339Z","comments":true,"path":"2018/04/28/jquery-performance/","permalink":"https://woonyzzang.github.com/2018/04/28/jquery-performance/","excerpt":"","text":"jQuery 성능 향상하기 (performance)jQuery는 라이브러리이기 때문에 순수 자바스크립트보다 당연히 성능이 느릴 수 밖에 없다. 안 그래도 느린데 잘못된 방법으로 코딩을 하면 상황을 더 악화시킬 수 있다. 그래서 흔히들 하는 실수와 그에 대한 대처 방법을 소개 한다. 변수 저장우선 첫 번째로 가장 간단한 건데 많이 놓치고 있는 부분이 있다. 제이쿼리로 찾은 객체를 변수에 저장하지 않는 것이다. 123$(&#x27;#zero&#x27;).text(&#x27;저장하지 않으면 매번 함수가 실행됩니다&#x27;);$(&#x27;#zero&#x27;).append(&#x27;&lt;button /&gt;&#x27;);$(&#x27;#zero&#x27;).css(&#x27;color&#x27;, &#x27;#fff&#x27;); 위와 같이 $(&#39;#zero&#39;)를 여러 번 쓰는 것을 많이 봤을 것이다. 하지만 흔히 놓치는 사실이 $()는 함수라는 겁니다. 위의 코드는 매번 함수를 실행하게 된다. 12345var $zero = $(&#x27;#zero&#x27;);$zero.text(&#x27;이렇게 저장하면 한 번만 실행됩니다&#x27;);$zero.append(&#x27;&lt;button /&gt;&#x27;);$zero.css(&#x27;color&#x27;, &#x27;#fff&#x27;); 변수에 재사용하게될 셀렉터를 저장하게 되면 단 한 번만 호출을 하게 되기에 성능에 좋다. DocumentFragment 사용jQuery가 왜 이렇게 느릴까란 질문에 꼭 나오는 부분이다. 수십, 수백 개의 태그를 동적으로 추가하는 데 documentFragement를 사용하지 않고 그냥 append 했기 때문에 나타나는 현상이다. 12345var $zero = $(&#x27;#zero&#x27;);[&#x27;Aero&#x27;, &#x27;Bero&#x27;, &#x27;Cero&#x27;, &#x27;Dero&#x27;, ... , &#x27;Zero&#x27;].forEach(function(item) &#123; $zero.append(&#x27;&lt;strong&gt;&#x27; + item + &#x27;&lt;/strong&gt;&#x27;);&#125;); 위와 같이 간단하게 할 수도 있지만 기존에 있는 태그에 append하는 것은 성능에 매우 부담이 가게된다. 또 26번 반복하기 때문에 브라우저는 26번이나 페이지를 새로 그려야 한다. 만약 반복문의 개수가 수백 수천개라고 생각해보면 더 성능이 느려질 것이다. 이럴때는 documentFragement을 활용하면 성능에 도움이 된다 123456var $frag = $(document.createDocumentFragment());[&#x27;Aero&#x27;, &#x27;Bero&#x27;, &#x27;Cero&#x27;, &#x27;Dero&#x27;, ... , &#x27;Zero&#x27;].forEach(function(item) &#123; $frag.append(&#x27;&lt;strong&gt;&#x27; + item + &#x27;&lt;/strong&gt;&#x27;);&#125;);$(&#x27;#zero&#x27;).append($frag); $frag에 append하는 것은 가상의 메모리 공간에서 일어나는 일이기 때문에 브라우저와는 상관이 없다. 위에 코드는 마지막에 그 $frag를 원래 태그에 한 번에 append해주는 것이다. 이렇게 하면 단 한번만 브라우저에 태그가 추가되어 브라우저가 페이지를 새로 그리는 횟수도 한 번만 그리 된다. 다른 방법도 있다. 바로 detach 메소드를 사용하는 것이다.detach() 메서드는 노드를 DOM에서 제거 하면서 캐싱한다. (캐싱될때 노드의 정보는 jQuery 데이터 형태로 이전에 등록되었던 이벤트, 정보들도 함께 캐싱하게 된다.) DOM에서 제거했다가 추후에 다시 삽입하는 형태로 사용 가능하다. 캐싱된 노드를 다시 DOM에 삽입 후, 이벤트를 다시 등록해 줄 필요가 없다. 123456var $zero = $(&#x27;#zero&#x27;).detach();[&#x27;Aero&#x27;, &#x27;Bero&#x27;, &#x27;Cero&#x27;, &#x27;Dero&#x27;, ... , &#x27;Zero&#x27;].forEach(function(item) &#123; $zero.append(&#x27;&lt;strong&gt;&#x27; + item + &#x27;&lt;/strong&gt;&#x27;);&#125;);$zero.appendTo($zeroParent); detach 메소드를 사용하는 순간 원래 있던 #zero 태그는 브라우저에서 떨어져서 메모리 속으로 들어간다. 메모리 상에서 append를 해준 후 마지막에 다시 원래 태그의 부모의 자식으로 추가하는 것이다. 선택자 최적화jQuery 선택자를 사용하는 데 있어 많은 실수를 하곤 한다. 선택자는 원하는 태그를 선택할 수 있을 정도로만 최소화해서 사용해야 한다. 예를 들면 $(&#39;div#zero&#39;)는 간단히 $(&#39;#zero&#39;)로 표현할 수 있다. 어차피 id는 유니크한 단 하나의 태그만 가리키기 때문이다.또한 id나 class를 사용하는 게 좋은데 $(&#39;div p a&#39;)보다는 $(&#39;#zero p a&#39;)가 훨씬 성능이 좋다. 찾길 원하는 태그가 있다면 id나 class를 붙여서 사용하는걸 권장한다.그리고 제이쿼리에서 지원하는 선택자들 :input, :even, :odd 등등은 최대한 피하는 게 좋다. 순수 자바스크립트에서 지원하지 않는 만큼, 제이쿼리가 직접 구현해야 하는데 이 과정에서 성능이 저하될 수 있기 때문이다. 참조 https://www.zerocho.com/category/jQuery/post/57c3a8821efc521700a70918","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Library","slug":"Frontend/Library","permalink":"https://woonyzzang.github.com/categories/Frontend/Library/"},{"name":"jQuery","slug":"Frontend/Library/jQuery","permalink":"https://woonyzzang.github.com/categories/Frontend/Library/jQuery/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"https://woonyzzang.github.com/tags/jquery/"}]},{"title":"Ubuntu OS Playonlinux","slug":"ubuntu-os-playonlinux","date":"2017-11-10T05:16:46.000Z","updated":"2024-06-07T09:27:28.380Z","comments":true,"path":"2017/11/10/ubuntu-os-playonlinux/","permalink":"https://woonyzzang.github.com/2017/11/10/ubuntu-os-playonlinux/","excerpt":"","text":"Ubuntu 16.04 LTS Playonlinux 설치우분투에서 Wine 과 PlayOnLinux 를 사용하여 윈도우 프로그램을 사용할 수 있다.설치는 소프트웨어 센터에서 Playonlinux 를 간편하게 설치하거나 터미널 명령어를 설치 하면 된다. Wine 설치 터미널 창에서 다음의 명령어를 통해 Wine 을 설치 한다. 12345$ sudo apt-get install software-properties-common$ sudo dpkg --add-architecture i386$ sudo add-apt-repository ppa:wine/wine-builds$ sudo apt-get update$ sudo apt-get install --install-recommends winehq-staging PlayOnLinux 설치 터미널 창에서 다음의 명령어를 통해 playonlinux 를 설치 한다.($는 일반 사용자 쉘, #는 root 쉘을 뜻함.) 12345$ sudo apt-get install software-properties-common$ sudo dpkg --add-architecture i386$ sudo add-apt-repository ppa:wine/wine-builds$ sudo apt-get update$ sudo apt-get install --install-recommends winehq-staging Playonlinux playonlinux 를 사용하여 Adobe Photoshop CS6를 설치해봤는데 잘 구동된다.예전에는 포토샵을 정상 적으로 설치 하여도 폰트가 깨지는 등 완벽 구동이 되지 않았었는데 우분투 16.04.3 LTS 버전에서는 별 문제 없는 것 같다. 참조 https://www.playonlinux.com/en/","categories":[{"name":"OS","slug":"OS","permalink":"https://woonyzzang.github.com/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"https://woonyzzang.github.com/categories/OS/Linux/"},{"name":"Ubuntu","slug":"OS/Linux/Ubuntu","permalink":"https://woonyzzang.github.com/categories/OS/Linux/Ubuntu/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://woonyzzang.github.com/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://woonyzzang.github.com/tags/ubuntu/"}]},{"title":"Ubuntu OS Chrome Browser","slug":"ubuntu-os-chrome-browser","date":"2017-11-10T04:15:55.000Z","updated":"2024-06-07T09:27:28.378Z","comments":true,"path":"2017/11/10/ubuntu-os-chrome-browser/","permalink":"https://woonyzzang.github.com/2017/11/10/ubuntu-os-chrome-browser/","excerpt":"","text":"Ubuntu OS 16.04 LTS 크롬 브라우저 설치예전 우분투 버전에서는 소프트웨어 센터에서 chromium 으로 설치를 해서 사용했었는데 업데이트 된 우분투 리눅스에는 chromium 설치가 되지 않는 듯 하다.검색 확인 결과 크롬 브라우저를 설치하려면 터미널에서 아래 명령어를 실행해서 설치 과정을 거치면 크롬 브라우저를 사용할 수 있다. 우분투 16.04 크롬 설치하는 방법 123$ wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb sudo apt-get in$ sudo apt-get install libxss1 libgconf2-4 libappindicator1 libindicator7$ sudo dpkg -i google-chrome-stable_current_amd64.deb 설치가 완료된 후 확인 해보면 크롬 브라우저가 잘 설치된 것을 볼 수 있다. 참고로 윈도우용 크롬에서 쓰던 맑은고딕굴림체 등을 우분투용 크롬에서도 사용하고 싶다면 아래와 같이 하면 진행하면 된다. 윈도우 C:\\Windows\\Font 디렉토리에서 굴림체(gulim.ttc), 맑은고딕(malgun.ttf &#x2F; malgunbd.ttf &#x2F; malunsl.ttf), 바탕(batang.ttc) 정도만 추출 한다. 우분투 /usr/share/fonts/ 디렉토리에 복사를 하거나 임의의 디렉토리를 생성한 후(&#x2F;usr&#x2F;share&#x2F;fonts&#x2F;truetype&#96;) 그 안에 폰트 서체를 넣는다. 터미널 창에서 fc-cache -f -v 라고 입력하여 폰트 파일 캐시를 갱신한다. 크롬 브라우저의 설정 &gt; 글꼴 맞춤설정 에서 폰트 서체를 변경한다. 만약 폰트캐시 갱신을 했는데도 크롬 설정에서 폰트가 보이지 않는다면 PC를 재부팅 한다. 참조 http://jimnong.tistory.com/693","categories":[{"name":"OS","slug":"OS","permalink":"https://woonyzzang.github.com/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"https://woonyzzang.github.com/categories/OS/Linux/"},{"name":"Ubuntu","slug":"OS/Linux/Ubuntu","permalink":"https://woonyzzang.github.com/categories/OS/Linux/Ubuntu/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://woonyzzang.github.com/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://woonyzzang.github.com/tags/ubuntu/"}]},{"title":"React.js Functional Component","slug":"reactjs-functional-component","date":"2017-11-10T00:29:01.000Z","updated":"2024-06-07T09:27:28.350Z","comments":true,"path":"2017/11/10/reactjs-functional-component/","permalink":"https://woonyzzang.github.com/2017/11/10/reactjs-functional-component/","excerpt":"","text":"React.js Functional Component (함수형 컴포넌트)React 에서 컴포넌트를 정의 할 때는 보통 EcmaScipt 6 에 도입된 class 문법을 사용한다. 컴포넌트에서 라이프사이클 API 를 사용해야 하거나, state 를 사용하는 경우에는 꼭 이렇게 정의를 해야 했었다. 1234567891011import React, &#123; Component &#125; from &#x27;react&#x27;;class Hello extends React.Component &#123; render() &#123; return ( &lt;div&gt;Hello &#123;this.props.name&#125;&lt;/div&gt; ); &#125;&#125;export default Hello; React.createClass(…) 를 사용하는 방법도 있지만 요즘 잘 사용되지 않는 추세이다. 만약에 만들어야 하는 컴포넌트가 라이프사이클 API 도 사용하지 않고, state 도 사용하지 않고, 그냥 props 만 전달해주면 뷰를 렌더링만 해주는 역할이라면 함수형 컴포넌트 형식으로 컴포넌트를 정의 할 수 있다. 123456789import React from &#x27;react&#x27;;function Hello(props) &#123; return ( &lt;div&gt;Hello &#123;props.name&#125;&lt;/div&gt; );&#125;export default Hello; 아니면 ES6 의 화살표 함수를 사용해서 만들수도 있다. 123456789import React from &#x27;react&#x27;;const Hello = (props) =&gt; &#123; return ( &lt;div&gt;Hello &#123;props.name&#125;&lt;/div&gt; );&#125;export default Hello; 위에 코드를 비구조화 할당 (Object Destructuring) 문법을 사용하면 다음과 같이 작성할 수 있다. 123456789import React from &#x27;react&#x27;;const Hello = (&#123;name&#125;) =&gt; &#123; return ( &lt;div&gt;Hello &#123;name&#125;&lt;/div&gt; );&#125;export default Hello; 컴포넌트를 만드는게 훨씬 더 쉬워졌을 것이다.참고로 함수형 컴포넌트를 사용 할 때 첫 마운팅 속도에 있어서는 7% ~ 11% 빠르다고 한다. 그럼 이 함수형 컴포넌트를 어떤 상황에 사용해야 하는가? state 나 라이프사이클 API 를 전혀 사용하지 않을 때, 그리고 해당 컴포넌트는 자체 기능은 따로 없고 props 가 들어가면 뷰가 나온다는 것을 명시하기 위해 사용한다거나 특히, Redux 를 사용하여 컴포넌트들을 구성 할 때, Container 컴포넌트 (혹은 Smart, 컴포넌트) 는 클래스형 컴포넌트를 사용하고, Presentational 컴포넌트 (혹은, Dumb 컴포넌트) 는 함수형 컴포넌트를 사용해볼 수 있다. 참조 https://velopert.com/2994","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"SPA","slug":"Frontend/SPA","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/"},{"name":"React.js","slug":"Frontend/SPA/React-js","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/React-js/"}],"tags":[{"name":"react","slug":"react","permalink":"https://woonyzzang.github.com/tags/react/"}]},{"title":"React.js Router v3","slug":"reactjs-router-v3","date":"2017-10-05T23:29:54.000Z","updated":"2024-06-07T09:27:28.357Z","comments":true,"path":"2017/10/06/reactjs-router-v3/","permalink":"https://woonyzzang.github.com/2017/10/06/reactjs-router-v3/","excerpt":"","text":"React.js Router v3 사용하기아직 React-Router v3 는 유지보수가 이뤄지고 있는 상태이며, 현재 2017년 3월 기준 가장 최신 버전은 v4 이다. (한동안 베타였는데 정식 릴리즈되었다. 관련 동영상이 만들어졌으니 여기를 참조) 리액트 프로젝트에서 여러 페이지가 있을 땐, 라우터를 사용한다. 라우터는 사용자가 요청한 URL에 따라서 다른 결과물을 렌더링해준다. 일반 Apache, Nginx 등의 웹 서버에서 각 페이지마다 다른 디렉토리 및 파일을 제공하여 여러 페이지를 구현하는것과 달리, 리액트 라우터(react-router)를 사용하는 프로젝트에서는 어떤 경로로 들어오던 똑같은 html 파일과 자바스크립트 파일을 제공을 한다. 여기서 제공되는 js 파일에서는 웹 어플리케이션에서 사용 할 모든 컴포넌트들이 담겨있고, URL에 따라서 지정된 컴포넌트를 렌더링해준다. 그리고, 페이지가 한번 로드 된 다음에 다른 페이지로 이동 시, 이동 될 때 마다 페이지를 처음부터 로딩하지 않고 기존에 불러왔었던 자바스크립트 파일을 이용하여 페이지에서 기존 컴포넌트를 언마운트 시키고 다른 컴포넌트를 마운트한다. 예를들어서, 웹의 헤더 컴포넌트와 같이 모든 페이지에서 존재하는 컴포넌트의 경우 페이지가 바뀌어도 처음부터 렌더링 할 필요 없이, 그대로 유지 할 수 있다는 뜻이다. 이 포스트에서는, React-router 를 프로젝트에서 사용하는 방법을 알아보도록 하겠다. 현재 React-router 의 최신버전은 v4 이다. React Router v4 Pre Release 버전의 경우 아직까진 베타여서 production-ready 하지는 않은 것 같다. 서브라우트의 경우 뒤로가기가 제대로 작동하지 않는 이슈가 있었고 (&#x2F; → &#x2F;post&#x2F;1 → &#x2F;post&#x2F;2 로 이동을 한다음에 뒤로가기를 하면 중간 서브라우트가 생략되고 &#x2F; 로 이동 됨) 문서들이 부족해서 서버사이드 렌더링을 하게 될 때 가이드가 좀 부족한 편이고 (특히 리덕스 등의 상태 관리 라이브러리와 함께 사용시..) 써드 파티 라이브러리도 조금 적은 편이다.그래서, 이 포스트에서는 v3 를 다뤄보겠다. 이 버전은 기존의 v2 버전과 동일하게 작동하는데, 기능개선 및 버그수정이 된 버전이다. v4 의 경우 새로운 방식의 라우팅이라 편하고 멋지긴 하지만, 만약에 문제를 겪을 시 혼자 해결해 나갈 수 있는 자신이 있으신 분들만 사용하시길 권장한다. 1. 프로젝트 만들기react-router 를 사용해보기 위하여, 프로젝트를 준비해준다. create-react-app 이란 도구를 사용하면 간편하게 프로젝트를 만들 수 있다. 자세한 사용법은 여기를 참조하면 된다. 1$ create-react-app react-router-tutorial 이 작업은 2~3분 정도 소요됩니다. 그 동안, 이 포스트를 훑어가면서 앞으로 어떤 작업을 하게 될 지 간단하게 예습을 해보세요. 설치가 완료되면, react-router 를 로컬 모듈로 설치하자. 1$ npm install --save react-router 2. 프로젝트 계획이번 프로젝트에서는 4가지의 라우트를 만들겠다. / 메인 라우트로서, 프로젝트에서 가장 처음 보여줄 페이지이다. Home 컴포넌트를 보여준다./about 이 라우트에서는 About 컴포넌트를 보여준다./post 이 라우트에서는 Posts 컴포넌트를 보여준다./post/:id/ 이 라우트에서는 Post 컴포넌트를 보여준다. id 라는 파라미터를 화면에 렌더링한다.추가적으로, Header 라는 컴포넌트를 만들어 이 컴포넌트는 모든 페이지에서 보여주도록 설정 할 것이다. 그 다음에는 Node.js 환경의 서버를 사용하여 프로젝트를 올려보겠다. 3. 라우팅을 위한 컴포넌트 만들기3.1 Header먼저 src 디렉토리 내부에 components 디렉토리를 만들고, 그 안에 Header.js 라는 파일을 만든다. 1234567891011121314151617181920212223// src/components/Header.jsimport React from &#x27;react&#x27;;import &#x27;./Header.css&#x27;;const MenuItem = (&#123;active, children, to&#125;) =&gt; ( &lt;div className=&quot;menu-item&quot;&gt;&#123;children&#125;&lt;/div&gt;)const Header = () =&gt; &#123; return ( &lt;div&gt; &lt;div className=&quot;logo&quot;&gt;velopert&lt;/div&gt; &lt;div className=&quot;menu&quot;&gt; &lt;MenuItem&gt;홈&lt;/MenuItem&gt; &lt;MenuItem&gt;소개&lt;/MenuItem&gt; &lt;MenuItem&gt;포스트&lt;/MenuItem&gt; &lt;/div&gt; &lt;/div&gt; );&#125;;export default Header; 추후, 활성화된 라우트의 메뉴 아이템일 경우 다른 스타일이 적용되게 설정 할 것이다. 다음, 그리고 간단하게 스타일링을 해준다. 1234567891011121314151617181920212223242526272829303132333435363738/* src/components/Header.css */.logo &#123; height: 3.5rem; background-color: #212529; width: 100vw; line-height: 3.5rem; color: white; font-size: 1.5rem; font-weight: bold; text-align: center;&#125;.menu &#123; background-color: #343a40; height: 3.5rem;&#125;.menu-item &#123; display: inline-block; color: white; font-size: 1rem; line-height: 3.5rem; width: 33.3333%; text-align: center; cursor: pointer; transition: background-color 0.3s; text-decoration: none;&#125;.menu-item:hover &#123; background-color: #495057;&#125;.menu-item:active,.menu-item.active &#123; background-color: #1862ab;&#125; 이제 App.js 에서 헤더 컴포넌트를 불러와서 렌더링한다. 1234567891011121314151617// src/App.jsimport React, &#123;Component&#125; from &#x27;react&#x27;;import Header from &#x27;./components/Header&#x27;;class App extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;Header/&gt; &#123;this.props.children&#125; &lt;/div&gt; ); &#125;&#125;export default App; 헤더 아래에는 10번째 줄에서 children 이 렌더링 되게 했다. 복습을 해보자면, 이 부분엔 컴포넌트 태그 사이의 내용이 입력된다.예: &lt;컴포넌트&gt;여기 있는 내용&lt;&#x2F;컴포넌트&gt;. 나중에, 라우트용 컴포넌트가 저 부분에서 렌더링 되는 것 이다. 3.2 BigText 컴포넌트 만들기이 컴포넌트는 아무 의미없이 대문짝만하게 큰 글씨를 띄워주는 컴포넌트이다. 1234567891011121314// src/components/BigText.jsimport React from &#x27;react&#x27;;import &#x27;./BigText.css&#x27;;const BigText = (&#123;children&#125;) =&gt; &#123; return ( &lt;div className=&quot;big-text&quot;&gt; &#123;children&#125; &lt;/div&gt; );&#125;;export default BigText; 1234567/* src/components/BigText.css */.big-text&#123; margin-top: 3rem; font-size: 7rem; text-align: center;&#125; 3.3 Home 컴포넌트 만들기프로젝트에서 가장 먼저 보여줄 라우트인 / 라우트를 위한 컴포넌트를 만들어보자.이 컴포넌트는 components 디렉토리 말고 containers 디렉토리에 만들어준다. (꼭 그럴 필요는 없지만 이는 일반 컴포넌트들과 라우트용 컴포넌트를 분리하기 위함이다.) 1234567891011121314// src/containers/Home.jsimport React from &#x27;react&#x27;;import BigText from &#x27;../components/BigText&#x27;;const Home = () =&gt; &#123; return ( &lt;div&gt; &lt;BigText&gt;홈&lt;/BigText&gt; &lt;/div&gt; );&#125;;export default Home; 3.4 About 컴포넌트 만들기 1234567891011121314// src/containers/About.jsimport React from &#x27;react&#x27;;import BigText from &#x27;../components/BigText&#x27;;const About = () =&gt; &#123; return ( &lt;div&gt; &lt;BigText&gt;소개&lt;/BigText&gt; &lt;/div&gt; );&#125;;export default About; 3.5 Posts 컴포넌트 만들기 1234567891011121314// src/containers/Posts.jsimport React from &#x27;react&#x27;;import BigText from &#x27;../components/BigText&#x27;;const Posts = () =&gt; &#123; return ( &lt;div&gt; &lt;BigText&gt;포스트&lt;/BigText&gt; &lt;/div&gt; );&#125;;export default Posts; 4. 라우터 설정컴포넌트들이 준비되었으니, 라우터 설정을 해보자. index.js 파일을 다음과 같이 수정한다. 1234567891011121314151617181920212223// src/index.jsimport React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import &#123; Router, Route, IndexRoute, browserHistory &#125; from &#x27;react-router&#x27;;import App from &#x27;./App&#x27;;import Home from &#x27;./containers/Home&#x27;;import About from &#x27;./containers/About&#x27;;import Posts from &#x27;./containers/Posts&#x27;;import &#x27;./index.css&#x27;;ReactDOM.render( &lt;Router history=&#123;browserHistory&#125;&gt; &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt; &lt;IndexRoute component=&#123;Home&#125;/&gt; &lt;Route path=&quot;about&quot; component=&#123;About&#125;/&gt; &lt;Route path=&quot;post&quot; component=&#123;Posts&#125;/&gt; &lt;/Route&gt; &lt;/Router&gt;, document.getElementById(&#x27;root&#x27;)); 3번 줄에서는, react-router 에서 4가지의 객체를 불러왔다. Router: 이 컴포넌트는 react-router 의 주요 컴포넌트로서, 라우터의 속성을 정의하고 이 내부에서 라우트 설정을 한다. Route: 이 컴포넌트는 우리가 설정한 경로에서 어떤 컴포넌트를 렌더링 할 지 정하는 컴포넌트 이다. 이 라우트 컴포넌트의 자식에 또 다른 Route 컴포넌트를 넣으면 해당 자식 컴포넌트는 부모 라우트의 서브 라우트가 된다. IndexRoute: 라우트에서 서브라우트가 주어지지 않았을 때, 즉 특정 라우트의 / 경로로 들어 왔을 때, 이 라우트에서 지정한 컴포넌트를 보여준다. browserHistory: HTML5 의 History API 를 사용하여 브라우저의 URL 변화를 주시하고, 조작한다. 13번 줄에서는 Router 컴포넌트를 정의하고 history 값을 browserHistory 로 설정 했다. history 는 브라우저의 주소창이 어떻게 바뀌는지 주시하고 주소를 라우터에서 인식할 수 있도록 location 객체로 파싱을 해준다. history 는 총 3가지가 있는데, 이에 대해선 여기서 더 자세히 알아 볼 수 있다. 14번 줄에서는 Route 컴포넌트의 path 를 “&#x2F;“ 로 설정했다. 즉, &#x2F; 경로로 들어왔을땐 App 컴포넌트를 보여주라고 설정하는 것 이죠. 그 내부에는 여러개의 Route 들이 자식으로 있는데, 이 자식들은 URL 이 매칭 하는 경우, App 컴포넌트의 자식으로 들어갑니다. 예를 들어서, &#x2F; 경로의 경우엔 IndexRoute 를 사용하여 Home 컴포넌트를 렌더링한다. &#x2F;about 경로의 경우엔 About 컴포넌트를 렌더링하죠. 자, 이제 index.js 파일을 저장하고 브라우저에서 열어보면. 첫 화면에서 홈이 보일 것이다. 5. 헤더 기능 구현아직 헤더는 폼만 잡고 있고, 클릭해도 아무 기능을 하지 않는다. 이제 기능을 구현해보자. 여기서 버튼을 눌렀을 때, 단순히 태그를 사용하여 링크를 걸 면 안된다. 작동을 하긴 하겠지만, 페이지를 새로 불러오게 된다. 하지만 리액트 프로젝트의 경우 모든 프로젝트의 클라이언트 정보를 코드를 번들링 할 때 한 파일에 담기 때문에, 주소가 변한다고해서 페이지를 새로 로딩 할 필요가 없다. 따라서, 우리는 Link 라는 컴포넌트를 사용해야한다. 이 컴포넌트는 브라우저의 주소만 바꿔주고 페이지를 새로 로딩하진 않는다. 그렇게 브라우저의 주소가 바뀌고 나면, Router 컴포넌트가 이를 인식하여 우리가 정한 컴포넌트를 보여주게 될 것이다. 5.1 메뉴 아이템 클릭시 페이지 이동 12345678910111213141516171819202122232425262728// src/components/Header.jsimport React from &#x27;react&#x27;;import &#123; Link &#125; from &#x27;react-router&#x27;;import &#x27;./Header.css&#x27;;const MenuItem = (&#123;active, children, to&#125;) =&gt; ( &lt;Link to=&#123;to&#125; className=&quot;menu-item&quot;&gt; &#123;children&#125; &lt;/Link&gt;)const Header = () =&gt; &#123; return ( &lt;div&gt; &lt;div className=&quot;logo&quot;&gt; velopert &lt;/div&gt; &lt;div className=&quot;menu&quot;&gt; &lt;MenuItem to=&#123;&#x27;/&#x27;&#125;&gt;홈&lt;/MenuItem&gt; &lt;MenuItem to=&#123;&#x27;/about&#x27;&#125;&gt;소개&lt;/MenuItem&gt; &lt;MenuItem to=&#123;&#x27;/post&#x27;&#125;&gt;포스트&lt;/MenuItem&gt; &lt;/div&gt; &lt;/div&gt; );&#125;;export default Header; MenuItem 컴포넌트에서 기존에 div 태그를 사용 하던 것을 Link 로 변환 하였다. 이 컴포넌트에 className 을 설정하면 그대로 전달이 돼서 해당 클래스를 가진 a 태그로 이뤄진 컴포넌트로 변환해준다. 이 컴포넌트는 링크가 클릭 되었을 때, 페이지가 전환 되는 것을 막고, Router 에서 정한 history 를 사용하여 브라우저의 주소를 변경한다. Link 컴포넌트가 눌렸을 때, 설정 될 라우트 경로는 to 값을 통해 설정한다. 위 코드에서는 MenuItem 에서 to 값을 설정하고 이 props 가 Link 컴포넌트의 값으로 설정되게끔 전달되었다. 코드를 저장하고, 잘 작동하는지 헤더의 버튼을 눌러보자. 5.2 현재 주소에 따라 메뉴 아이템에 다른 효과 주기 123456789101112131415161718192021222324252627282930313233// src/components/Header.jsimport React from &#x27;react&#x27;;import &#123; Link &#125; from &#x27;react-router&#x27;;import &#x27;./Header.css&#x27;;const MenuItem = (&#123;active, children, to&#125;) =&gt; ( &lt;Link to=&#123;to&#125; className=&#123;`menu-item $&#123;active ? &#x27;active&#x27;: &#x27;&#x27;&#125;`&#125;&gt; &#123;children&#125; &lt;/Link&gt;);const Header = (props, context) =&gt; &#123; const &#123; router &#125; = context; return ( &lt;div&gt; &lt;div className=&quot;logo&quot;&gt; velopert &lt;/div&gt; &lt;div className=&quot;menu&quot;&gt; &lt;MenuItem to=&#123;&#x27;/&#x27;&#125; active=&#123;router.isActive(&#x27;/&#x27;, true)&#125;&gt;홈&lt;/MenuItem&gt; &lt;MenuItem to=&#123;&#x27;/about&#x27;&#125; active=&#123;router.isActive(&#x27;/about&#x27;)&#125;&gt;소개&lt;/MenuItem&gt; &lt;MenuItem to=&#123;&#x27;/post&#x27;&#125; active=&#123;router.isActive(&#x27;/post&#x27;)&#125;&gt;포스트&lt;/MenuItem&gt; &lt;/div&gt; &lt;/div&gt; );&#125;;Header.contextTypes = &#123; router: React.PropTypes.object&#125;export default Header; 현재 주소에 따라서 메뉴 아이템을 파란색으로 설정을 하려면, 컴포넌트의 context 객체의 router 에 접근을 해야 하는데, 이를 사용하려면, 27 ~ 29번 줄처럼 contextType 을 지정해주어야 한다. context 는 React 프로젝트에서 전역적으로 사용 될 수 있는 객체이다. 컴포넌트마다 props 로 전달하기 힘든 경우에 이 기능이 사용된다.class 형태의 컴포넌트의 경우엔 this.context.router 라고 사용을 하면 되고, 위 처럼 함수형 컴포넌트의 경우엔, 두번째 파라미터로 context 를 전달받아서 사용하면 된다. router 객체 내부의 isActive 함수는 현재 브라우저의 경로가 주어진 경로와 매칭이 되는지 확인을 한다. 첫번째 파라미터로는 경로가 들어가고 두번째 파라미터는 주어진 경로가 IndexRoute 인지 설정을 한다. 예를들어서. 만약에 현재 경로가 &#x2F;about 일 때, isActive(&#39;/&#39;) 가 실행 되면 현재 경로가 &#x2F; 의 자식 경로이기 때문에 true 를 반환한다. 두번째 파라미터를 설정하여 isActive(&#39;/&#39;, true) 를 실행하면 현재 경로가 정확히 &#x2F; 일 때만 true 를 반환하고 그 외엔 false 를 반환합니다. 이를 함수를 사용하여 사용하여 MenuItem 의 active 값을 설정해주고, MenuItem 컴포넌트에서는 active 값이 true 라면 active 라는 클래스를 적용하도록 설정했다. 이제 활성화된 메뉴아이템은 파란색으로 설정된다. 6. 서브 라우트 설정하기이제 우리의 4번째 라우트, /post/:id/ 를 구현해보겠다. 6.1 Post 컴포넌트 만들기먼저 Post 컴포넌트를 만들어보. 1234567891011121314// src/containers/Post.jsimport React from &#x27;react&#x27;;import BigText from &#x27;../components/BigText&#x27;;const Post = (&#123;params&#125;) =&gt; &#123; return ( &lt;div&gt; &lt;BigText&gt;&#123;params.id&#125;&lt;/BigText&gt; &lt;/div&gt; );&#125;;export default Post; 라우트에서의 파라미터 값은, 컴포넌트에서 params props 에 접근하여 얻어 낼 수 있다. 6.2 Posts 컴포넌트 수정하기Post 컴포넌트가 Posts 컴포넌트의 내부에서 보여지게 할 계획이다. 마치, App 컴포넌트 내부에서 헤더를 보여주고 그 하단에 Home, About, Posts 컴포넌트를 보여준 것 처럼 말이죠. 그러려면, Posts 컴포넌트에서 Post 컴포넌트가 보여질 부분에 children 을 렌더링 하면 된다. 123456789101112131415// src/containers/Posts.jsimport React from &#x27;react&#x27;;import BigText from &#x27;../components/BigText&#x27;;const Posts = (&#123;children&#125;) =&gt; &#123; return ( &lt;div&gt; &lt;BigText&gt;포스트&lt;/BigText&gt; &#123;children&#125; &lt;/div&gt; );&#125;;export default Posts; 6.3 라우터 설정 수정하기 1234567891011121314151617181920212223242526// src/index.jsimport React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import &#123; Router, Route, IndexRoute, browserHistory &#125; from &#x27;react-router&#x27;;import App from &#x27;./App&#x27;;import Home from &#x27;./containers/Home&#x27;;import About from &#x27;./containers/About&#x27;;import Posts from &#x27;./containers/Posts&#x27;;import Post from &#x27;./containers/Post&#x27;;import &#x27;./index.css&#x27;;ReactDOM.render( &lt;Router history=&#123;browserHistory&#125;&gt; &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt; &lt;IndexRoute component=&#123;Home&#125; /&gt; &lt;Route path=&quot;about&quot; component=&#123;About&#125; /&gt; &lt;Route path=&quot;post&quot; component=&#123;Posts&#125;&gt; &lt;Route path=&quot;:id&quot; component=&#123;Post&#125; /&gt; &lt;/Route&gt; &lt;/Route&gt; &lt;/Router&gt;, document.getElementById(&#x27;root&#x27;)); 라우터를 위와 같이 수정해준다. &#x2F;post 경로를 위한 Route 컴포넌트 내부에 또 다른 Route 컴포넌트를 작성한다. 여기서 path 을 :id 로 설정을 하면, id 라는 파라미터가 들어가는것이라고 설정을 하는 것 이다. 지금은 Post 컴포넌트가 Posts 내부에 위치하게 하고 싶기 때문에 이렇게 했지만, 만약에 주소가 &#x2F;post&#x2F;:id 일 때 Posts 를 보여주지 않고 Post 만 보여주게 하고싶다면, 이렇게 라우트를 다음과 같이 작성하면 된다. 1234567891011ReactDOM.render( &lt;Router history=&#123;browserHistory&#125;&gt; &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt; &lt;IndexRoute component=&#123;Home&#125; /&gt; &lt;Route path=&quot;about&quot; component=&#123;About&#125; /&gt; &lt;Route path=&quot;post&quot; component=&#123;Posts&#125; /&gt; &lt;Route path=&quot;post/:id&quot; component=&#123;Post&#125; /&gt; &lt;/Route&gt; &lt;/Router&gt;, document.getElementById(&#x27;root&#x27;)); 여기까지 완성이 되었으면 &#x2F;post&#x2F;10 이런식으로 브라우저에서 직접 주소를 입력하여 들어가보자. 6.4 PostLinks 컴포넌트 만들기마지막으로, 포스트의 링크들을 보여주는 컴포넌트를 만들어서 Posts 컴포넌트에서 렌더링을 해보겠다. 먼저 컴포넌트파일을 만든다. 12345678910111213141516171819// src/components/PostLinks.jsimport React from &#x27;react&#x27;;import &#123; Link &#125; from &#x27;react-router&#x27;;import &#x27;./PostLinks.css&#x27;;const PostLinks = () =&gt; &#123; return ( &lt;div className=&quot;post-links&quot;&gt; &lt;Link to=&quot;/post/1&quot;&gt;1&lt;/Link&gt; &lt;Link to=&quot;/post/2&quot;&gt;2&lt;/Link&gt; &lt;Link to=&quot;/post/3&quot;&gt;3&lt;/Link&gt; &lt;Link to=&quot;/post/4&quot;&gt;4&lt;/Link&gt; &lt;/div&gt; );&#125;;export default PostLinks; 간단하게 스타일링도 해줍시다 12345678910111213141516171819/* src/components/PostLinks.css */.post-links a &#123; display: block; text-align: center; text-decoration: none; background-color: #495057; color: white; padding: 0.5rem; transition: background .3s;&#125;.post-links a:hover &#123; background-color: #868e96;&#125;.post-links a:active &#123; background-color: #343a40;&#125; 이제 Posts 컴포넌트에서 렌더링해줍니다 123456789101112131415161718// src/containers/Posts.jsimport React from &#x27;react&#x27;;import BigText from &#x27;../components/BigText&#x27;;import PostLinks from &#x27;../components/PostLinks&#x27;;const Posts = (&#123;children&#125;) =&gt; &#123; return ( &lt;div&gt; &lt;BigText&gt;포스트&lt;/BigText&gt; &lt;PostLinks /&gt; &#123;children&#125; &lt;/div&gt; );&#125;;export default Posts; 7. 서버에 올리기이제 Node.js 의 Express 프레임워크를 사용하여 이 프로젝트를 서버에 올려보겠다. 이 포스트에서는 여러분이 Express 에 대한 기본지식이 있다는 것을 전제로 하고 진행한다. (모르셔도 그대로 따라 할 수는 있으나, 이해를 하는게 조금 어려울 수도 있다) 현재 프로젝트 경로에서 express 를 설치하자. 1$ npm install --save express 이 포스트에서는 Node 6.9.2 버전이 사용된다. 6 미만 버전을 사용하는 경우 업데이트 해야 정상적으로 작동한다.방금 완성한 리액트 프로젝트를 빌드한다. 이 과정은 파일 최적화 과정을 거치기 때문에 1~2분 정도 소요 된다. 1$ npm run build 빌드가 완료되었다면 서버파일을 작성해보자. 서버는 server 디렉토리를 만들어서 그 안에 작성해보자. 1234567891011// server/index.jsconst express = require(&#x27;express&#x27;);const app = express();const path = require(&#x27;path&#x27;);app.use(&#x27;/&#x27;, express.static(path.resolve(__dirname, &#x27;../build&#x27;)));app.listen(4000, function () &#123; console.log(&#x27;Example app listening on port 4000!&#x27;);&#125;); 1$ node server 이제 브라우저로 http://localhost:4000/ 에 들어가서 테스팅을해보자. 작동은 잘 하는데, F5 를 눌르면 오류가 난다. 이렇게 라우팅이 잘 되다가 URL 로 직접 들어가면 오류가 발생하는 이유는, 처음 &#x2F; 경로로 들어갔을때, 서버에서 리액트 프로젝트와 html 파일을 제공해주고 그 내부에서 라우팅을 할 때는 페이지를 새로 불러오지 않고 클라이언트 내부에서 자체적으로 라우팅을 하기 때문에 정상적으로 작동하지만 새로고침을 하거나 URL 로 직접 들어가면 서버 내에서 해당 라우트를 찾는데, 그것을 위해 우리가 express 에서 따로 준비한게 없어서 이렇게 오류가 나는 것 이다. 이를 해결하기 위해선 코드를 다음과 같이 모든 경로로 들어왔을때 리액트 index.html 를 보여주게 하면 된다. 주의하실 점은, 여기서 리액트 빌드 파일이 &#x2F;static 경로에 위치해 있기 때문에 static 경로의 경우는 예외로 처리해야한다. 123456789101112131415// server/index.jsconst express = require(&#x27;express&#x27;);const app = express();const path = require(&#x27;path&#x27;);app.use(&#x27;/&#x27;, express.static(path.resolve(__dirname, &#x27;../build&#x27;)));app.get(&#x27;*&#x27;, (req, res, next) =&gt; &#123; if(req.path.split(&#x27;/&#x27;)[1] === &#x27;static&#x27;) return next(); res.sendFile(path.resolve(__dirname, &#x27;../build/index.html&#x27;));&#125;);app.listen(4000, function () &#123; console.log(&#x27;Example app listening on port 4000!&#x27;);&#125;); 이렇게하고 서버를 재시작하면 URL로 직접 들어가도 정상적으로 작동한다. 참조 https://velopert.com/2937","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"SPA","slug":"Frontend/SPA","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/"},{"name":"React.js","slug":"Frontend/SPA/React-js","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/React-js/"}],"tags":[{"name":"react","slug":"react","permalink":"https://woonyzzang.github.com/tags/react/"}]},{"title":"React.js Router [Outdated]","slug":"reactjs-router","date":"2017-10-04T15:04:37.000Z","updated":"2024-06-07T09:27:28.359Z","comments":true,"path":"2017/10/05/reactjs-router/","permalink":"https://woonyzzang.github.com/2017/10/05/reactjs-router/","excerpt":"","text":"React.js Router: URL 에 따라서 다른 결과물을 보여주기이 포스트는 Outdated 되었으니, React-router v3 를 더 자세히 다루는 리액트 프로젝트에서의 라우터, React-router v3 사용하기 를 참고하도록 하자. 이번 포스트는 React.js 의 Router 사용에 대한 내용으로 Router 는 사용자가 요청한 URL 의 서브디렉토리에 따라서 결과물을 렌더링해준다. Apache, nginx등의 웹서버처럼 각 페이지마다 다른 디렉토리 및 파일을 사용하는것과 달리, 라우터를 사용하게되면 처음부터 웹앱에서 사용 할 모든 컴포넌트들을 먼저 불러와두고, 페이지를 이동할 때 마다 그때 그때 페이지를 처음부터 로딩하지 않고 필요한 컴포넌트만 다시 렌더링 한다.(즉, Header 같은 부분처럼 변동이 없는 부분들은 유지되어있다는 의미이다.) 1. React Router 설치하기NPM 을 통하여 react-router 을 설치한다:npm install --save react-router 그리고 index.js 의 상단에 다음 코드를 추가한다:import &#123; Router, Route, browserHistory, IndexRoute &#125; from &#39;react-router&#39;; App.js의 상단에는 다음 코드를 추가한다.import &#123; Link &#125; from &#39;react-router&#39; 2. Route 할 컴포넌트 만들기이 섹션에서는 라우팅 할 컴포넌트3개를 만들어보겠다 : Home About Articles 편의를 위하여 모두 같은 파일 App.js 에 작성하도록하겠다. 1234567891011121314151617181920212223class Home extends React.Component &#123; render() &#123; return ( &lt;h2&gt;Hey, I am HOME!&lt;/h2&gt; ); &#125;&#125;class About extends React.Component &#123; render() &#123; return ( &lt;h2&gt;Hey, I am ABOUT!&lt;/h2&gt; ); &#125;&#125;class Articles extends React.Component &#123; render() &#123; return ( &lt;h2&gt;Hey, I am ARTCILES!&lt;/h2&gt; ); &#125;&#125; 3. Router Container 컴포넌트 만들기여기서 컨테이너는, App 컴포넌트이다. 1234567891011121314class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=&quot;home&quot;&gt;Home&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;about&quot;&gt;About&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;articles&quot;&gt;Articles&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &#123;this.props.children&#125; &lt;/div&gt; ); &#125;&#125; LINE 7 – 9: 여기서 를 사용하였습니다. Link 는 Router 에 내장되어있는 컴포넌트중 하나인데요, github에서 렌더링 되는 부분 코드를 살펴보면 다음과 같습니다: return &lt;a &#123;...props&#125; onClick=&#123;this.handleClick&#125; /&gt; 결국 그냥 링크를 해주는 a 태그와 같지만 다른점은 클릭했을 때, &lt;a href=&quot;..&quot;&gt; 이 태그는 페이지 자체를 리로딩해버리지만, &lt;Link&gt; 는 this.props.children 부분만 리로딩해다. LINE 11: this.props.children 은 따로 설정하는 props 가 아니라, 모든 컴포넌트가 기본적으로 가지고있는 컴포넌트로서, 컴포넌트를 사용 할 때, &lt;Component&gt;&lt;...&gt;&lt;/Component&gt; bold로 표시된 부분에 들어가는 부분이 this.props.children 으로 자동으로 설정된다. 4. ReactDOM 렌더링 및 Router 설정하기index.js 의 최하단에 이 코드를 삽입한다: 12345678ReactDOM.render(&lt;Router history = &#123;browserHistory&#125;&gt; &lt;Route path = &quot;/&quot; component = &#123;App&#125;&gt; &lt;IndexRoute component = &#123;Home&#125; /&gt; &lt;Route path = &quot;home&quot; component = &#123;Home&#125; /&gt; &lt;Route path = &quot;about&quot; component = &#123;About&#125; /&gt; &lt;Route path = &quot;articles&quot; component = &#123;Articles&#125; /&gt; &lt;/Route&gt; &lt;/Router&gt;, document.getElementById(&#x27;root&#x27;)); 지금까지 ReactDOM 을 사용해 컴포넌트를 렌더링 할 때, 바로 &lt;App…. &#x2F;&gt; 형태로 해왔지만 라우터를 사용할 땐 &lt;Router …&gt; 형태를 사용합니다. 여기선 App 컴포넌트가 Router의 props로 있는 셈이다.Route 는 클라이언트상에서 페이지를 라우팅 할 주소를 정의해준다.browserHistoy 를 사용함으로서, 뒤로가기를 해도 페이지가 새로 리로딩되지 않고 필요한부분만 리렌더링하게끔 해준다.IndexRoute 의 Index 가 의미하듯, 라우터의 첫 페이지를 정의해준다. 5. 서버 사이드 설정지금까지 작성한 코드를 저장하고 브라우저상에서 방금 만든 페이지를 열어보자.Link 들을 클릭해보면 페이지를 라우팅하는데는 문제가없지만 http://localhost/home 와 같이 직접 주소를 입력해주면 “Cannot GET &#x2F;home” 라는 오류를 반환하게 된다.해당 주소를 서버에 요청하면 서버쪽 라우터에서 먼저 연결할 곳이 있는지 확인해보고 없기 때문에 이런 오류가 발생한다.이를 위해 서버에서 따로 설정을 해주어야하는데, 지금 공부하면서 사용하는 webpack 개발서버는, webpack.config.js 파일에 코드 한줄을 추가해주면 해결된다. 12345devServer: &#123; inline: true, port: 7777, historyApiFallback: true&#125;, 4번줄인 historyApiFallback을 활성화 해주면 이 문제가 해결된다. 하지만, express를 사용하는경우에는 다음과 같이 작성하면 된다. 12345var app = express();app.get(&#x27;*&#x27;, function (request, response) &#123; response.sendFile(path.resolve(__dirname, &#x27;public&#x27;, &#x27;index.html&#x27;))&#125;); 참조 https://velopert.com/1173","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"SPA","slug":"Frontend/SPA","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/"},{"name":"React.js","slug":"Frontend/SPA/React-js","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/React-js/"}],"tags":[{"name":"react","slug":"react","permalink":"https://woonyzzang.github.com/tags/react/"}]},{"title":"React.js ref","slug":"reactjs-ref","date":"2017-10-04T14:33:16.000Z","updated":"2024-06-07T09:27:28.355Z","comments":true,"path":"2017/10/04/reactjs-ref/","permalink":"https://woonyzzang.github.com/2017/10/04/reactjs-ref/","excerpt":"","text":"React.js ref: DOMref는 reference 를 의미하며, 이는 DOM 요소에 이름을 달아준다.HTML 의 id와 사뭇 비슷하지만, id는 일반 DOM 요소에 특정 DOM 메소드만 사용 할 수 있지만, ref는 DOM 요소에도 사용하고 컴포넌트에도 사용 할 수 있으며, 해당 컴포넌트가 가지고있는 메소드 및 변수들을 사용 할 수 있다는 점이 큰 차이점 이다. Ref 를 배우기전에살펴보기 전에 한가지 사실을 먼저 짚고 넘어가야될 부분은 ref를 아무 곳에서나 자주 사용하는건 절대 비권장 한다.비록 ref를 사용하는것이 가끔씩은 코드를 간결하게 짤 수 있게해주지만, state 및 props 로 해결 할 수 있는 부분에선 ref 를 사용하지 않고, 해결 할 수 없는 부분에서만 ref 를 사용하는 것이 유지보수에 좋은 방향이다.따라서, 이 개념을 일단 잘 배워뒀다가 남용하지 말고 꼭 필요한 때에 쓰도록 하자. 어떤 경우에 써야할까?ref는 다음과 같은 경우에 유용하게 사용된다. 컴포넌트에 의해 렌더 된 DOM 에 직접 어떠한 처리를 해야 할 경우 큰 프로젝트에 React 컴포넌트를 사용하는 경우 (예: 다른 웹프레임워크와 혼용) 1. ref 사용하기ref 를 사용하는 방법은 두가지 방법이 있다 – 문자열 Attribute 사용, 콜백 함수 사용 1.1 문자열 사용하기이 방법은 outdated된 방법이다. 그래도 일단 참고용으로 한번 알아보자. 123456789101112131415161718class Hello extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;input ref=&quot;myInput&quot;&gt;&lt;/input&gt; &lt;/div&gt; ) &#125; componentDidMount() &#123; this.refs.myInput.value = &#x27;Hi, I used ref to do this&#x27;; &#125;&#125;ReactDOM.render( &lt;Hello/&gt;, document.getElementById(&#x27;app&#x27;)); LINE 5: DOM에 ref&#x3D;”refName” 형식으로 ref를 지정해준다. LINE 12: 문자열 형식으로 만든 ref 는 this.refs.refName으로 접근해야 한다.추가적으론, refs 를 사용 할 때는 컴포넌트가 렌더링 된 후 이여야 한다. 1.2 콜백 함수 사용하기12345678910111213141516171819class Hello extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;input ref=&#123;ref =&gt; this.input = ref&#125;&gt;&lt;/input&gt; &lt;/div&gt; ) &#125; componentDidMount() &#123; this.input.value = &#x27;I used ref to do this&#x27;; &#125; &#125;ReactDOM.render( &lt;Hello/&gt;, document.getElementById(&#x27;app&#x27;)); LINE 5: { } 안에 함수를 넣어 ref 를 설정하였다. 이 코드에선 arrow function 이 사용되었다. 함수 안에서 어떤 변수가 ref 로 사용 될 지 직접 정하였다. LINE 12: 5번줄에서 썼던 변수를 사용하면 됩니다. 더이상 String을 쓸 때 처럼 this.refs 를 사용하지 않아도 된다. 1.3 조금 응용해보기ref는 일반 DOM 요소 뿐만 아니라 컴포넌트 자체에 적용하여 컴포넌트의 내장된 메소드 및 변수를 사용 할 수 있다. 아래 예제 코드를 한번 살펴보자. 123456789101112131415161718192021222324252627class Hello extends React.Component &#123; handleClick() &#123; this.textBox.input.value = &#x27;I used ref&#x27;; &#125; render() &#123; return ( &lt;div&gt; &lt;TextBox ref=&#123;ref=&gt;this.textBox = ref&#125; /&gt; &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;Click Me&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;class TextBox extends React.Component &#123; render() &#123; return ( &lt;input ref=&#123;ref =&gt; this.input = ref&#125;&gt;&lt;/input&gt; ) &#125;&#125;ReactDOM.render( &lt;Hello/&gt;, document.getElementById(&#x27;app&#x27;)) 위와 같은 구린 데이터플로우는 절대 사용하면 안되고 “이런 것 도 할 수 있다” 란걸 보여주기 위한 예제 이다. LINE 19: TextBox 컴포넌트의 input 박스의 ref를 this.input으로 지정하였다. LINE 9: Hello 컴포넌트에서 TextBox 컴포넌트의 ref 를 this.textBox 로 지정한다. LINE 3: ref 를 통하여 input 의 값을 변경한다. 2. 적용하기이번엔 ref를 사용하기에 적절한 사례에 대하여 알아보겠다.예를들어, input과 버튼이 있고, 버튼을 누르면 input 을 초기화 하고 focus 를 해야 할 때는, ref 를 사용 해야만 한다. 1234567891011121314151617181920class Hello extends React.Component &#123; handleClick() &#123; this.input.value = &#x27;&#x27;; this.input.focus(); &#125; render() &#123; return ( &lt;div&gt; &lt;input ref=&#123;ref=&gt; this.input = ref&#125; /&gt; &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;Click Me&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Hello/&gt;, document.getElementById(&#x27;app&#x27;)); LINE 4: JavaScript DOM 메소드를 이용하여 인풋박스에 포커스를 하였다. LINE 10: ref를 설정하는 부분이다. ref를 사용하기 전엔 언제나 이를 사용 하지 않고 해결 할 수 있는 방안이 있는지 고려해보도록 하자. 참조 https://velopert.com/1148","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"SPA","slug":"Frontend/SPA","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/"},{"name":"React.js","slug":"Frontend/SPA/React-js","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/React-js/"}],"tags":[{"name":"react","slug":"react","permalink":"https://woonyzzang.github.com/tags/react/"}]},{"title":"React.js Component LifeCycle API","slug":"reactjs-component-lifecycle-api","date":"2017-10-04T14:01:37.000Z","updated":"2024-06-07T09:27:28.347Z","comments":true,"path":"2017/10/04/reactjs-component-lifecycle-api/","permalink":"https://woonyzzang.github.com/2017/10/04/reactjs-component-lifecycle-api/","excerpt":"","text":"React.js Component LifeCycle API이번에는 React.js 컴포넌트의 LifeCycle API 에 관하여 살펴보겠다.LifeCycle API는, 컴포넌트가 DOM 위에 생성되기 전 후 및 데이터가 변경되어 상태를 업데이트하기 전 후로 실행되는 메소드들 이다.이 메소드를 왜 쓰는것인가? 과연 쓸일이 있을까? 라고 생각할 수 있는데, 가끔 이를 사용하지 않으면 해결 할 수 없는 난관에 가끔 부딪치기도 때문에 잘 알아뒀다가 필요 할 때 사용하는것이 좋다.저번 편에서도 전화번호부를 구현 할 때, 인풋박스에 기본값을 전달 해 줄때와, 자원낭비를 줄이기 위하여 코드를 최적화 할 떄 LifeCycle API 가 사용되었다. 1. 시작하기123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; number: 0, show: false &#125; &#125; _increase() &#123; this.setState(&#123; number: this.state.number + 1 &#125;); &#125; _show() &#123; this.setState(&#123; show: true &#125;); &#125; _unmount() &#123; this.setState(&#123; number: 0, show: false &#125;); &#125; render()&#123; let component = (&lt;Card number=&#123;this.state.number&#125; /&gt;); return ( &lt;div&gt; &lt;Button caption=&quot;Show Card&quot; customClass=&quot;green&quot; onClick=&#123;this._show.bind(this)&#125; /&gt; &lt;Button caption=&quot;Increase Number&quot; customClass=&quot;blue&quot; onClick=&#123;this._increase.bind(this)&#125; /&gt; &lt;Button caption=&quot;Unmount Card&quot; customClass=&quot;red&quot; onClick=&#123;this._unmount.bind(this)&#125; /&gt; &#123;this.state.show ? component : &#x27;&#x27;&#125; &lt;/div&gt; ); &#125;&#125;class Button extends React.Component &#123; render() &#123; let className = &quot;ui button &quot; + this.props.customClass; return ( &lt;div onClick=&#123;this.props.onClick&#125;className=&#123;className&#125;&gt;&#123;this.props.caption&#125;&lt;/div&gt; ) &#125;&#125;class Card extends React.Component &#123; constructor(props) &#123; super(props); console.log(&#x27;constructor&#x27;); &#125; componentWillMount() &#123; console.log(&#x27;componentWillMount&#x27;); &#125; componentDidMount() &#123; console.log(&#x27;componentDidMount&#x27;); &#125; componentWillReceiveProps(nextProps) &#123; console.log(&#x27;componentWillReceiveProps: &#x27; + JSON.stringify(nextProps)); &#125; shouldComponentUpdate(nextProps, nextState) &#123; console.log(&#x27;shouldComponentUpdate: &#x27; + JSON.stringify(nextProps) + &#x27; &#x27; + JSON.stringify(nextState)); return true; &#125; componentWillUpdate(nextProps, nextState) &#123; console.log(&#x27;componentWillUpdate: &#x27; + JSON.stringify(nextProps) + &#x27; &#x27; + JSON.stringify(nextState)); &#125; componentDidUpdate(prevProps, prevState) &#123; console.log(&#x27;componentDidUpdate: &#x27; + JSON.stringify(prevProps) + &#x27; &#x27; + JSON.stringify(prevState)); &#125; componentWillUnmount() &#123; console.log(&#x27;componentWillUnmount&#x27;); &#125; render() &#123; console.log(&#x27;render&#x27;); return ( &lt;div className=&quot;ui card&quot;&gt; &lt;div className=&quot;content&quot;&gt; number: &#123;this.props.number&#125; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;App/&gt;, document.getElementById(&#x27;app&#x27;)); 컴포넌트를 생성 할 때는 constructor -&gt; componentWillMount -&gt; render -&gt; componentDidMount 순으로 진행된다.컴포넌트를 제거 할 때는 componentWillUnmount 메소드만 실행된다.컴포넌트의 prop이 변경될 때엔 componentWillReceiveProps -&gt; shouldComponentUpdate -&gt; componentWillUpdate-&gt; render -&gt; componentDidUpdate 순으로 진행됩니다.이 예제에는 없지만 state가 변경될 떄엔 props 를 받았을 때 와 비슷하지만 shouldComponentUpdate 부터 시작된다. 2. 정리LifeCycle API를 정리하면 다음과 같다. 3. 자세히 알아보기위 메소드들이 어떤 역할을 하는지 자세히 알아보자. constructor 1234constructor(props) &#123; super(props); console.log(&#x27;constructor&#x27;);&#125; 생성자 메소드로서 컴포넌트가 처음 만들어 질 때 실행된다.이 메소드에서 기본 state 를 정할 수 있다. componentWillMount 123componentWillMount() &#123; console.log(&#x27;componentWillMount&#x27;);&#125; 컴포넌트가 DOM 위에 만들어지기 전에 실행된다. render 컴포넌트 렌더링을 담당한다. componentDidMount 123componentDidMount() &#123; console.log(&#x27;componentDidMount&#x27;);&#125; 컴포넌트가 만들어지고 첫 렌더링을 다 마친 후 실행되는 메소드이다.이 안에서 다른 JavaScript 프레임워크를 연동하거나, setTimeout, setInterval 및 AJAX 처리 등을 넣는다. componentWillReceiveProps 123componentWillReceiveProps(nextProps) &#123; console.log(&#x27;componentWillReceiveProps: &#x27; + JSON.stringify(nextProps));&#125; 컴포넌트가 prop 을 새로 받았을 때 실행된다.prop 에 따라 state 를 업데이트 해야 할 때 사용하면 유용하다.이 안에서 this.setState() 를 해도 추가적으로 렌더링하지 않는다. shouldComponentUpdate 12345shouldComponentUpdate(nextProps, nextState) &#123; console.log(&#x27;shouldComponentUpdate: &#x27; + JSON.stringify(nextProps) + &#x27; &#x27; + JSON.stringify(nextState)); return true;&#125; prop 혹은 state 가 변경 되었을 때, 리렌더링을 할지 말지 정하는 메소드이다.위 예제에선 무조건 true 를 반환 하도록 하였지만, 실제로 사용 할 떄는 필요한 비교를 하고 값을 반환하도록 하시길 바란다.예: return nextProps.id !== this.props.id;JSON.stringify() 를 쓰면 여러 field 를 편하게 비교 할 수 있다. componentWillUpdate 123componentWillUpdate(nextProps, nextState) &#123; console.log(&#x27;componentWillUpdate: &#x27; + JSON.stringify(nextProps) + &#x27; &#x27; + JSON.stringify(nextState));&#125; 컴포넌트가 업데이트 되기 전에 실행된다.이 메소드 안에서는 this.setState() 를 사용하게 되면 무한루프에 빠져들게 되니 사용하지 않도록 하자. componentDidUpdate 123componentDidUpdate(prevProps, prevState) &#123; console.log(&#x27;componentDidUpdate: &#x27; + JSON.stringify(prevProps) + &#x27; &#x27; + JSON.stringify(prevState));&#125; 컴포넌트가 리렌더링을 마친 후 실행된다. componentWillUnmount 123componentWillUnmount()&#123; console.log(&quot;componentWillUnmount&quot;);&#125; 컴포넌트가 DOM 에서 사라진 후 실행되는 메소드이다. 참조 https://velopert.com/1130","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"SPA","slug":"Frontend/SPA","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/"},{"name":"React.js","slug":"Frontend/SPA/React-js","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/React-js/"}],"tags":[{"name":"react","slug":"react","permalink":"https://woonyzzang.github.com/tags/react/"}]},{"title":"React.js Immutability Helper","slug":"reactjs-immutability-helper","date":"2017-08-09T13:21:44.000Z","updated":"2024-06-07T09:27:28.351Z","comments":true,"path":"2017/08/09/reactjs-immutability-helper/","permalink":"https://woonyzzang.github.com/2017/08/09/reactjs-immutability-helper/","excerpt":"","text":"React.js Immutability Helper – State 내부 Array 에 원소 삽입&#x2F;제거&#x2F;수정컴포넌트에서 사용할 데이터 배열을 매핑하여 효율적으로 렌더링하는 방법에 이어 이번엔 데이터 배열에 변화를 주는 방법을 알아보도록 하겠다. 이 과정은 생각보다 쉽지만은 않다. 1. state 안의 array 에 원소 삽입&#x2F;제거&#x2F;수정this.state 에 포함된 배열에 원소를 삽입&#x2F;제거&#x2F;수정 을 할 때 그 배열에 직접 접근하면 안된다. 예를들어, 원소를 추가 할 때 배열객체의 push() 메소드를 사용하면 원하는대로 되지 않는다.this.state가 변경된다고해서 컴포넌트가 업데이트되지 않기 때문이다. 물론 변경 후 React 컴포넌트 API 인 forceUpdate()를 통하여 컴포넌트가 render()를 다시 실행 하게 끔 하는 방법이 있긴하지만 이건 절대 권장되지 않는 방법이다.React 메뉴얼 에서도 this.state를 직접 수정하지 말고 this.setState()를 사용하여 수정 할 것을 강조하고 있다. (이 메소드가 실행되면 자동으로 re-rendering 이 진행된다.) 1.1 원소 삽입하기state 내부의 배열에 원소를 추가하는 방법은 다음과 같다. 123this.setState(&#123; list: this.state.list.concat(newObj)&#125;); concat 을 사용함으로서 현재의 list 배열에 newObj 원소를 추가한 새로운 배열을 생성 한 후, 그 값을 현재의 list 로 설정한다. 배열을 수정 할 땐 원시적인 방법으론 위와 같이 배열 전체를 복사하고 처리 후 기존 값에 덮어씌우는 과정을 거쳐야 한다.허나, 만약에 배열의 크기가 클 땐 성능이 좀 저하될 것이다. 다른 방법으로는 Immutability Helpers 를 사용하는 방법이 있다.이는 배열을 더 효율적으로 수정 할 수 있게 해주는 페이스북의 Immutable-js 를 사용한다. 이를 사용하려면 라이브러리를 사전 설치해주어야 한다. React 구버전에서는 해당 라이브러리가 내장되어 import React from &#39;react/addons&#39;; 으로 React를 import 하여 React.addons.update() 를 사용 할 수 있었으나, 이제 이 방법은 deprecated 되었다.아직도 이렇게 사용은 가능 하나, 브라우저 상에서 ‘react-addon-update’ 를 import 하라고 권장하는 오류 메시지가 발생한다. 라이브러리 설치 방법 $ npm install --save react-addons-update 를 통하여 라이브러리를 저장 후, js 파일 상단에 import update from &#39;react-addons-update&#39; 를 삽입해 준다. 123this.setState(&#123; list: update(this.state.list, &#123;$push: [newObj, newObj2]&#125;)&#125;); update() 메소드의 첫 파라미터는 처리 할 배열이며 두번째는 처리 할 명령들을 지니고 있는 객체 타입 이다. $push: [newObj, newObj2]는 list 배열에 newObj 와 newObj2 를 추가해 준다.한 객체를 추가 할 때도 [] 안에 배열형태로 감싸 줘야 한다.Immutable-js 의 syntax 는 MongoDB 쿼리 언어에서 영감을 받았다고 한다.브라우저상에서 react-with-addons를 불러와서 사용하는 경우에는 update 가 아닌 React.addons.update 를 사용 해야 한다.(jsfiddle이 이에 해당한다.) 1.2 원소 제거하기원소를 제거 할 때 역시, state 의 배열에 직접 접근하면 안 되고, 배열을 복사한 후 원소 제거 후 기존 값에 덮어씌워져야 한다.JavaScript Array의 내장 함수인 splice()를 사용하면 되지만, 이는 생략하고 더 효율적인 Immutability Helper를 사용하는 예제를 알아 보겠디. 123this.setState(&#123; list: update(this.state.list, &#123;$splice: [[index, 1]]&#125;)&#125;); 위 코드는 list 배열의 index번째 아이템부터 시작해서 1개의 만큼의 데이터를 제거 한다.$splice 에 전달 되는 데이터는 배열로 이루어진 배열이다. 1.3 원소 수정하기Immutability Helper를 사용하여 특정 원소를 수정하는 예제를 살펴보자. 12345678this.setState(&#123; list: update(this.state.list, &#123; [index]: &#123; field: &#123;$set: &#x27;value&#x27;&#125;, field2: &#123;$set: &#x27;value2&#x27;&#125; &#125; &#125;&#125;); 위 코드는 list 배열의 index 번째 아이템의 field 와 field2 의 값을 변경 한다. 2. 적용하기그럼, 위에서 배운것들을 적용해보도록 하겠다.앞으로 만들 클래스는 다음과 같다. ContactCreator: Contact 를 생성하는 컴포넌트 ContactRemover: Contact 를 제거하는 컴포넌트 ContactEditor: Contact 를 수정하는 컴포넌트 앞으로 구현하고자 하는 기능은, 인풋박스에 입력하여 원하는 Contact를 추가 하고, 리스트에 있는 Contact를 선택하여 수정 및 제거를 하는 것 이다. 2.1 ContactCreator 컴포넌트 만들기위에서 배운것을 적용을 해보도록 하기위해, ContactInfo 를 생성하기 위해 필요한 텍스트박스 두개와 버튼 하나를 지니고있는 컴포넌트를 만들어 보자. 클래스는 강의 편의상 같은 파일에 작성하도록 하겠다. a. ContactCreator: 클래스 생성 및 렌더링 12345678910111213class ContactCreator extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;p&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; placeholder=&quot;name&quot; /&gt; &lt;input type=&quot;text&quot; name=&quot;phone&quot; placeholder=&quot;phone&quot; /&gt; &lt;button&gt;Insert&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; ); &#125;&#125; b. Contact: 렌더링 할 컴포넌트에 추가 1234567891011121314151617181920class Contacts extends React.Component &#123;/* ... */ render() &#123; return ( &lt;div&gt; &lt;h1&gt;Contacts&lt;/h1&gt; &lt;ul&gt; &#123;this.state.contactData.map((contact, i) =&gt; &#123; return ( &lt;ContactInfo name=&#123;contact.name&#125; phone=&#123;contact.phone&#125; key=&#123;i&#125; /&gt; ); &#125;)&#125; &lt;/ul&gt; &lt;ContactCreator/&gt; &lt;/div&gt; ); &#125;/* ... */ c. ContactCreator: Input 의 값을 컴포넌트의 state 로 사용하기 1234567891011class ContactCreator extends React.Component &#123; constructor(props) &#123; super(props); // Configure default state this.state = &#123; name: &#x27;&#x27;, phone: &#x27;&#x27; &#125;; &#125;/* ... */ 12&lt;input type=&quot;text&quot; name=&quot;name&quot; placeholder=&quot;name&quot; value=&#123;this.state.name&#125; /&gt;&lt;input type=&quot;text&quot; phone=&quot;phone&quot; placeholder=&quot;phone&quot; value=&#123;this.state.phone&#125; /&gt; 초기 state 값을 지정하고, 렌더링 부분 코드에서 input 의 value를 state를 사용하도록 수정한 후, 인풋박스에 텍스트를 적으려고 시도해보면 값이 고정되서 변경되지 않는다.이 부분을 해결하기 위하여, onChange 이벤트를 통하여 인풋박스에 텍스트를 입력 시 status 를 업데이트하도록 설정해야 한다. d. ContactCreator: onChange 이벤트 사용하기 12345678910class ContactCreator extends React.Component &#123;/* ... */ handleChange(e) &#123; var nextState = &#123;&#125;; nextState[e.target.name] = e.target.value; this.setState(nextState); &#125;/* ... */ 1234567891011&lt;input type=&quot;text&quot; name=&quot;name&quot; placeholder=&quot;name&quot; value=&#123;this.state.name&#125; onChange=&#123;this.handleChange.bind(this)&#125; /&gt;&lt;input type=&quot;text&quot; name=&quot;phone&quot; placeholder=&quot;phone&quot; value=&#123;this.state.phone&#125; onChange=&#123;this.handleChange.bind(this)&#125; /&gt; 인풋박스의 값을 변경 할 때 실행 될 handleChange(e) 메소드를 만들었다. 여기서 파라미터 e 는 JavaScript 의 Event 인터페이스이다.e 를 사용함으로서 한 메소드로 여러 인풋박스를 인풋박스의 name 에 따라 처리 할 수 있게된다.렌더링 부분의 코드를 보기 좋게 하기위해 줄바꿈을 하였으며 onChange=&#123;this.handleChange.bind(this)&#125;를 넣어주었다.인풋박스가 변경 될 때 해당 메소드를 실행한다는 의미 이다. bind 를 통하여 컴포넌트의 this 에 접근 할 수 있게 된다. e. ContactCreator: Insert 버튼 기능 구현하기 12345678910111213141516class ContactCreator extends React.Component &#123;/* ... */ handleClick()&#123; this.props.onInsert(this.state.name, this.state.phone); this.setState(&#123; name: &#x27;&#x27;, phone: &#x27;&#x27; &#125;); &#125;/* ... */&lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;Insert&lt;/button&gt;/* ... */ 버튼을 클릭 했을 때 실행 될 메소드를 만들었다. handleClick() 에서는 parent 컴포넌트인 Contacts 에서 props 로 받아온 메소드를 실행합니다. 그 후, 인풋 박스 값을 비운다. f. Contacts: _insertContact 메소드 만들기 123456789101112131415161718class Contacts extends React.Component &#123;/* ... */ _insertContact(name, phone)&#123; let newState = update(this.state, &#123; contactData: &#123; $push: [&#123;&#x27;name&#x27;: name, &#x27;phone&#x27;: phone&#125;] &#125; &#125;); this.setState(newState); &#125;/* ... */&lt;ContactCreator onInsert=&#123;this._insertContact.bind(this)&#125; /&gt;/* ... */ Immutability Helpers 를 사용하여 배열에 원소를 추가하였으며, _insertContact(name, phone) 메소드를 ContactCreator 의 prop 으로 전달 해 주었다.참고: jsfiddle 에선 React.addons.update 를 사용해아한다. 2.2 선택 기능 구현하기배열에서 데이터를 수정 하거나 제거 할 때 필요할 마우스로 선택하는 기능을 구현해보자. a. ContactInfo: handleClick() 메소드 및 onClick prop 추가 123456789101112class ContactInfo extends React.Component &#123; handleClick() &#123; this.props.onSelect(this.props.contactKey); &#125; render() &#123; return ( &lt;li onClick=&#123;this.handleClick.bind(this)&#125;&gt; &#123;this.props.name&#125; &#123;this.props.phone&#125; &lt;/li&gt; ); &#125; 해당 컴포넌트가 클릭되면 handleClick() 메소드가 실행되며, 이 메소드 내부에선 parent 컴포넌트에서 prop 으로 전달받은 onSelect() 메소드를 실행한다.여기서 인수 contactKey 는 해당 컴포넌트의 고유 번호이다.컴포넌트를 매핑할 때 key 를 사용하긴 하였으나, 이는 prop으로 간주되지 않으며 React 내부에서 사용하는 용도이기에 직접 접근이 불가하다. b. Contacts: _onSelect(), _isSelected() 메소드 추가 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Contacts extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; contactData: [ /* ... */ ], selectedKey: -1 &#125;; &#125; /* ... */ _onSelect(key) &#123; if (key === this.state.selectedKey) &#123; console.log(&#x27;key select cancelled&#x27;); this.setState(&#123; selectedKey: -1 &#125;); return; &#125; this.setState(&#123; selectedKey: key &#125;); console.log(key + &#x27; is selected&#x27;); &#125; _isSelected(key) &#123; if (this.state.selectedKey == key) &#123; return true; &#125; else &#123; return false; &#125; &#125; render() &#123; /* ... */ &#123;this.state.contactData.map((contact, i) =&gt; &#123; return ( &lt;ContactInfo key=&#123;i&#125; name=&#123;contact.name&#125; phone=&#123;contact.phone&#125; contactKey=&#123;i&#125; isSelected=&#123;this._isSelected.bind(this)(i)&#125; onSelect=&#123;this._onSelect.bind(this)&#125; /&gt; ); &#125;)&#125;/* ... */ state selectedKey 는 현재 선택된 컴포넌트의 고유번호 이다.만약에 선택된 Contact 가 없을 시에는 -1 로 설정된다._onSelect() 메소드는 컴포넌트가 클릭 될 때 실행 할 메소드 입니다. 선택 할 컴포넌트가 이미 선택되어있다면 선택을 해제한다.이 메소드는 child 컴포넌트의 onSelect prop 으로 전달된다._isSelect(key) 메소드는 child 컴포넌트에게 해당 컴포넌트가 선택된 상태인지 아닌지 알려준다.이 메소드를 실행 한 결과 값이 child 컴포넌트의 isSelected prop 으로 전달 된다. c. ContactInfo: 렌더링 시 선택된 상태라면 특정 스타일 적용 123456789101112131415161718192021class ContactInfo extends React.Component &#123;/* ... */ render() &#123; let getStyle = isSelect =&gt; &#123; if(!isSelect) return; let style = &#123; fontWeight: &#x27;bold&#x27;, backgroundColor: &#x27;#4efcd8&#x27; &#125;; return style; &#125;; return ( &lt;li style=&#123;getStyle(this.props.isSelected)&#125; onClick=&#123;this.handleClick.bind(this)&#125;&gt; &#123;this.props.name&#125; &#123;this.props.phone&#125; &lt;/li&gt; ); &#125;&#125; 5번 줄에서는 getStyle 이라는 함수를 선언했다. arrow function 이 사용되었는데, 매개변수가 오직 하나라면 괄호가 생략 될 수 있다.이 함수는 매개변수가 참이면 배경색이 아쿠아색인 스타일을 반환하며 거짓이면 비어있는 스타일을 반환한다.전에 JSX 에서 언급했었던 inline styling이 사용되었다. 2.3 ContactRemover 컴포넌트 만들기선택 기능이 구현 되었으니, 이 컴포넌트를 구현하는건 간단하다. a. ContactRemover: 컴포넌트 작성 12345678910111213class ContactRemover extends React.Component &#123; handleClick() &#123; this.props.onRemove(); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt; Remove selected contact &lt;/button&gt; ); &#125;&#125; 버튼이 클릭되면 handleClick() 메소드가 실행 되며, 해당 메소드에선 parent 컴포넌트에서 전달 받은 onRemove() 메소드가 실행됩니다. b. Contact: 렌더링 할 컴포넌트에 추가 123456class Contacts extends React.Component &#123;/* ... */ &lt;ContactCreator onInsert=&#123;this._insertContact.bind(this)&#125; /&gt; &lt;ContactRemover /&gt;/* .. */&#125; 렌더링 부분에 ContactCreator 하단에 &lt;ContactRemover /&gt; 를 추가한다 c. Contact: _removeContact() 메소드 작성 1234567891011121314151617class Contacts extends React.Component &#123;/* ... */ _removeContact() &#123; if (this.state.selectedKey == -1) &#123; console.log(&#x27;contact not selected&#x27;); return; &#125; this.setState(&#123; contactData: update( this.state.contactData, &#123;$splice: [[this.state.selectedKey, 1]]&#125; ), selectedKey: -1 &#125;); &#125;/* ... */ 선택한 Contact 를 제거하는 메소드 입니다. 선택된 Contact 가 없다면 작업을 취소한다.this.setState(...) 가 실행 되면 state contactData 에서 selectedKey번째 데이터를 제거하고 아무것도 선택하지 않은 상태로 설정한다.참고: jsfiddle을 사용한다면 React.addons.update 를 사용해야한다. d. Contact: ContactRemover 컴포넌트에 삭제 메소드 prop onRemove 으로 전달 1234class Contacts extends React.Component &#123;/* ... */&lt;ContactRemover onRemove=&#123;this._removeContact.bind(this)&#125;/&gt;/* ... */ 2.4 ContactEditor 만들기ContactEditor 에서 구현하고자 하는 기능은 다음과 같다. Contact를 선택하면 Contact 의 name 과 phone 데이터가 인풋박스로 복사됨 Edit 버튼을 누르면 Contacts 의 데이터를 수정함. 이 컴포넌트에서 사용 할 prop 들은 다음과 같다. isSelected: parent 컴포넌트에서 Contact가 선택 되어있는지 안되어있는지 알려준다. onEdit(): parent 컴포넌트에서 전달 받을 메소드로서, 데이터 수정 작업을 처리한다. contact: parent 컴포넌트에서 선택된 Contact의 name 과 phone 정보를 갖고있는 객체이다. a. ContactEditor: 컴포넌트 초기 작성이 컴포넌트의 코드 형태는 위에서 만든 ContactCreator 와 매우 비슷하다. ContactCreator 를 copy &amp; paste 하고 우선 필요한 부분만 수정하도록 하자. 1234567891011121314151617181920212223242526272829303132333435363738394041class ContactEditor extends React.Component &#123; constructor(props) &#123; super(props); // Configure default state this.state = &#123; name: &#x27;&#x27;, phone: &#x27;&#x27; &#125;; &#125; handleClick() &#123; &#125; handleChange(e) &#123; var nextState = &#123;&#125;; nextState[e.target.name] = e.target.value; this.setState(nextState); &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; placeholder=&quot;name&quot; value=&#123;this.state.name&#125; onChange=&#123;this.handleChange.bind(this)&#125; /&gt; &lt;input type=&quot;text&quot; name=&quot;phone&quot; placeholder=&quot;phone&quot; value=&#123;this.state.phone&#125; onChange=&#123;this.handleChange.bind(this)&#125; /&gt; &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;Edit&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; ); &#125;&#125; 코드를 붙여 넣은 후, 클래스 이름을 변경하고 handleClick() 에서 처리할 내용이 다르니 코드를 비워두자.이 컴포넌트는 수정하는 컴포넌트니까 버튼 캡션을 Edit 으로 변경해할 것이다. b. ContactEditor: handleClick() 메소드 작성 123456789101112class ContactEditor extends React.Component &#123;/* ... */ handleClick()&#123; if (!this.props.isSelected) &#123; console.log(&#x27;contact not selected&#x27;); return; &#125; this.props.onEdit(this.state.name, this.state.phone); &#125;/* ... */ 선택 된 Contact가 없다면 작업을 취소한다.onEdit() 은 parent 컴포넌트에서 전달 받을 메소드 이다. c. Contacts: _editContact 메소드 초기작성 렌더링 할 컴포넌트 추가 123456789class Contacts extends React.Component &#123;/* .. */ _editContact(name, phone)&#123; &#125;/* ... */ &lt;ContactRemover onRemove=&#123;this._removeContact.bind(this)&#125; /&gt; &lt;ContactEditor onEdit=&#123;this._editContact.bind(this)&#125; isSelected=&#123;(this.state.selectedKey !=-1)&#125; /&gt;/* ... */ _editContact() 메소드는 오류가 나지 않도록 초기 작성만하고 구현은 나중에 하도록 하겠습니다.ContactsRemover 컴포넌트 하단에 &lt;ContactEditor... /&gt;를 작성하세요.prop isSelected 은 JavaScript 표현식을 사용하여 selectedKey가 -1이 아니라면 true를, 맞다면 false를 반환합니다. d. 선택된 내용을 인풋박스로 복사하는 기능 구현하기 Contact 를 선택 하였을 때 내용을 ContactEditor 의 input 으로 복사되는 기능을 구현해보겠다.일단은 선택된 Contact 의 정보를 ContactEditor 로 전달을 해줘야할 것 이다.우선 선택된 Contact의 정보를 Contacts 의 state selected 에 저장하도록 하자. 123456789101112131415161718192021222324252627282930313233343536373839404142// Contacts:class Contacts extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; /* ... */ selectedKey: -1, selected: &#123; name: &#x27;&#x27;, phone: &#x27;&#x27; &#125; &#125;; &#125; _onSelect(key) &#123; if (key === this.state.selectedKey) &#123; console.log(&#x27;key select cancelled&#x27;); this.setState(&#123; selectedKey: -1, selected: &#123; name: &#x27;&#x27;, phone: &#x27;&#x27; &#125; &#125;); return; &#125; this.setState(&#123; selectedKey: key, selected: this.state.contactData[key] &#125;); console.log(key + &#x27; is selected&#x27;); &#125;/* ... */ &lt;ContactEditor onEdit=&#123;this._editContact.bind(this)&#125; isSelected=&#123;(this.state.selectedKey !=-1)&#125; contact=&#123;this.state.selected&#125; /&gt;/* ... */ 새로운 state 를 사용 할 땐, 언제나 초기 값을 설정해줘야한다. (그렇지 않으면 오류가 발생하기 쉽상이다.)Contact를 선택하였을 때 prop selected 에 값을 저장 하게하고, 선택을 취소 하였을 때, 값을 공백으로 설정하도록 하였다.그리고 이 prop selected 값을 ContactEditor 에 prop contact로 전달해준다. 이제 ContactEditor 에서 선택된 Contact의 값을 받아와서 렌더링해줘할 것이다.하지만, 인풋박스의 value 부분은 유동적이기에 그 부분에 {this.props.contact.name} 을 할 수는 없다.prop값이 바뀔 때마다 state를 업데이트 해줄 필요가 있는데요, 이는 Component Lifecycle API 중 하나인 componentWillReceiveProps()를 사용하면 된다. 이 컴포넌트 내장메소드는, prop 값을 받게 될 때 실행되는 메소드 이다. 12345678910// ContactEditor:class ContactEditor extends React.Component &#123;/* ... */ componentWillReceiveProps(nextProps) &#123; this.setState(&#123; name: nextProps.contact.name, phone: nextProps.contact.phone &#125;); &#125;/* ... */ e. Contacts: _editContact 메소드 구현하기 1234567891011121314151617181920class Contacts extends React.Component &#123;/* ... */ _editContact(name, phone) &#123; this.setState(&#123; contactData: update( this.state.contactData, &#123; [this.state.selectedKey]: &#123; name: &#123;$set: name&#125;, phone: &#123;$set: phone&#125; &#125; &#125; ), selected: &#123; name: name, phone: phone &#125; &#125;); &#125;/* ... */ 출력물123&lt;div id=&quot;container&quot;&gt; &lt;!-- This element&#x27;s contents will be replaced with your component. --&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266class App extends React.Component &#123; render() &#123; return (&lt;Contacts/&gt;); &#125;&#125;class Contacts extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; contactData: [ &#123;name: &#x27;Abet&#x27;, phone: &#x27;010-0000-0001&#x27;&#125;, &#123;name: &#x27;Betty&#x27;, phone: &#x27;010-0000-0002&#x27;&#125;, &#123;name: &#x27;Charlie&#x27;, phone: &#x27;010-0000-0003&#x27;&#125;, &#123;name: &#x27;David&#x27;, phone: &#x27;010-0000-0004&#x27;&#125; ], selectedKey: -1, selected: &#123; name: &#x27;&#x27;, phone: &#x27;&#x27; &#125; &#125;; &#125; _insertContact(name, phone) &#123; let newState = React.addons.update(this.state, &#123; contactData: &#123; $push: [&#123;&#x27;name&#x27;: name, &#x27;phone&#x27;: phone&#125;] &#125; &#125;); this.setState(newState); &#125; _onSelect(key) &#123; if (key == this.state.selectedKey) &#123; console.log(&#x27;key select cancelled&#x27;); this.setState(&#123; selectedKey: -1, selected: &#123; name: &#x27;&#x27;, phone: &#x27;&#x27; &#125; &#125;); return; &#125; this.setState(&#123; selectedKey: key, selected: this.state.contactData[key] &#125;); console.log(key + &#x27; is selected&#x27;); &#125; _isSelected(key) &#123; if (this.state.selectedKey == key) &#123; return true; &#125; else &#123; return false; &#125; &#125; _removeContact() &#123; if (this.state.selectedKey == -1) &#123; console.log(&#x27;contact not selected&#x27;); return; &#125; this.setState(&#123; contactData: React.addons.update( this.state.contactData, &#123; $splice: [[this.state.selectedKey, 1]] &#125; ), selectedKey: -1 &#125;); &#125; _editContact(name, phone) &#123; this.setState(&#123; contactData: React.addons.update( this.state.contactData, &#123; [this.state.selectedKey]: &#123; name: &#123;$set: name&#125;, phone: &#123;$set: phone&#125; &#125; &#125; ), selected: &#123; name: name, phone: phone &#125; &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Contacts&lt;/h1&gt; &lt;ul&gt; &#123;this.state.contactData.map((contact, i) =&gt; &#123; return ( &lt;ContactInfo key=&#123;i&#125; name=&#123;contact.name&#125; phone=&#123;contact.phone&#125; contactKey=&#123;i&#125; isSelected=&#123;this._isSelected.bind(this)(i)&#125; onSelect=&#123;this._onSelect.bind(this)&#125; /&gt; ); &#125;)&#125; &lt;/ul&gt; &lt;ContactCreator onInsert=&#123;this._insertContact.bind(this)&#125; /&gt; &lt;ContactRemover onRemove=&#123;this._removeContact.bind(this)&#125; /&gt; &lt;ContactEditor onEdit=&#123;this._editContact.bind(this)&#125; contact=&#123;this.state.selected&#125; /&gt; &lt;/div&gt; ); &#125;&#125;class ContactInfo extends React.Component &#123; handleClick() &#123; this.props.onSelect(this.props.contactKey); &#125; render() &#123; let getStyle = isSelect =&gt; &#123; if(!isSelect) return; let style = &#123; fontWeight: &#x27;bold&#x27;, backgroundColor: &#x27;#4efcd8&#x27; &#125;; return style; &#125;; return ( &lt;li style=&#123;getStyle(this.props.isSelected)&#125; onClick=&#123;this.handleClick.bind(this)&#125;&gt; &#123;this.props.name&#125; &#123;this.props.phone&#125; &lt;/li&gt; ); &#125;&#125;class ContactCreator extends React.Component &#123; constructor(props) &#123; super(constructor); // Configure default state this.state = &#123; name: &#x27;&#x27;, phone: &#x27;&#x27; &#125;; &#125; handleClick() &#123; this.props.onInsert(this.state.name, this.state.phone); this.setState(&#123; name: &#x27;&#x27;, phone: &#x27;&#x27; &#125;); &#125; handleChange(e) &#123; var nextState = &#123;&#125;; nextState[e.target.name] = e.target.value; this.setState(nextState); &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; placeholder=&quot;name&quot; value=&#123;this.state.name&#125; onChange=&#123;this.handleChange.bind(this)&#125; /&gt; &lt;input type=&quot;text&quot; name=&quot;phone&quot; placeholder=&quot;phone&quot; value=&#123;this.state.phone&#125; onChange=&#123;this.handleChange.bind(this)&#125; /&gt; &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;Insert&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; ); &#125;&#125;class ContactRemover extends React.Component &#123; handleClick() &#123; this.props.onRemove(); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt; Remove selected contact &lt;/button&gt; ); &#125;&#125;class ContactEditor extends React.Component &#123; constructor(props) &#123; super(constructor); // Configure default state this.state = &#123; name: &#x27;&#x27;, phone: &#x27;&#x27; &#125;; &#125; handleClick() &#123; if (!this.props.isSelected) &#123; console.log(&#x27;contact not selected&#x27;); return; &#125; this.props.onEdit(this.state.name, this.state.phone); &#125; handleChange(e) &#123; var nextState = &#123;&#125;; nextState[e.target.name] = e.target.value; this.setState(nextState); &#125; componentWillReceiveProps(nextProps) &#123; this.setState(&#123; name: nextProps.contact.name, phone: nextProps.contact.phone &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; placeholder=&quot;name&quot; value=&#123;this.state.name&#125; onChange=&#123;this.handleChange.bind(this)&#125; /&gt; &lt;input type=&quot;text&quot; name=&quot;phone&quot; placeholder=&quot;phone&quot; value=&#123;this.state.phone&#125; onChange=&#123;this.handleChange.bind(this)&#125; /&gt; &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;Edit&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;container&#x27;)); 3. CPU 자원낭비 줄이기원하고자 하는 기능은 모두 구현하였지만, 사실 위에서 작성한 코드는 CPU 자원을 낭비하고있다.비록 큰데이터를 다루는게 아니기 때문에 성능에 큰 영향을 끼치지는 않고 있지만 코드의 완성도를 위하여 컴포넌트를 최적화해보겠다. 3.1 무엇이 문제인가..데이터가 수정 될 때 마다, 상태에 변동이 없는, 즉 리렌더링 할 필요가 없는 컴포넌트들도 리렌더링이 되고있다.한번 ContactInfo 컴포넌트의 render() 메소드에 코드 console.log(&#39;rendered: &#39; + this.props.name); 를 추가해보자. 123456// ContactInfo:class ContactInfo extends React.Component &#123;/* ... */ render() &#123; console.log(&quot;rendered: &quot; + this.props.name);/* ... */ 그리고 Contact들을 선택해보고, 추가해보고 수정해보자. 보다시피, 쓸데없는 렌더링을 하고있는걸 확인할 수 있다. 3.2 해결하기자, 그럼 이제 해결해보도록 하자. 해결법은 매우 간단하다.Component Lifecycle API 중 하나인 shouldComponentUpdate() 메소드를 컴포넌트 클래스 안에 작성해주면 된다.이 메소드는 컴포넌트를 다시 렌더링 해야 할 지 말지 정의를 해준다. 123456class ContactInfo extends React.Component &#123;/* ... */ shouldComponentUpdate(nextProps, nextState) &#123; return (JSON.stringify(nextProps) !== JSON.stringify(this.props)); &#125; /* ... */ 자, 이제 필요한 컴포넌트만 렌더링하게 된다.이와 같이, 컴포넌트를 Mapping 하고 데이터를 수정 할 떄 코드를 최적화 하는것을 잊지 않도록 하자. 참조 https://velopert.com/1015","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"SPA","slug":"Frontend/SPA","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/"},{"name":"React.js","slug":"Frontend/SPA/React-js","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/React-js/"}],"tags":[{"name":"react","slug":"react","permalink":"https://woonyzzang.github.com/tags/react/"}]},{"title":"React.js Component Map","slug":"reactjs-component-map","date":"2017-07-13T21:35:39.000Z","updated":"2024-06-07T09:27:28.348Z","comments":true,"path":"2017/07/14/reactjs-component-map/","permalink":"https://woonyzzang.github.com/2017/07/14/reactjs-component-map/","excerpt":"","text":"React.js Component Iteration (반복) – MapReact.js 에서 다른 데이터를 지니고있는 같은 종류의 여러 컴포넌트를 효율적으로 렌더링 하는 방법에 대하여 알아보도록 하겠다. 1. JavaScript – Array.prototype.map우선, JavaScript 의 Array 객체 내장함수인 map 함수에 대하여 알아보자. 정의 map() 메소드는 파라미터로 전달 된 함수를 통하여 배열 내의 각 요소를 프로세싱 하여 그 결과로 새로운 배열을 생성한다. 문법 1arr.map(callback, [thisArg]); 파라미터 callback 새로운 배열의 요소를 생성하는 함수로서, 다음 세가지 인수를 가진다. currentValue 현재 처리되고 있는 요소 index 현재 처리되고 있는 요소의 index 값 array 메소드가 불려진 배열 thisArg (선택항목) callback 함수 내부에서 사용 할 this 값을 설정 예제 배열 [1, 2, 3, 4, 5] 의 각 요소를 제곱하여 새로운 배열을 생성하는 예제를 살펴보자. 1234567var numbers = [1, 2, 3, 4, 5];var processed = numbers.map(function(num) &#123; return num*num;&#125;);// 결과: [1, 4, 9, 16, 25] 위 코드를 ES6 문법으로 작성하면 다음과 같습니다. 123let numbers = [1, 2, 3, 4, 5];let result = numbers.map((num) =&gt; &#123;return num*num&#125;); 이 코드에서 사용된 ( ) &#x3D;&gt; { } 은 ES6 에 새로 도입된 arrow function 이다. 자세한 설명은 Mozilla 참고자료를 참조하자. 2. 컴포넌트 mapping이번엔 데이터 배열을 mapping 하여 컴포넌트 배열로 변환하는 과정을 살펴보도록 하겠다.React.js 작업환경이 설정되었다는 가정하에 진행하도록 한다. 편의상 컴포넌트들을 App.js에 모두 작성한다. src&#x2F;components&#x2F;App.js 12345678910111213141516171819202122232425262728import React from &#x27;react&#x27;;class App extends React.Component &#123; render()&#123; return ( &lt;Contacts/&gt; ); &#125;&#125;class Contacts extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Contacts&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Abet 010-0000-0001&lt;/li&gt; &lt;li&gt;Betty 010-0000-0002&lt;/li&gt; &lt;li&gt;Chalie 010-0000-0003&lt;/li&gt; &lt;li&gt;David 010-0000-0003&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125;export default App; 위의 코드는 전화번호부 기능을 하는 예제 컴포넌트 이다. 19-22번줄, 비슷한 코드가 반복되고 있다. 지금 당장은 큰 문제가 없지만, 저기에 나올 데이터가 유동적이라면 그때그때 하드코딩 하게 될 것이다. 이 문제점을 React 스럽게 해결해보도록 하자. 2.2 ContactInfo 컴포넌트 만들기ContactInfo 클래스 생성 (Contacts 클래스 하단) 1234567class ContactInfo extends React.Component &#123; render() &#123; return ( &lt;li&gt;&#123;this.props.name&#125; &#123;this.props.phone&#125;&lt;/li&gt; ); &#125;&#125; 이름과 전화번호가 나타날 부분에 props 를 사용하였다. Contacts 컴포넌트 렌더링 부분 수정 12345678910111213render() &#123; return ( &lt;div&gt; &lt;h1&gt;Contacts&lt;/h1&gt; &lt;ul&gt; &lt;ContactInfo name=&quot;Abet&quot; phone=&quot;010-0000-0001&quot;/&gt; &lt;ContactInfo name=&quot;Betty&quot; phone=&quot;010-0000-0002&quot;/&gt; &lt;ContactInfo name=&quot;Charlie&quot; phone=&quot;010-0000-0003&quot;/&gt; &lt;ContactInfo name=&quot;David&quot; phone=&quot;010-0000-0004&quot;/&gt; &lt;/ul&gt; &lt;/div&gt; );&#125; html 코드를 컴포넌트 형태로 변환하여 작성하였다.아직 크게 달라진건 없다. 같은 코드를 반복해서 사용하는건 마찬가지이다. 2.3 mapping데이터를 매핑해보도록 하자. 기본 state 추가 (Contacts 클래스 내부) 1234567891011constructor(props) &#123; super(props); this.state = &#123; contactData: [ &#123;name: &quot;Abet&quot;, phone: &quot;010-0000-0001&quot;&#125;, &#123;name: &quot;Betty&quot;, phone: &quot;010-0000-0002&quot;&#125;, &#123;name: &quot;Charlie&quot;, phone: &quot;010-0000-0003&quot;&#125;, &#123;name: &quot;David&quot;, phone: &quot;010-0000-0004&quot;&#125; ] &#125;;&#125; state 는 컴포넌트에서 유동적인 데이터를 다룰 때 사용된다. 렌더링 부분 배열 mapping 으로 교체 123456789101112render() &#123; return ( &lt;div&gt; &lt;h1&gt;Contacts&lt;/h1&gt; &lt;ul&gt; &#123;this.state.contactData.map((contact, i) =&gt; &#123; return (&lt;ContactInfo name=&#123;contact.name&#125; phone=&#123;contact.phone&#125; key=&#123;i&#125;/&gt;); &#125;)&#125; &lt;/ul&gt; &lt;/div&gt; );&#125; 9번 줄에서 key 가 사용되었는데, 이는 child 컴포넌트에 identity (독자성) 을 부여해준다. 최종 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445import React from &#x27;react&#x27;;class App extends React.Component &#123; render() &#123; return ( &lt;Contacts/&gt; ); &#125;&#125;class Contacts extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; contactData: [ &#123;name: &quot;Abet&quot;, phone: &quot;010-0000-0001&quot;&#125;, &#123;name: &quot;Betty&quot;, phone: &quot;010-0000-0002&quot;&#125;, &#123;name: &quot;Charlie&quot;, phone: &quot;010-0000-0003&quot;&#125;, &#123;name: &quot;David&quot;, phone: &quot;010-0000-0004&quot;&#125; ] &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Contacts&lt;/h1&gt; &lt;ul&gt; &#123;this.state.contactData.map((contact, i) =&gt; &#123; return (&lt;ContactInfo name=&#123;contact.name&#125; phone=&#123;contact.phone&#125; key=&#123;i&#125;/&gt;); &#125;)&#125; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125;class ContactInfo extends React.Component &#123; render() &#123; return ( &lt;li&gt;&#123;this.props.name&#125; &#123;this.props.phone&#125;&lt;/li&gt; ); &#125;&#125;export default App; 출력물 참조 https://velopert.com/957","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"SPA","slug":"Frontend/SPA","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/"},{"name":"React.js","slug":"Frontend/SPA/React-js","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/React-js/"}],"tags":[{"name":"react","slug":"react","permalink":"https://woonyzzang.github.com/tags/react/"}]},{"title":"React.js Component State Props","slug":"reactjs-component-state-props","date":"2017-07-13T21:16:12.000Z","updated":"2024-06-07T09:27:28.349Z","comments":true,"path":"2017/07/14/reactjs-component-state-props/","permalink":"https://woonyzzang.github.com/2017/07/14/reactjs-component-state-props/","excerpt":"","text":"React.js Component의 State 와 Props 사용하기React.js 의 Component 에서 사용 할 데이터를 다루는 State 와 Props 에 대하여 알아보도록 하겠다. 1. 시작하기Component 생성 및 모듈화 에서 사용하던 프로젝트를 계속해서 이어서 작성한다. index.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;React App&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; index.js 123456import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import App from &#x27;./components/App&#x27;; const rootElement = document.getElementById(&#x27;root&#x27;); ReactDOM.render(&lt;App /&gt;, rootElement); src&#x2F;components&#x2F;App.js 123456789101112131415import React from &#x27;react&#x27;;import Header from &#x27;./Header&#x27;;import Content from &#x27;./Content&#x27;;class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;Header/&gt; &lt;Content/&gt; &lt;/div&gt; ); &#125;&#125;export default App; src&#x2F;components&#x2F;Header.js 1234567891011import React from &#x27;react&#x27;;class Header extends React.Component &#123; render() &#123; return ( &lt;h1&gt;Header&lt;/h1&gt; ); &#125;&#125;export default Header; src&#x2F;components&#x2F;Content.js 1234567891011121314import React from &#x27;react&#x27;;class Content extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h2&gt;Content&lt;/h2&gt; &lt;p&gt; Hey! &lt;/p&gt; &lt;/div&gt; ); &#125;&#125;export default Content; 2. propsprops 는 컴포넌트에서 사용 할 데이터 중 변동되지 않는 데이터를 다룰 때 사용된다. parent 컴포넌트에서 child 컴포넌트로 데이터를 전할 때, props 가 사용된다. 예제를 통하여 이에 대하여 알아보겠다. 2.1 props 추가하기 컴포넌트에서 immutable (변하지 않는) 데이터가 필요 할 땐, render() 메소드의 내부에 안에 &#123; this.props.propsName &#125; 형식으로 넣고, 컴포넌트를 사용 할 때, &lt; &gt; 괄호 안에 propsName=&quot;value&quot; 를 넣어 값을 설정한다. Header 컴포넌트와 Content 컴포넌트가 props를 사용하도록 코드를 업데이트 해보도록 하자. Header.js 1234567891011import React from &#x27;react&#x27;; class Header extends React.Component &#123; render() &#123; return ( &lt;h1&gt;&#123; this.props.title &#125;&lt;/h1&gt; ); &#125;&#125;export default Header; 위와 같이 props 값이 렌더링 될 위치에 &#123; this.props.propsName &#125; 를 넣는다. Content.js 1234567891011121314import React from &#x27;react&#x27;; class Content extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h2&gt;&#123; this.props.title &#125;&lt;/h2&gt; &lt;p&gt; &#123; this.props.body &#125; &lt;/p&gt; &lt;/div&gt; ); &#125;&#125;export default Content; contentTitle 와 contentBody props 를 넣어주었다. 2.2 props 사용하기이제 App 컴포넌트에도 props 를 넣어주고, App 컴포넌트에서 사용되는 props 값을 child 컴포넌트들로 전달해도록 하자. App.js 1234567891011121314151617import React from &#x27;react&#x27;;import Header from &#x27;./Header&#x27;;import Content from &#x27;./Content&#x27;;class App extends React.Component &#123; render()&#123; return ( &lt;div&gt; &lt;Header title=&#123; this.props.headerTitle &#125;/&gt; &lt;Content title=&#123; this.props.contentTitle &#125; body=&#123; this.props.contentBody &#125;/&gt; &lt;/div&gt; ); &#125;&#125;export default App; index.js 12345678import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import App from &#x27;./components/App&#x27;; const rootElement = document.getElementById(&#x27;root&#x27;); ReactDOM.render(&lt;App headerTitle = &quot;Welcome!&quot; contentTitle = &quot;Stranger,&quot; contentBody = &quot;Welcome to example app&quot;/&gt;, rootElement); 2.3 기본 값 설정하기props 값을 임의로 지정해주지 않았을 때 사용할 기본값을 설정하는 방법을 알아보도록 하겠다. 기본값을 설정 할 땐, 컴포넌트 클래스 하단에 className.defaultProps = &#123; propName: value &#125; 를 삽입하면 된다. App.js 123456789101112131415161718192021222324import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import Header from &#x27;./Header&#x27;;import Content from &#x27;./Content&#x27;;class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;Header title=&#123; this.props.headerTitle &#125;/&gt; &lt;Content title=&#123; this.props.contentTitle &#125; body=&#123; this.props.contentBody &#125;/&gt; &lt;/div&gt; ); &#125;&#125;App.defaultProps = &#123; headerTitle: &#x27;Default header&#x27;, contentTitle: &#x27;Default contentTitle&#x27;, contentBody: &#x27;Default contentBody&#x27;&#125;;export default App; index.js 123456import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import App from &#x27;./components/App&#x27;; const rootElement = document.getElementById(&#x27;root&#x27;); ReactDOM.render(&lt;App /&gt;, rootElement); 2.4 Type 검증(Validate)하기컴포넌트 에서 원하는 props 의 Type 과 전달 된 props 의 Type 이 일치하지 않을 때 콘솔에서 오류 메시지가 나타나게 하고 싶을 땐, 컴포넌트 클래스의 propTypes 객체를 설정하면 된다. 또한, 이를 통하여 필수 props 를 지정할 수 있다. 즉, props 를 지정하지 않으면 콘솔에 오류 메시지가 나타나게 된다. 한번 Content 컴포넌트의 propTypes을 지정 해보도록 하자. Content.js 12345678910111213141516171819import React from &#x27;react&#x27;;class Content extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h2&gt;&#123; this.props.title &#125;&lt;/h2&gt; &lt;p&gt; &#123; this.props.body &#125; &lt;/p&gt; &lt;/div&gt; ); &#125;&#125;Content.propTypes = &#123; title: React.PropTypes.string, body: React.PropTypes.string.isRequired&#125;;export default Content; 두 props 의 Type 를 모두 string 을 지정하고, body는 .isRequired 를 추가하여 필수 props 로 설정하였다. 이제 App 컴포넌트에서 잘못된 값을 줘보도록 하겠다. App.js 1234567891011121314151617181920212223import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import Header from &#x27;./Header&#x27;;import Content from &#x27;./Content&#x27;;class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;Header title=&#123; this.props.headerTitle &#125;/&gt; &lt;Content title=&#123; this.props.contentTitle &#125; body=&#123; this.props.contentBody &#125;/&gt; &lt;/div&gt; ); &#125;&#125;App.defaultProps = &#123; headerTitle: &#x27;Default header&#x27;, contentTitle: 5, contentBody: undefined&#125;;export default App; contentTitle 엔 숫자를 지정하였고, contentBody에는 빈 값을 전달하도록 설정하였다. Validation이 실패하면 브라우저에서 다음과 같은 오류가 나타난다. 테스트가 끝나면 2.3 의 App.js 상태로 되돌리도록 하자. 예제 예제를 통하여 여러 종류의 Type 를 Validate 하는 방법을 알아보도록 하겠습니다. (reference: React.js 메뉴얼 API) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import React from &#x27;react&#x27;;class ValidationExample extends React.Component &#123; /* ... */&#125;Content.propTypes = &#123; // JS primitive types optionalArray: React.PropTypes.array, optionalBool: React.PropTypes.bool, optionalFunc: React.PropTypes.func, optionalNumber: React.PropTypes.number, optionalObject: React.PropTypes.object, optionalString: React.PropTypes.string, // anything that can be rendered ( numbers, string, elements, array, fragment) optionalNode: React.PropTypes.node, // React element optionalElement: React.PropTyps.element, // instance of specific class optionalMessage: React.PropTypes.instanceOf(Message), // limited to specific values optionalEnum: React.PropTypes.oneOf([&#x27;News&#x27;, &#x27;Photos&#x27;]), // one of many types optionalUnion: React.PropTypes.oneOfType([ React.PropTypes.string, React.propTypes.number ]), // array of specific type optionalArrayOf: React.PropTypes.arrayOf(React.PropTypes.number), // object with property values of a certain type optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number), // object with particular shape optionalObjectWithShape: React.PropTypes.shape(&#123; color: React.PropTypes.string, fontSize: React.PropTypes.number &#125;), // Required function requiredFunc: React.PropTypes.func.isRequired, // Required prop with any data type requiredAny: React.PropTypes.any.isRequired, // custom validator customProp: function(props, propName, componentName) &#123; if (!/matchme/.test(props[propName])) &#123; return new Error(&#x27;Validation failed!&#x27;); &#125; &#125;&#125;;/* ... */export default ValidationExample; 3. State컴포넌트에서 유동적인 데이터를 다룰 때, state 를 사용한다. React.js 어플리케이션을 만들 땐, state를 사용하는 컴포넌트의 갯수를 최소화 하는 것 을 노력해야 한다. 예를들어, 10 개의 컴포넌트에서 유동적인 데이터를 사용 하게 될 땐, 각 데이터에 state를 사용 할 게 아니라, props 를 사용하고 10 개의 컴포넌트를 포함시키는 container 컴포넌트를 사용하는것이 효율적 이다. 3.1 기본적인 사용 방법StateExample.js (미리보기: JSFiddle) 123456789101112131415161718192021222324252627282930import React from &#x27;react&#x27;;class StateExample extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; header: &quot;Header Initial state&quot;, content: &quot;Content Initial State&quot; &#125;; &#125; updateHeader(text)&#123; this.setState(&#123; header: &quot;Header has changed&quot; &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;&#123;this.state.header&#125;&lt;/h1&gt; &lt;h2&gt;&#123;this.state.content&#125;&lt;/h2&gt; &lt;button onClick=&#123;this.updateHeader.bind(this)&#125;&gt;Update&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default StateExample; state 의 초기 값을 설정 할 때는 constructor(생성자) 메소드에서 this.state= &#123; &#125; 를 통하여 설정한다. state 를 렌더링 할 때는 &#123; this.state.stateName &#125; 을 사용한다. state 를 업데이트 할 때는 this.setState() 메소드를 사용한다. ES6 class에선 auto binding이 되지 않으므로, setState 메소드를 사용 하게 될 메소드를 bind 해주어야 한다. (bind 하지 않으면 React Component 가 가지고있는 멤버 함수 및 객체에 접근 할 수 없다.) 4. 적용: State 와 Props유동적인 데이터를 렌더링하며, parent 컴포넌트와 communicate 하는 예제 컴포넌트 RandomNumber 를 만들어 보도록 하자. RandomNumber.js 12345678910111213141516171819202122232425import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;class RandomNumber extends React.Component &#123; updateNumber() &#123; let value = Math.round(Math.random()*100); this.props.onUpdate(value); &#125; constructor(props) &#123; super(props); this.updateNumber = this.updateNumber.bind(this); &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;RANDOM NUMBER: &#123; this.props.number &#125;&lt;/h1&gt; &lt;button onClick=&#123;this.updateNumber&#125;&gt;Randomize&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default RandomNumber; 랜덤 숫자를 나타내는 h1 element와, 클릭 하면 새로운 랜덤값으로 바꾸는 button element를 렌더링 한다. 이 컴포넌트에서는 두가지 prop을 사용한다. number: 랜덤 값 onUpdate: function 형태의 prop 으로서, parent 컴포넌트에 정의된 메소드를 실행 할 수 있게 한다. 코드 설명 Line 8: props 로 받은 함수를 실행한다. Line 11 ~ 14: React 컴포넌트의 생성자 이다. super(props) 로 상속받은 React.Component 의 생성자 메소드를 실행 한 후, 입력한 코드를 실행한다. 13번 줄에서는 update 메소드에서 this.props 에 접근 할 수 있도록 binding 을 해준다. Line 20: 버튼을 클릭하였을 시 update() 메소드를 실행한다. 이제, parent 컴포넌트인 App 컴포넌트에서 RandomNumber 컴포넌트를 사용해보도록 하자. App.js 1234567891011121314151617181920212223242526272829303132333435363738394041import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import Header from &#x27;./Header&#x27;;import Content from &#x27;./Content&#x27;;import RandomNumber from &#x27;./RandomNumber&#x27;;class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: Math.round(Math.random()*100) &#125;; this.updateValue = this.updateValue.bind(this); &#125; updateValue(randomValue) &#123; this.setState(&#123; value: randomValue &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;Header title=&#123; this.props.headerTitle &#125;/&gt; &lt;Content title=&#123; this.props.contentTitle &#125; body=&#123; this.props.contentBody &#125;/&gt; &lt;RandomNumber number=&#123;this.state.value&#125; onUpdate=&#123;this.updateValue&#125; /&gt; &lt;/div&gt; ); &#125;&#125;App.defaultProps = &#123; headerTitle: &#x27;Default header&#x27;, contentTitle: &#x27;Default contentTitle&#x27;, contentBody: &#x27;Default contentBody&#x27;&#125;;export default App; 코드 설명 Line 5: RandomNumber.js 를 import 한다. Line 12: 초기 state 를 설정한다. Line 16: updateValue() 메소드에서 this.setState 에 접근 할 수 있도록 bind 한다. Line 20~22: state 를 변경 할 때는 setState({key: value}) 메소드 를 사용한다. Line 31-32: RandomNumber 컴포넌트를 사용한다. 출력물 props 와 state, 생긴건 비슷하지만 용도는 다르니 헷갈리지 않도록 다음 특성을 기억하자. 특성 props state parent 컴포넌트에 의해 값이 변경 될 수 있는가? 예 아니오 컴포넌트 내부에서 변경 될 수 있는가? 아니오 예 참조 https://velopert.com/921","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"SPA","slug":"Frontend/SPA","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/"},{"name":"React.js","slug":"Frontend/SPA/React-js","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/React-js/"}],"tags":[{"name":"react","slug":"react","permalink":"https://woonyzzang.github.com/tags/react/"}]},{"title":"React.js Component Module","slug":"reactjs-component-module","date":"2017-07-13T21:08:44.000Z","updated":"2024-06-07T09:27:28.349Z","comments":true,"path":"2017/07/14/reactjs-component-module/","permalink":"https://woonyzzang.github.com/2017/07/14/reactjs-component-module/","excerpt":"","text":"React.js Component 생성 및 모듈화React.js 에서 사용되는 Component 를 생성하고, 이를 모듈화 하는 방법을 알아보도록 하겠다. Component 생성 및 모듈화다음 index.js 파일은, 이전 포스트에서 만든걸 이어서 진행한다. src&#x2F;index.js 123456import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import App from &#x27;./components/App&#x27;;const rootElement = document.getElementById(&#x27;root&#x27;); ReactDOM.render(&lt;App /&gt;, rootElement); 먼저, React 어플리케이션 의 기반이 될 App.js 파일을 수정한다. src&#x2F;components&#x2F;App.js 1234567891011121314import React from &#x27;react&#x27;;class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;Header/&gt; &lt;Content/&gt; &lt;/div&gt; ); &#125;&#125;export default App; 컴포넌트를 만들때는 React.Component 클래스를 상속하여 만든다.7-8 에있는 &lt;Header/&gt; 와 &lt;Content/&gt; 는 앞으로 우리가 만들 컴포넌트 이다. 한 파일엔 여러개의 컴포넌트가 존재 할 수 있다. 그럼, App.js 파일을 업데이트 해보도록 한다. src&#x2F;components&#x2F;App.js [+1] 123456789101112131415161718192021222324252627282930313233import React from &#x27;react&#x27;;class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;Header/&gt; &lt;Content/&gt; &lt;/div&gt; ); &#125;&#125;class Header extends React.Component &#123; render() &#123; return ( &lt;h1&gt;Header&lt;/h1&gt; ); &#125;&#125;class Content extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h2&gt;Content&lt;/h2&gt; &lt;p&gt; Hey! &lt;/p&gt; &lt;/div&gt; ); &#125;&#125;export default App; 이렇게 여러 class를 포함시켜 작성 할 수 있지만, 어플리케이션의 규모가 커지면 유지&#x2F;보수가 불편해질 것이다. Component들을 모듈화 하여 여러 파일로 분리해서 사용하면 유지 보수가 훨씬 쉬워진다. 이 개념은 Node.js 의 모듈화와 동일하다. Header.js 파일을 생성하고, App.js의 15~21 줄을 잘라내서 삽입한다. src&#x2F;components&#x2F;Header.js 123456789101112import React from &#x27;react&#x27;; class Header extends React.Component &#123; render() &#123; return ( &lt;h1&gt;Header&lt;/h1&gt; ); &#125;&#125;export default Header; 모듈에서도 react 를 import 해주어야 한다. 이 키워드에 대한 자세한 정보는 Mozilla 참고자료 에서 확인 할 수 있다. 이제 Content 컴포넌트를 모듈화 해보도록 하겠다. 과정은 위와 같으니 설명은 생략한다. src&#x2F;components&#x2F;Content.js 1234567891011121314import React from &#x27;react&#x27;;class Content extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h2&gt;Content&lt;/h2&gt; &lt;p&gt; Hey! &lt;/p&gt; &lt;/div&gt; ); &#125;&#125;export default Content; 모듈들을 export 했으니 App.js 에서 import 도 해야 될 것이다. App.js 를 다음과 같이 업데이트 한다. src&#x2F;components&#x2F;App.js [+2] 12345678910111213141516import React from &#x27;react&#x27;;import Header from &#x27;./Header&#x27;;import Content from &#x27;./Content&#x27;;class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;Header/&gt; &lt;Content/&gt; &lt;/div&gt; ); &#125;&#125;export default App; 3~4번에 있는 import 를 통하여 해당 모듈들을 App.js 에서 사용한다. 출력물 참조 https://velopert.com/900","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"SPA","slug":"Frontend/SPA","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/"},{"name":"React.js","slug":"Frontend/SPA/React-js","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/React-js/"}],"tags":[{"name":"react","slug":"react","permalink":"https://woonyzzang.github.com/tags/react/"}]},{"title":"React.js JSX Syntax","slug":"reactjs-jsx","date":"2017-07-13T21:05:12.000Z","updated":"2024-06-07T09:27:28.353Z","comments":true,"path":"2017/07/14/reactjs-jsx/","permalink":"https://woonyzzang.github.com/2017/07/14/reactjs-jsx/","excerpt":"","text":"React.js JSX 문법React.js 는 일반 JavaScript 문법이 아닌 JSX 문법을 사용하여 UI를 템플릿화 한다. JSX를 사용하는것이 필수는 아니지만 이를 사용하면 다음과 같은 장점이 있다. JSX는 컴파일링 되면서 최적화 되므로, 빠르다 Type-safe (어떠한 연산도 정의되지 않은 결과를 내놓지 않는것, 즉 예측 불가능한 결과를 나타내지 않는 것) 하며 컴파일링 과정에서 에러를 감지 할 수 있다. HTML에 익숙하다면, JSX를 사용하여 더 쉽고 빠르게 템플릿을 작성 할 수 있다. type-safe 란“어떠한 오퍼레이션(또는 연산)도 정의되지 않은 결과를 내놓지 않는것, 즉, 예측불가능한 결과를 내지 않는것을 뜻한다.” 예를 들면, 1 + “1” 의 연산이 가능하거나, 문자열에 숫자 1을 할당하는것이 가능하다거나 한다는 것은 일면 비 논리적이라고 볼 수 있다. type-safe 란 위와 같이 연산이나 조작에 있어서 논리적이지 않은 것에 대해 엄격히 체크를 하여Runtime시 이로 인한 오류가 발생하지 않도록 하는것이다. Type-Safe하다고 알려진 언어에서는 보통 이를 컴파일 타임에 에러처리를 해주지만,Type-Safe하지 않은 언어, 예를 들어 자바스크립트같은 언어에서는 이것을 적당하게(?) 처리한다.그래서 Javascript는 Type-Safe하다고 하지 않는다. 위와 같은 의미에서, 일반적으로, c# &#x2F; java 와 같은 언어들을 일반적으로 type-safe 하다라고 한다. JSX 사용하기JSX는 HTML이랑 문법이 거의 비슷하게 생겼다. App.js 1234567891011import React from &#x27;react&#x27;;class App extends React.Component &#123; render()&#123; return ( &lt;h1&gt;Hello Velopert&lt;/h1&gt; ); &#125;&#125;export default App; LINE 1: import 는 ES6 에 도입된 새로운 문법인데, var React &#x3D; require(‘react’) 와 같다. React 모듈은 Component를 만들때 사용된다. LINE 3: class 개념 역시 ES6 에 새로 도입된 요소중 하나 이다. 모든 Component는 React.Component 를 상속한다. ES5 환경에서는 React.createClass() 라는 메소드를 사용한다. 또한, ES5 에서 클래스를 만들때는 메소드들을 nest 할 수 없고 prototype을 사용했어야 했는데, 많이 편해졌다.(ES6 Class 에 대해서는 Mozilla 참고자료 에서 확인하면 된다.) LINE 4: render() 메소드에서는 컴포넌트에 렌더링 될 데이타를 정의한다. LINE 5~7: 이 부분이 JSX의 가장 중요한 부분으로 자바스크립트에서 html 태그를 반환하는데, 따옴표같은건 없음을 유의하자.(문자열 처리) React JSX 는 XML-like Syntax 를 native Javascript로 변환해주므로 &quot;&quot; 로 감싸지 않는 점을 주의해야한다. ()를 사용하지 않아도 오류는 발생하지 않지만 가독성을 위하여 사용하는것이 좋다. 1. 확장자에 대하여..JSX 파일의 확장자의 경우, 이전에는 개발자들이 .jsx 확장자를 사용하였지만 요즘은 .js 를 사용하는 추세로 전환되어 가고 있다. 페이스북의 오픈소스 에디터인 draft.js 는 구별을 제대로 하기 위하여 .react.js 확장자를 사용하기도 한다. 여기서는 .js 확장자를 사용하도록 하겠다. JSX VS JSJSX 를 사용했을 경우와 사용하지 않았을 때를 비교 차이는 다음과 같다. 123456789101112131415161718192021222324252627282930&lt;!-- JSX --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;JSX 문법&lt;/title&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.24/browser.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://npmcdn.com/react@latest/dist/react-with-addons.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://npmcdn.com/react-dom@latest/dist/react-dom.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://facebook.github.io/react/js/jsfiddle-integration-babel.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;container&quot;&gt; &lt;!-- This element&#x27;s contents will be replaced with your component. --&gt;&lt;/div&gt;&lt;script&gt;var Hello = React.createClass(&#123; render: function() &#123; return &lt;div&gt;Hello &#123;this.props.name&#125;&lt;/div&gt;; &#125;&#125;);ReactDOM.render( &lt;Hello name=&quot;World&quot; /&gt;, document.getElementById(&#x27;container&#x27;));&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 참조: https://jsfiddle.net/reactjs/69z2wepo/ 1234567891011121314151617181920212223242526272829&lt;!-- JS --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;JS 문법&lt;/title&gt;&lt;script src=&quot;https://npmcdn.com/react@latest/dist/react-with-addons.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://npmcdn.com/react-dom@latest/dist/react-dom.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;container&quot;&gt; &lt;!-- This element&#x27;s contents will be replaced with your component. --&gt;&lt;/div&gt;&lt;script&gt;var Hello = React.createClass(&#123; displayName: &#x27;Hello&#x27;, render: function() &#123; return React.createElement(&quot;div&quot;, null, &quot;Hello &quot;, this.props.name); &#125;&#125;);ReactDOM.render( React.createElement(Hello, &#123;name: &quot;World&quot;&#125;), document.getElementById(&#x27;container&#x27;));&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 참조: https://jsfiddle.net/reactjs/5vjqabv3/ 2. Nested Elements컴포넌트에서 여러 Element 를 렌더링 해야 할 때, 그 element들을 필수적으로 container element 안에 포함시켜줘야 된다.예를들어 다음과 같이 코드를 작성하면: 1234return ( &lt;h1&gt; Hello Velopert&lt;/h1&gt; &lt;h2&gt; Welcome &lt;/h2&gt;); 변환 과정에서 다음과 같은 오류가 발생 한다. 123456789ERROR in ./src/App.jsModule build failed: SyntaxError: /home/vlpt/node_tutorial/react/react-tutorials/03-jsx/src/App.js: Adjacent JSX elements must be wrapped in an enclosing tag (10:12) 8 | return ( 9 | &lt;h1&gt; Hello Velopert&lt;/h1&gt;&gt; 10 | &lt;h2&gt; Welcome &lt;/h2&gt; | ^ 11 | ); 12 | &#125; 13 | &#125; 다음과 같이 div element 를 wrapper 로 사용하면 오류가 발생하지 않는다. 123456return ( &lt;div&gt; &lt;h1&gt; Hello Velopert &lt;/h1&gt; &lt;h2&gt; Welcome &lt;/h2&gt; &lt;/div&gt;); 3. JavaScript ExpressionJSX 안에서, JavaScript 표현을 사용하는 방법은 매우 간단하다. 그냥 &#123;&#125; 로 wrapping 하면 된다. 12345678910render() &#123; let text = &#x27;Dev-Server&#x27;; return ( &lt;div&gt; &lt;h1&gt; Hello Velopert &lt;/h1&gt; &lt;h2&gt; Welcome to &#123;text&#125;&lt;/h2&gt; &lt;/div&gt; );&#125; LINE 2: ES6 에 도입된 let 키워드는 var 과 비슷하지만, var 변수의 scope는 기본적으로 함수 단위인데 let 은 블럭 범위 내에서 변수를 선언 한다. 따라서 가끔 발생하는 javascript 의 Scope관련 문제를 해결 할 수 있다. 지금 이 상황에선 let 을 사용하는것이 필수는 아니지만, ES6 에선 평상시 let 을 쓰고 var은 필요한 상황에서만 사용하는게 좋다. (let 에 관련된 정보는 Mozilla 참고자료 에서 확인하면 된다.) LINE 6: &#123; text &#125; 를 사용하여 text Javascript 변수를 렌더링 한다. 임의 method 생성 및 사용하기React 에서 method를 생성하고 사용하는 방법에 대하여 알아보자. 123456789101112131415sayHey() &#123; alert(&quot;hey&quot;);&#125;render() &#123; let text = &#x27;Dev-Server&#x27;; return ( &lt;div&gt; &lt;h1&gt; Hello Velopert &lt;/h1&gt; &lt;h2&gt; Welcome to &#123;text&#125;&lt;/h2&gt; &lt;button onClick=&#123;this.sayHey&#125;&gt;Click Me&lt;/button&gt; &lt;/div&gt; );&#125; LINE 11: &#123;this.sayHey&#125; 를 통해 버튼이 클릭되면 해당 메소드가 실행되게 할 수 있다. () 가 뒤에 안붙어있다는점을 주의하자. 만약에 () 가 붙으면 페이지가 로드 될때도 실행되고, 클릭할때도 실행된다. If-Else 문 사용 불가JSX 안에서 사용되는 JavaScript 표현에는 If-Else 문이 사용 불가하다. 이에 대한 대안은 ternary ( condition ? true : false ) 표현(삼항 연산자)을 사용하는 것이다. 예를 들면 다음과 같다. 1&lt;p&gt;&#123;1 == 1 ? &#x27;True&#x27; : &#x27;False&#x27;&#125;&lt;/p&gt; 4. Inline StyleReact의 Inline Style 에서는, string 형식이 사용되지 않고 key 가 camelCase 인 Object 가 사용된다.다음 예제를 통하여 살펴보자. 1234567891011121314151617render() &#123; let text = &#x27;Dev-Server&#x27;; let pStyle = &#123; color: &#x27;aqua&#x27;, backgroundColor: &#x27;black&#x27; &#125;; return ( &lt;div&gt; &lt;h1&gt; Hello Velopert &lt;/h1&gt; &lt;h2&gt; Welcome to &#123;text&#125;&lt;/h2&gt; &lt;button onClick= &#123;this.sayHey&#125;&gt;Click Me&lt;/button&gt; &lt;p style = &#123;pStyle&#125;&gt;&#123;1 == 1 ? &#x27;True&#x27; : &#x27;False&#x27;&#125;&lt;/p&gt; &lt;/div&gt; );&#125; pStyle 이 p element 에 적용되었다. 5. 주석JSX 안에서 주석을 작성할 때엔, &#123; /* comments */ &#125; 형식으로 작성하면 된다. 여기에 작성된 주석은 브라우저상 source 에서 나타나지 않는다. 주의하실 점은 2. Nested Element 에서 나왔던 것 처럼 container element 안에 주석이 작성되어야 한다. 6. Naming Convention모든 React Component 은 첫 문자가 대문자인 CamelCase 로 작성된다. 참조 https://velopert.com/867","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"SPA","slug":"Frontend/SPA","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/"},{"name":"React.js","slug":"Frontend/SPA/React-js","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/React-js/"}],"tags":[{"name":"react","slug":"react","permalink":"https://woonyzzang.github.com/tags/react/"}]},{"title":"React.js Setting","slug":"reactjs-setting","date":"2017-07-11T12:13:39.000Z","updated":"2024-06-07T09:27:28.359Z","comments":true,"path":"2017/07/11/reactjs-setting/","permalink":"https://woonyzzang.github.com/2017/07/11/reactjs-setting/","excerpt":"","text":"React.js 작업환경 설정하기React 작업환경을 설정에 대해 알아보자. NodeJS 환경에서 React를 사용 할 것이므로 NodeJS 및 npm이 설치되있어야 한다. NodeJS 환경에서 React를 사용하는 방법은 대표적으로 webpack을 이용하는 방법이 있고, browserify를 이용하는 방법이 있는데, 이 포스트에서는 webpack을 이용하는 방법을 설명한다.주의: Node.js를 설치 한 다음에, npm install -g npm 을 통하여 npm 버전을 최신버전으로 업데이트 한다. LTS 버전에서는 지금은 NPM을 2.15.9 을 사용하는데, 이는 모듈을 설치할때 nested 된 구조로 설치하기 때문에 React.js 프로젝트를 만들땐 오래 걸린다. (babel-preset-es2015 설치 할 때). 위 명령어로 최신버전인 3.10.6 을 사용하면 모듈설치가 훨씬 빨라진다. (node_modules 의 용량차이가 상당하다. babel-preset-es2015 의 경우 6.14MB, 구버전 NPM을 사용 했을땐, 144MB) 1. Global Package 설치작업환경 설치를 위하여 몇가지 글로벌 패키지가 설치 되어야 한다. 설치 할 패키지들은 다음과 같다. babel: 아직 ECMAScript6 를 지원하지 않는 환경에서 ECMAScript6 Syntax를 사용 할 수 있게 해준다. webpack: 모듈 번들러로서, Browserify 처럼 브라우저 위에서 import (require) 을 할 수 있게 해주고 자바스크립트 파일들을 하나로 합쳐준다. webpack-dev-server: wepback에서 지원하는 간단한 개발서버로서 별도의 서버를 구축하지 않고도 웹서버를 열 수 있으며 hot-loader를 통하여 코드가 수정될때마다 자동으로 리로드 되게 할 수 있다. 1$ npm install -g babel webpack webpack-dev-server 2. 프로젝트 생성react-tutorial 이라는 루트 폴더를 생성 후 npm init 명령어를 사용하여 Nodejs 프로젝트를 생성한다. 12$ mkdir react-tutorial &amp;&amp; cd react-tutorial$ npm init 3. Dependency 및 Plugin 설치React 를 사용 할 것이므로, react-dom을 설치해야 한다. –save 옵션을 통하여 package.json 에 의존 패키지들을 추가 할 수있다. 1$ npm install --save react react-dom 둘쨰로, babel 에서 사용 될 플러그인을 설치해야 한다. 해당 모듈들은 개발환경에서만 사용되므로 –save-dev 옵션을 설정한다. 1$ npm install --save-dev babel-core babel-loader babel-preset-react babel-preset-es2015 webpack webpack-dev-server webpack 과 webpack-dev-server 가 글로벌로 이미 설치가 되어있는데, 로컬 모듈로 설치된 이유는 webpack 의 livereload와 비슷한 기능인 –hot 옵션을 사용하기 위함 이다. 사실 상, webpack 모듈을 글로벌 패키지로서 꼭 설치 할 필요는 없다. 이를 설치 한 이유는 커맨드라인에서 webpack-dev-server을 바로 실행하기 위함인데, 로컬에만 설치하고 나중에 webpack 을 실행할 때는 .&#x2F;node_modules&#x2F;bin&#x2F;webpack-dev-server –hot 이런식으로 실행 할 수 있다. 현재 package.json 파일을 확인해 보면 설치된 의존 모듈은 다음과 같다. 123456789101112&quot;dependencies&quot;: &#123; &quot;react&quot;: &quot;^0.14.7&quot;, &quot;react-dom&quot;: &quot;^0.14.7&quot;&#125;,&quot;devDependencies&quot;: &#123; &quot;babel-core&quot;: &quot;^6.7.0&quot;, &quot;babel-loader&quot;: &quot;^6.2.4&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.6.0&quot;, &quot;babel-preset-react&quot;: &quot;^6.5.0&quot;, &quot;webpack&quot;: &quot;^1.12.14&quot;, &quot;webpack-dev-server&quot;: &quot;^1.14.1&quot;&#125; 4. 디렉토리 구조 이해 및 파일 생성123456789react-tutorial├── package.json ├── public # 서버 public path│ └── index.html # 메인 페이지├── src # React.js 프로젝트 루트│ ├── components # 컴포넌트 폴더│ │ └── App.js # App 컴포넌트│ └── index.js # Webpack Entry point└── webpack.config.js # Webpack 설정파일 다음 명령어를 통하여 파일들을 생성한다.Webpack entry point 는, Webpack 모듈에서 가장 처음으로 읽어들일 파일이다. 이 파일에서부터 시작해서, 해당 파일에서 import 한 다른 모듈들을 불러온다. 1$ mkdir src src/components public &amp;&amp; touch public/index.html src/components/App.js src/index.js webpack.config.js 5. 컴파일러, 서버 및 로더 설정webpack 설정하기 [webpack.config.js] ECMAScript6 를 컴파일해주고 개발서버를 열어주는 webpack의 설정파일 webpack config.js 을 수정한다. 12345678910111213141516171819202122232425262728module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; path: __dirname + &#x27;/public/&#x27;, filename: &#x27;bundle.js&#x27; &#125;, devServer: &#123; inline: true, port: 7777, contentBase: __dirname + &#x27;/public/&#x27; &#125;, module: &#123; loaders: [ &#123; test: /\\.js$/, loader: &#x27;babel-loader&#x27;, exclude: /node_modules/, query: &#123; cacheDirectory: true, presets: [&#x27;es2015&#x27;, &#x27;react&#x27;] &#125; &#125; ] &#125;&#125;; webpack의 역할은, entry 부터 시작하여 필요한 모듈들을 다 불러온 후, 한 파일로 합쳐 bundle.js 에 저장한다.추가적으로는, 모듈을 통하여 ES6 문법으로 작성된 코드를 ES5 형태로 변환도 해준다. 개발 서버의 포트는 7777로 설정되었다.개발 서버는 파일이 변동 될 때마다 다시 컴파일하고, 연결되어있는 브라우저를 새로고침해주는 기능을 가지고 있다. package.jsonnpm start 명령어를 콘솔에서 입력 했을 때, webpack-dev-server 가 실행 될 수있게 package.json 의 “scripts” 블록을 수정한다. 123&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack-dev-server --hot --host 0.0.0.0&quot;&#125;, 만약에 localhost 가 아닌 외부 서버에서 dev-server 실행 시, –host 옵션을 추가하지 않으면 접근이 안된다.localhost 경우에는 생략하면 다. 6. HTML 및 js 수정 index.html 이 파일은 평범한 HTML 파일 이다. div id &#x3D; “app” 을 React 프로젝트의 root element 로 지정하고 index.js 스크립트를 로드해주세요. 이 파일은 webpack에서 bundle된 파일로서, react 라이브러리 및 기타 자바스크립트 파일들이 하나로 합쳐진 파일이다. 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;React App&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; src&#x2F;components&#x2F;App.js처음 만들어 볼 React 컴포넌트 이다. * 파일 및 컴포넌트의 첫 문자를 대문자로 하는건 React의 naming convention 다. 123456789import React from &#x27;react&#x27;;class App extends React.Component &#123; render() &#123; return ( &lt;h1&gt;Hello React Skeleton&lt;/h1&gt; ); &#125;&#125; 1번에서 사용된 import JavaScript ES6 에 새로 도입된 키워드로서, require(‘..’) 의 역할을 한다.12번에서 사용된 export는 JavaScript ES6 에 새로 도입된 키워드로서, module.export &#x3D; App 와 같다.컴포넌트에 대한 설명은 추후 자세히 알아보도록 하겠다. src&#x2F;index.js123456import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import App from &#x27;./components/App&#x27;;const rootElement = document.getElementById(&#x27;root&#x27;);ReactDOM.render(&lt;App /&gt;, rootElement); App 컴포넌트를 불러와서 root element에 렌더링하는 부분입니다. 7. webpack-dev-server 구동하기1$ npm start 지금까지 같은 모듈 버전에 오타가 없이 위에 예제들을 순차적으로 진행하였으면 에러 없이 서버가 구동 될 것 다.브라우저에서 링크를 띄운 상태에서 App.js 를 수정해보면 브라우저에서 수동으로 F5를 누르지 않아도 자동으로 새로고침 된다. 참조 https://velopert.com/814 https://www.youtube.com/watch?v=gSwO2S-Q88s","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"SPA","slug":"Frontend/SPA","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/"},{"name":"React.js","slug":"Frontend/SPA/React-js","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/React-js/"}],"tags":[{"name":"react","slug":"react","permalink":"https://woonyzzang.github.com/tags/react/"}]},{"title":"React.js","slug":"reactjs","date":"2017-06-26T13:35:05.000Z","updated":"2024-06-07T09:27:28.373Z","comments":true,"path":"2017/06/26/reactjs/","permalink":"https://woonyzzang.github.com/2017/06/26/reactjs/","excerpt":"","text":"React.js란React는 페이스북에서 개발한 유저인터페이스 라이브러리로서 개발자로 하여금 재사용 가능한 UI를 생성 할 수 있게 해준다. 이 라이브러리는 현재 페이스북, 인스타그램, 야후, 넷플릭스를 포함한 많은 큰 서비스에서 사용되고 있다. 이 라이브러리는 Virtual DOM 이라는 개념을 사용하여 상태의 변함에 따라 선택적으로 유저인터페이스를 렌더링을 한다.따라서, 최소한의 DOM 처리로 컴포넌트들을 업데이트 할 수 있게 해준다. DOM 이해하기 DOM 은 Document Object Model 의 약자로, 이는 객체를 통하여 구조화된 문서를 표현하는 방법이며, XML 혹은 HTML 로 작성된다. 웹 브라우저는 이 DOM 을 활용하여 객체에 JavaScript 와 CSS를 적용한다. DOM은 트리 형태로 되어있어서, 특정 node를 찾을 수도 있고, 수정 할 수도 있고, 제거하거나 원하는 곳에 삽입 할 수도 있다. DOM 의 문제점 요즘의 DOM API 는 수많은 플랫폼, 그리고 수많은 브라우저에서 사용되고 있는데, 이 DOM 에는 치명적인 문제점이 하나 있다. 그것은 바로, 동적 UI 에 최적화되어 있지 않다는 것이다. HTML은 자체적으로는 정적인 페이지이다. 물론, 이는 자바스크립트나 jQuery 를 사용하여 손을 볼 수는 있다. 하지만, 요즘의 큰 규모의 웹 어플리케이션에서 스크롤을 좀 내리다 보면 수많은 데이터를 동적으로 데이터를 가져온다. 그리고 각 데이터를 표현하는 요소(element)들이 있을 것 이다. 그 요소들의 개수가 몇백 개, 몇천 개 단위로 많아진다면 (예: 페이스북에서 포스트 한 개를 표현 할 때 사용되는 요소의 개수는 약 100개 이다) 이야기가 좀 달라진다. 이렇게 규모가 큰 웹 어플리케이션에서 DOM 에 직접 접근하여 변화를 주다 보면, 성능상의 이슈가 조금씩 발생하기 시작한다. 일부 문서에서는 이를 두고 요즘의 자바스크립트 엔진은 매우 빠른 반면, DOM 은 느리다 라고 하는데, 이것은 정확한 사실이 아니다. DOM 자체는 빠르다. DOM 자체를 읽고 쓸 때의 성능은 자바스크립트 객체를 처리 할 때의 성능과 비교해서 다를 게 없습니다. 단, 브라우저 단에서 DOM 의 변화가 일어나면, 브라우저가 CSS 를 다시 연산하고, 리레이아웃을 구성하고, 웹 페이지를 리페인트 하는데, 이 과정에서 퍼포먼스 성능이 저하되는 것이다. 여기서 레이아웃을 새로 구성하면서 계산하는것을 reflow 라고하고, 색상변경과 같은 레이아웃에 관계없는 것들읃 처리하는건 repaint 라고 한다. 아래 예제로 한번 살펴보자. 12345678910var style = document.body.style; // 캐싱style.padding = &#x27;20px&#x27;; // reflow, repaintstyle.border = &#x27;10px solid red&#x27;; // reflow, repaintstyle.color = &#x27;blue&#x27;; // repaint (레이아웃이 변경되진 않았기 때문에 reflow 안함)style.backgroundColor = &#x27;#ffa&#x27;; // repaintstyle.fontSize = &#x27;1em&#x27;; // reflow, repaint// reflow, repaintdocument.body.appendChild(document.createTextNode(&#x27;hello world&#x27;)); 이 외에도, 변경하지 않고 DOM 의 값을 읽을떄도 reflow가 계산 될 때가 있다. element.offsetLeft, element.clientWidth, element.getClientRects() 이런 코드가 실행 될 떄도 브라우저에서 reflow가 발생하게 된다. 브라우저 렌더링 브라우저 벤더들은 언제나 최적의 경험을 사용자에게 제공해주기위해서 노력을 하고 있다. 저렇게 코드가 실행될때마다 비효율적으로 그때그때 reflow를 한다면 정말 성능이 저하 될 것 이다. 그래서 브라우저는 이 성능저하를 단축시키기 위하여 이렇게 매우 짧은시간내에 여러 reflow 가 발생하려고 할 시, 이 작업을 미루고 한꺼번에 처리한다. 하지만, 일부 코드들은 브라우저에서 최적화를 하지 못할때도 있다. 예를들어 offsetTop, scrollTop, getComputedStyle() 등의 코드가 실행 될 때는 현재의 값을 가져오는것들이 중요하기 때문에 reflow가 여러번 발생할수밖에 없게 된다. 그렇기 때문에, 성능 개선을 위해서는 reflow 횟수를 줄이기 위하여 코드를 최적화 해야한다. (참고) 해결법 HTML 마크업을 시각적인 형태로 변환을 하는 것은 브라우저의 주 역할이기 때문에, 이를 처리 할 때 컴퓨터 자원이 사용되는 것은 어쩔 수 없다. 결국엔, 이 문제를 해결하기 위해서 DOM 조작을 아예 안 할 수는 없으니까, 적어도 최소한의 DOM 조작을 통하여 작업을 처리하는 방식으로 이를 개선 할 수는 있다. Virtual DOMReact 에서는 Virtual DOM이란 개념을 도입했는데 이는 DOM 작업을 가상화 하여 미리 처리한다음에 한꺼번에 적용할 수 있는 방법을 사용하여 퍼포먼스 성능을 향상시키는 것이다.Virtual DOM 을 사용하면, 실제 DOM 에 접근하여 조작하는 대신에, 이를 추상화 시킨 자바스크립트 객체를 구성하여 사용한다. 이는 마치 실제 DOM 의 가벼운 사본과도 비슷하다고 볼 수 있다. React 에서 데이터가 변하여 브라우저상의 실제 DOM 을 업데이트 할 때에는 다음과 같이 3가지 절차로 진행한다. 데이터가 업데이트되면, 전체 UI 를 Virtual DOM 에 리렌더링 한다. 이전 Virtual DOM 에 있던 내용과 현재의 내용을 비교한다. 바뀐 부분만 실제 DOM 에 적용이 된다. 결국에는 컴포넌트가 업데이트 될 때, 레이아웃 계산이 한번만 이뤄지게 된다. 오해 Virtual DOM을 사용한다고 해서, 사용하지 않았을 때와 비해 무조건 빠른 것은 아니다. 결국엔 적절한 곳에 사용해야 React 가 비로소 지니고 있는 진가를 발휘하게 된다. React 를 사용하지 않아도 코드 최적화를 열심히 하면 DOM 작업이 느려지는 문제를 개선 할 수 있고, 또 매우 간단한 작업의 경우엔 (예: 단순 라우팅 정도만 있는 정적인 웹페이지) 오히려 React 를 사용하지 않는 편이 더 나은 성능을 보이기도 한다.반면에, React 와 Virtual DOM 이 우리에게 언제나 제공해 줄 수 있는 것은 바로 업데이트 처리에 대한 간결함일 것이다. UI 를 업데이트하는 과정에서 생기는 복잡함을 모두 해소해주고, 업데이트에 더욱 쉽게 접근 할 수 있게 해준다. 특징 Virtual DOM 사용 JSX: JSX 는 JavaScript 확장 문법. DOM 엘리먼트들을 만들 때 JavaScript 형식으로 작성해야 하는 것을, XML 과 비슷한 형태로 작성할 수 있게 해준다. 이를 사용하는것은 권장사항이고 필수는 아니다. 하지만 사용하지 않으면 좀 불편하다. Components React는 모두 Component 에 대한 것 이다. React 개발을 할 때는 모든 것을 Component 로서 생각해야 한다. 장점 Virtual DOM 을 사용한 어플리케이션의 성능 향상 클라이언트, 서버측에서 렌더링 가능 (이를 통해 브라우저측의 초기 렌더링 딜레이를 줄이고, SEO 호환도 가능) Component 의 가독성이 매우 높고 간단하여 쉬운 유지보수가 가능 프레임워크가 아닌 라이브러리서 다른 프레임워크들과 사용이 가능하다. React 에선 UI만 신경쓰고, 빠져있는 부분은 본인이 좋아하는 라이브러리를 사용하여 stack 을 본인의 입맛대로 설정 가능 제한 어플리케이션의 View 레이어만 다루므로 이 외의 부분은 다른 기술을 사용해야 한다.(예를 들어 Ajax, Router 등의 기능은 직접 구현하거나 다른 모듈을 설치하여 사용한다. 하지만 그 과정이 그렇게 복잡하지는 않다)React 버전 v15부터 IE8 이하 버전을 지원하지 않는다. (IE8 이하 버전을 지원해야 할 경우 v0.14 버전을 사용 해야 한다) 참조 https://velopert.com/775 https://www.youtube.com/watch?v=H24D0GveBYY","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"SPA","slug":"Frontend/SPA","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/"},{"name":"React.js","slug":"Frontend/SPA/React-js","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/React-js/"}],"tags":[{"name":"react","slug":"react","permalink":"https://woonyzzang.github.com/tags/react/"}]},{"title":"Mobile Wep iScroll Dynamically Loading 이슈","slug":"mobile-web-iscroll-dynamically-loading","date":"2017-06-21T14:02:49.000Z","updated":"2020-09-05T13:07:55.905Z","comments":true,"path":"2017/06/21/mobile-web-iscroll-dynamically-loading/","permalink":"https://woonyzzang.github.com/2017/06/21/mobile-web-iscroll-dynamically-loading/","excerpt":"","text":"iScroll 플러그인 사용시 동적 로드 시 이슈iScroll은 모바일용 웹페이지 개발 시 내부 스크롤바 기능을 가능하게 해주는 자바스크립트 플러그인 이다. iScroll 사용시 아이폰,안드로이드 모두 정상동작하나, 동적일때가 문제가 있다.예를들어 검색버튼을 눌렀을때 스크롤될 리스트들이 호출되거나 동적으로 페이지 불러올때 페이지 양이 많아서 불러오느라 시간이 지연되어서 스크롤 처리가 안되어 iScroll 기능이 정상적으로 작동하지 않고 스크롤이 생기지 않는 문제가 있다. (가로,세로 폰을 돌리면 스크롤이 생기긴 한다.) 이유는 동적으로 불러오는 컨텐츠의 로딩이 페이지의 로딩보다 늦기 때문에, 동적으로 불러오는 컨텐츠는 wrapper div 내에 포함되어도 iscroll 이 div 의 변화를 인지하지 못해 생기는 문제이다.로딩이 끝난 다음 .refresh() 메소드를 호출 하던지 아니면 페이지 로딩되는 시간을 감안해서 setTimeout 으로 .refresh() 해도 된다.다만, 이 경우에도 setTimeout 보다 로딩이 느린 경우에는 가끔 스크롤이 안 먹는 경우가 생기기도 한다. 123456789101112131415var myScroll;function loaded() &#123; myScroll = new iScroll(&#x27;wrapper&#x27;, &#123;checkDOMChanges: true&#125;); setTimeout(function() &#123; myScroll.refresh(); &#125;, 100); // 삭제 //myScroll.destroy(); //myScroll = null;&#125;document.addEventListener(&#x27;touchmove&#x27;, function(e) &#123; e.preventDefault(); &#125;, false);document.addEventListener(&#x27;DOMContentLoaded&#x27;, function() &#123; setTimeout(loaded, 200); &#125;, false); wrapper 엘리먼트에 크기가 바뀌었을 경우 iScroll 객체에 .refresh() 메서드를 호출해 주어야 한다.단말기 방향을 바꾸었을 때 screen width 변경되면서 wrapper 엘리먼트의 크기도 변경되기 때문에.. 이럴 때에는 orientationchange 이벤트에서 .refresh() 호출을 해주면 된다. 123window.addEventListener(&#x27;orientationchange&#x27;, function() &#123; myscroll.refresh(); // iScroll 갱신&#125;, false); 참조 http://iscrolljs.com/","categories":[{"name":"Web","slug":"Web","permalink":"https://woonyzzang.github.com/categories/Web/"},{"name":"Mobile","slug":"Web/Mobile","permalink":"https://woonyzzang.github.com/categories/Web/Mobile/"}],"tags":[{"name":"mobile","slug":"mobile","permalink":"https://woonyzzang.github.com/tags/mobile/"}]},{"title":"jQuery Animated Background Position","slug":"jquery-background-position-animated","date":"2017-06-04T14:13:18.000Z","updated":"2024-06-07T09:27:28.339Z","comments":true,"path":"2017/06/04/jquery-background-position-animated/","permalink":"https://woonyzzang.github.com/2017/06/04/jquery-background-position-animated/","excerpt":"","text":"jQuery animate() 함수 backgroundPosition 사용배경이미지의 background-position 값 위치를 jQuery로 동적으로 제어하는 방법을 알아보자. jQuery v1.4.3 이상 버전부터는 animate() 함수에서 backgroundPosition 속성을 지원하지 않는다.따라서 속성값을 background-position-x, background-position-y 로 변경하여 사용해야 된다.(참고) 하지만 1.3.x 이하 버전에서는 이 속성을 지원하지 않는다. 1.3.x 이하 버전 1$(this).animate(&#123;backgroundPosition: &#x27;20px 30px&#x27;&#125;); 1.4.0 이상 버전 1$(this).animate(&#123;&#x27;background-position-x&#x27;: &#x27;20px&#x27;, &#x27;background-position-x&#x27;: &#x27;30px&#x27;&#125;); 크로스브라우징 이슈 animated() 의 background-position-x 나 background-position-y로 구현시 IE11 이하 브라우저에서는 지원이 되지 않는다.브라우저 파면화를 고려한다면 다음과 같이 플러그인으로 구현된 아래 코드를 활용하면 된다. 1234567891011121314151617181920212223242526$.fn.animateBgPosition = function(x, y, speed) &#123; var pos = this.css(&#x27;background-position&#x27;).split(&#x27; &#x27;); this.x = parseInt(pos[0]) || 0; this.y = parseInt(pos[1]) || 0; $.Animation(this, &#123; x: x, y: y &#125;, &#123; duration: speed &#125;).progress(function(e) &#123; this.css(&#x27;background-position&#x27;, e.tweens[0].now+&#x27;px &#x27;+e.tweens[1].now+&#x27;px&#x27;); &#125;); return this;&#125;;$(&#123;&#123;@selector&#125;&#125;).on(&#123; mouseenter: function() &#123; $(this).stop(true,true).animateBgPosition(&#x27;0&#x27;, 0, 400); &#125;, mouseleave: function() &#123; $(this).stop(true,true).animateBgPosition(&#x27;-400px&#x27;, 0, 400); &#125;&#125;); 참조 https://codepen.io/gabrieleromanato/pen/emzPXz","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Library","slug":"Frontend/Library","permalink":"https://woonyzzang.github.com/categories/Frontend/Library/"},{"name":"jQuery","slug":"Frontend/Library/jQuery","permalink":"https://woonyzzang.github.com/categories/Frontend/Library/jQuery/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"https://woonyzzang.github.com/tags/jquery/"}]},{"title":"CSS3 Background Image Blur","slug":"css3-background-image-blur","date":"2017-05-25T12:32:21.000Z","updated":"2024-06-07T09:27:28.275Z","comments":true,"path":"2017/05/25/css3-background-image-blur/","permalink":"https://woonyzzang.github.com/2017/05/25/css3-background-image-blur/","excerpt":"","text":"배경 이미지에만 흐림효과(Blur) 적용하기배경 이미지에만 blur 효과를 적용하는 방법이다.(IE에서는 적용이 안되고, 크롬에서는 정상 작동한다.) 주의할 점은 style로 Background를 준 엘리먼트 또는 그 자식 엘리먼트 이여야 한다.해당 개체의 z-index가 1 이상 이어야한다. blur 효과 적용 방법 1.HTML 코드에 적용할 Element의 bgBlur class를 추가 해준다.이때 흐림효과를 적용할 Element는 반드시 style로 background 이미지가 있어야 한다. 12345678&lt;div id=&quot;blurExample&quot; class=&quot;bgBlur&quot;&gt; &lt;h1&gt;내용물은 흐려지지 않습니다.&lt;/h1&gt;&lt;/div&gt;&lt;svg version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;filter id=&quot;blur&quot;&gt; &lt;feGaussianBlur stdDeviation=&quot;6&quot; /&gt; &lt;/filter&gt;&lt;/svg&gt; 2.style.css에 아래 코드를 추가한다. 123456789101112131415161718192021222324252627282930313233#blurExample &#123; overflow:hidden; float:left; position: relative; z-index: 1; width: 200px; height: 250px; margin: 10px; background: url(&#123;@이미지파일경로&#125;) 50% 50%; background-size: cover;&#125;.bgBlur:before &#123; content: &#x27;&#x27;; position: absolute; top: 0; left:0; right:0; bottom:0; z-index:-1; background: inherit; filter: blur(6px); -webkit-filter: blur(6px); -moz-filter: blur(6px); -o-filter: blur(6px); -ms-filter: blur(6px); filter:url(#blur); filter:progid:DXImageTransform.Microsoft.Blur(PixelRadius=&#x27;6&#x27;);&#125;svg &#123; height:0&#125; 참조 http://nubiz.tistory.com/443","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"CSS","slug":"Frontend/CSS","permalink":"https://woonyzzang.github.com/categories/Frontend/CSS/"}],"tags":[{"name":"css","slug":"css","permalink":"https://woonyzzang.github.com/tags/css/"},{"name":"css3","slug":"css3","permalink":"https://woonyzzang.github.com/tags/css3/"}]},{"title":"ASP IIS Http Error 503 Windows7","slug":"asp-iis-http-error503-win7","date":"2017-05-24T12:18:07.000Z","updated":"2024-06-07T09:27:28.261Z","comments":true,"path":"2017/05/24/asp-iis-http-error503-win7/","permalink":"https://woonyzzang.github.com/2017/05/24/asp-iis-http-error503-win7/","excerpt":"","text":"IIS 설정 Http Error 503 Windows7 에러 대처 방법윈도우7 환경에서 IIS 로컬 웹 서버를 구축하고 브라우저로 localhost로 접근했더니 다음과 같은 503 에러가 발생하였다. 1HTTP Error 503. The service is unavailable. IIS 관리자를 켜고 좌측 연결에서 응용 프로그램 풀을 마우스 우클릭해서 시작을 눌러도 해당 사이트가 바인딩된 응용프로그램 풀의 상태가 조금 있다가 자동으로 중지된다.참고로 프로젝트 보안이슈 때문에 외부 인터넷 연결이 차단되어 있는 로컬 환경이였다. 해결 방법 응용프로그램풀의 마우스 오른쪽을 눌러 고급설정 메뉴를 선택한다.ID가 기본적으로 ApplicationPoolIdentity로 설정되어 있는데 localsystem 으로 변경한다.ID 변경 후 브라우저로 localhost로 접근하면 에러 없이 웹 서버가 잘 동작한다. 참조 http://junigguya.tistory.com/121","categories":[{"name":"Server","slug":"Server","permalink":"https://woonyzzang.github.com/categories/Server/"},{"name":"IIS","slug":"Server/IIS","permalink":"https://woonyzzang.github.com/categories/Server/IIS/"}],"tags":[{"name":"server","slug":"server","permalink":"https://woonyzzang.github.com/tags/server/"},{"name":"asp","slug":"asp","permalink":"https://woonyzzang.github.com/tags/asp/"}]},{"title":"ASP IIS Web Server Windows7","slug":"asp-iis-web-server-win7","date":"2017-05-24T11:54:25.000Z","updated":"2024-06-07T09:27:28.262Z","comments":true,"path":"2017/05/24/asp-iis-web-server-win7/","permalink":"https://woonyzzang.github.com/2017/05/24/asp-iis-web-server-win7/","excerpt":"","text":"Windows7 환경에서 IIS 웹 서버 설치윈도우7 환경에서 IIS 로컬 웹 서버를 구축하는 방법을 설명한다.참고로 테스트 환경은 ‘Windows7 64bit + IIS 7.0’ 기준 이다. 설치 방법1.제어판 - 프로그램 및 기능으로 접근한다.(단축키는 윈도우키 + R 를 누른 후 명령프롬프트 창에서 control 명령어 입력) 2.Windows 기능 사용&#47;사용 안함을 클릭하면 창하나가 뜨는데 인터넷 정보 서비스(Internet Information Service) 항목을 활성화한다. 3.구동할 언어에 따른 항목을 체크하여 활성화 후 확인 버튼을 클릭한다.(아래는 ASP 기준) 4.내컴퓨터 - 속성 - 서비스 및 응용 프로그램 - IIS(인터넷 정보 서비스)항목을 클릭하면 오른쪽 화면에 사이트 항목이 있습니다. Default Web site라고 기본적으로 만들어져 있는 항목이 있습니다. 이는 C:\\Inetpub\\wwwroot가 기본 폴더로 지정이 되어있다. 웹사이트 추가 시 사이트항목에서 마우스 오른쪽 클릭 후 새로 생성하면 된다. 5.현재 IIS가 실행중이며 웹브라우저에 localhost를 주소창에 입력 시 IIS 로고가 보이면 IIS 설치가 정상적으로 완료된 것 아다. 참조 http://h5bak.tistory.com/140","categories":[{"name":"Server","slug":"Server","permalink":"https://woonyzzang.github.com/categories/Server/"},{"name":"IIS","slug":"Server/IIS","permalink":"https://woonyzzang.github.com/categories/Server/IIS/"}],"tags":[{"name":"server","slug":"server","permalink":"https://woonyzzang.github.com/tags/server/"},{"name":"asp","slug":"asp","permalink":"https://woonyzzang.github.com/tags/asp/"}]},{"title":"ASP IIS(Internet Information Services)","slug":"asp-iis","date":"2017-05-24T11:20:06.000Z","updated":"2024-06-07T09:27:28.262Z","comments":true,"path":"2017/05/24/asp-iis/","permalink":"https://woonyzzang.github.com/2017/05/24/asp-iis/","excerpt":"","text":"IIS(인터넷 정보 서비스) 란?웹 서버(IIS) 역할은 웹 사이트, 서비스 및 응용 프로그램을 안정적으로 호스팅하기 위한 안전하고 확장 가능하며, 쉽게 관리할 수 있는 모듈식 플랫폼을 제공한다. IIS8에서는 인터넷, 인트라넷 또는 엑스트라넷을 통해 사용자와 정보를 공유할 수 있고 IIS8은 IIS, ASP.NET, FTP 서비스 PHP 및 통합형 웹 플랫폼이다. IIS의 기능 IIS 관리자를 사용하여 IIS 기능을 구성하고 웹 사이트를 관리한다. FTP(파일 전송 프로토콜)를 사용하여 웹 사이트 소유자가 파일을 업로드 및 다운로드할 수 있다. 웹 사이트 격리를 사용하여 웹 사이트가 서버의 다른 사이트를 방해하지 않도록 한다. 클래식 ASP, ASP.NET, PHP 등의 다양한 기술을 사용하여 작성된 웹 응용 프로그램을 구성한다. Windows PowerShell을 사용하여 웹 서버에 대한 대부분의 관리 작업관리 과정을 자동화 한다. 여러 웹 서버를 IIS로 관리할 수 있는 서버 팜으로 구성한다. NUMA 하드웨어를 최대한 활용하고 NUMA 사용 가능 서버의 성능을 최대한 한다. 참조 http://blog.naver.com/PostView.nhn?blogId=tjrwjd3535&amp;logNo=220725935498&amp;parentCategoryNo=&amp;categoryNo=7&amp;viewDate=&amp;isShowPopularPosts=true&amp;from=search","categories":[{"name":"Server","slug":"Server","permalink":"https://woonyzzang.github.com/categories/Server/"},{"name":"IIS","slug":"Server/IIS","permalink":"https://woonyzzang.github.com/categories/Server/IIS/"}],"tags":[{"name":"server","slug":"server","permalink":"https://woonyzzang.github.com/tags/server/"},{"name":"asp","slug":"asp","permalink":"https://woonyzzang.github.com/tags/asp/"}]},{"title":"Webpack-v2 Config Usage","slug":"webpack-v2-config-usage","date":"2017-05-22T08:04:12.000Z","updated":"2024-06-07T09:27:28.382Z","comments":true,"path":"2017/05/22/webpack-v2-config-usage/","permalink":"https://woonyzzang.github.com/2017/05/22/webpack-v2-config-usage/","excerpt":"","text":"webpack2 사용 예제 기본 설치 및 사용법은 webpack 내용 참조 모듈 및 플러그인 사용법은 webpack-v2 module plugin 내용 참조 실제로 webpack2 어떻게 작성하고 사용하는지 샘플 코드로 작성 후 한번 살펴 보자. 디렉토리 구성 샘플 123456789101112131415[src] [css] -style.css [img] [js] -module-a.js -module-b.js -module-c.js [scss] -style.scss -entry-index.js -index.html-package.json-webpack.config.js 파일 구성 샘플 123456789101112131415&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;나는 문서의 제목이얌! 내가 짱이지!&lt;/h1&gt;&lt;p&gt;IE11+에서 나는 드래그 안 될 걸?!&lt;/p&gt;&lt;script src=&quot;./bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234// module-a.jsconst a = &#x27;나는 a&#x27;;export const ab = a + &#x27;, a를 외부에 노출시키지 않고 변수 a를 활용!&#x27;; 123// module-b.jsexport const a = &#x27;모듈 a에 존재하는 변수 a와는 다른 스코프를 가짐&#x27;; 123// module-c.jsexport const b = &#x27;나도 써주랑!&#x27;; 1234567891011// entry-index.jsimport &#x27;../css/style.css&#x27;;import &#x27;../scss/style.scss&#x27;; import &#123;ab&#125; from &#x27;./module-a&#x27;;import &#123;a&#125; from &#x27;./module-b&#x27;;import &#123;b&#125; from &#x27;./module-c&#x27;; console.log(ab); // &quot;나는 a, a를 외부에 노출시키지 않고 변수 a를 활용!&quot;console.log(a); // &quot;모듈 a에 존재하는 변수 a와는 다른 스코프를 가짐&quot; 12345/* style.css */p &#123; user-select: none&#125; 123456/* style.scss */$color: red;h1 &#123; color: $color&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// webpack.config.jsconst webpack = require(&#x27;webpack&#x27;);const autoprefixer = require(&#x27;autoprefixer&#x27;);module.exports = &#123; devtool: &#x27;source-map&#x27;, entry: &#x27;./src/entry-index.js&#x27;, output: &#123; filename: &#x27;bundle.js&#x27;, &#125;, // 플러그인 옵션 plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; compressor: &#123; warnings: false, &#125; &#125;), new HtmlWebpackPlugin(&#123; title: &#x27;Project Demo&#x27;, minify: &#123; collapseWhitespace: true &#125;, hash: true, template: &#x27;./src/index.html&#x27; &#125;) ], // 파일들에 영향을 주는 옵션 module: &#123; rules: [&#123; test: /\\.js$/, // exclude: /(node_modules|bower_components)/, use: [ &#123;loader: &#x27;babel-loader&#x27;, options: &#123; presets: [ // [&#x27;es2015&#x27;, &#123;moduels: false&#125;] [&#x27;latest&#x27;, &#123;moduels: false&#125;] ] &#125;&#125; ] &#125;, &#123; test: /\\.css$/, // exclude: /node_modules/, use: [ &#x27;style-loader&#x27;, &#123;loader: &#x27;css-loader&#x27;, options: &#123;sourceMap: true&#125;&#125;, &#123;loader: &#x27;postcss-loader&#x27;, options: &#123; plugins: (loader) =&gt; [ autoprefixer(&#123; browsers: [&#x27;last 2 version&#x27;, &#x27;ie &gt;= 10&#x27;] &#125;) ] &#125;&#125; ] &#125;, &#123; test: /\\.(scss|sass)$/, // exclude: /node_modules/, use: [ &#x27;style-loader&#x27;, &#123;loader: &#x27;css-loader&#x27;, options: &#123;sourceMap: true&#125;&#125;, &#123;loader: &#x27;postcss-loader&#x27;, options: &#123; plugins: (loader) =&gt; [ autoprefixer(&#123; browsers: [&#x27;last 2 version&#x27;, &#x27;ie &gt;= 10&#x27;] &#125;) ] &#125;&#125;, &#123;loader: &#x27;sass-loader&#x27;, options: &#123;sourceMap: true&#125;&#125; ] &#125;] &#125;&#125;; 그럼 실제로 번들링을 해보자. 1$ webpack -w 위 명령어를 실행하면 모듈들이 번들링되며 엔트리 포인트와 엔트리 포인트에 관련된 모듈들이 변경될 때마다 다시 번들링되는 감시(watch)를 진행하게 된다.Ctrl + C 키를 누르면 빠져나올 수 있다. 그리고나서 다시 디렉토리를 보면 다음과 같은 파일이 생긴 것을 볼 수 있다. bundle.js bundle.js.map 웹팩 설정 파일 Development(개발모드) &#47; Production(배포모드) 구분webpack의 개발 및 배포용 환경은 보통 구분되어져야 하는데 이에 따라 기본환경파일인 webpack.config.js 는 보통 webpack.donfig.dev.js(개발용) 및 webpack.config.prod.js(배포용) 으로 구분한다.개발모드에서는 source-map 등 debugging용 설정등이 추가되고, 배포모드에서는 소스크기등 최적화용 설정등이 추가된다. 그럼 개발용 파일과 배포용 파일을 분리해 보자!우선 디렉토리를 아래와 같이 바꾼다. 12345678910111213141516[src] [css] -style.css [img] [js] -module-a.js -module-b.js -module-c.js [scss] -style.scss -entry-index.js -index.htmlpackage.json-webpack.config.dev.js-webpack.config.prod.js 몇몇 파일들도 아래와 같이 변경한다. 1234567891011121314151617&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;나는 문서의 제목이얌! 내가 짱이지!&lt;/h1&gt;&lt;p&gt;IE11+에서 나는 드래그 안 될 걸?!&lt;/p&gt;&lt;span&gt;&lt;/span&gt;&lt;button id=&quot;btn&quot; class=&quot;btn btn-warning&quot;&gt;&lt;i class=&quot;fa fa-address-book&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/button&gt;&lt;img src=&quot;./img/logo_webpack.png&quot; alt=&quot;로고&quot;&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324// entry-index.jsif (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; require(&#x27;../index.html&#x27;)&#125;import &#x27;bootstrap/dist/css/bootstrap.min.css&#x27;;import &#x27;font-awesome/css/font-awesome.min.css&#x27;;import $ from &#x27;jquery/dist/jquery.slim&#x27;;import &#x27;./css/style.css&#x27;;import &#x27;./scss/style.scss&#x27;;import &#123; ab &#125; from &#x27;./js/module-a&#x27;;import &#123; a &#125; from &#x27;./js/module-b&#x27;;import &#123; b &#125; from &#x27;./js/module-c&#x27;;console.log(ab); // &quot;나는 a, a를 외부에 노출시키지 않고 변수 a를 활용!&quot;console.log(a); // &quot;모듈 a에 존재하는 변수 a와는 다른 스코프를 가짐&quot;console.log(b);$(&#x27;#btn&#x27;).on(&#x27;click&#x27;, function() &#123; alert(&#x27;test&#x27;);&#125;); 123456789101112131415/* style.scss */$color: blue;$square: 90px;h1 &#123; box-sizing: border-box; color: $color&#125;span &#123; display: inline-block; background-image: url(&#x27;../img/logo_webpack.png&#x27;); width: $square; height: $square;&#125; 추가로 패키지를 설치할 필요가 있다.(설치되어 있거나 필요없는 패키지는 제외하면 된다.) 1234$ npm i -g webpack-dev-server$ npm i -D webpack-dev-server raw-loader webpack-browser-plugin extract-text-webpack-plugin webpack-strip clean-webpack-plugin$ npm i -S jquery bootstrap font-awesome$ npm i -D url-loader file-loader webpack-dev-server: -g로 설치하는 이유는 해당 명령어를 터미널에서 쓰기 위함이고 다시 한 번 -D로 설치하는 이유는 현재 프로젝트에서 해당 패키지를 쓰기 위함이다. webpack-dev-server는 실제 눈에 보이지 않는 디렉토리를 만들고 그 디렉토리에 번들링을 진행하고 watch하며 테스트를 하는 웹팩 개발용 서버이다. raw-loader: html 파일을 핫리로드하게 만드는 로더. webpack-browser-plugin: webpack-dev-server에서 번들링을 끝낸 후 자동으로 브라우저를 열어주는 플러그인. 자세한 옵션은 webpack-browser-plugin을 확인하자. extract-text-webpack-plugin: 스타일 시트를 따로 빼기 위한 플러그인 webpack-strip: js 파일에서 디버깅을 위해 찍어본 로그를 삭제 clean-webpack-plugin: 배포용 파일을 빌드하기 전에 배포용 디렉토리를 지워주는 플러그인 jquery bootstrap font-awesome: 라이브러리 모듈 로더 설치 url-loader file-loader: jquery, bootstrap, font-awesome 이미지 모듈 사용을 위한 로더 Development(개발모드) webpack.config.dev.js 파일을 다음과 같이 수정한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// webpack.config.dev.jsconst path = require(&#x27;path&#x27;);const webpack = require(&#x27;webpack&#x27;);const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);const autoprefixer = require(&#x27;autoprefixer&#x27;);const WebpackBrowserPlugin = require(&#x27;webpack-browser-plugin&#x27;);module.exports = &#123; devtool: &#x27;cheap-eval-source-map&#x27;, entry: [ &#x27;./src/entry-index.js&#x27; ], output: &#123; filename: &#x27;bundle.js&#x27;, &#125;, plugins: [ new webpack.HotModuleReplacementPlugin(), new HtmlWebpackPlugin(&#123; //title: &#x27;Project Demo&#x27;, template: &#x27;./src/index.html&#x27; //filename: &#x27;./index.html&#x27; &#125;), new WebpackBrowserPlugin() ], module: &#123; rules: [&#123; test: /\\.js$/, use: [ &#123;loader: &#x27;babel-loader&#x27;, options: &#123; presets: [ [&#x27;latest&#x27;, &#123;moduels: false&#125;] ] &#125;&#125; ] &#125;, &#123; test: /\\.css$/, use: [ &#x27;style-loader&#x27;, &#123;loader: &#x27;css-loader&#x27;, options: &#123;sourceMap: true&#125;&#125;, &#123;loader: &#x27;postcss-loader&#x27;, options: &#123; plugins: (loader) =&gt; [ autoprefixer(&#123; browsers: [&#x27;last 2 version&#x27;, &#x27;ie &gt;= 10&#x27;] &#125;) ] &#125;&#125; ] &#125;, &#123; test: /\\.(scss|sass)$/, exclude: /node_modules/, use: [ &#x27;style-loader&#x27;, &#123;loader: &#x27;css-loader&#x27;, options: &#123;sourceMap: true&#125;&#125;, &#123;loader: &#x27;postcss-loader&#x27;, options: &#123; plugins: (loader) =&gt; [ autoprefixer(&#123; browsers: [&#x27;last 2 version&#x27;, &#x27;ie &gt;= 10&#x27;] &#125;) ] &#125;&#125;, &#123;loader: &#x27;sass-loader&#x27;, options: &#123;sourceMap: true&#125;&#125; ] &#125;, &#123; test: /\\.html$/, use: [ &#x27;raw-loader&#x27; ] &#125;, &#123; test: /\\.woff(2)?(\\?v=[0-9]\\.[0-9]\\.[0-9])?$/, use: [ &#123;loader: &#x27;url-loader&#x27;, options: &#123; limit: 10000, mimetype: &#x27;application/font-woff&#x27;, name: &#x27;fonts/[name].[ext]&#x27; &#125;&#125; ] &#125;, &#123; test: /\\.(ttf|eot|svg)(\\?v=[0-9]\\.[0-9]\\.[0-9])?$/, use: [ &#123;loader: &#x27;file-loader&#x27;, options: &#123; name: &#x27;fonts/[name].[ext]&#x27; &#125;&#125; ] &#125;, &#123; test: /\\.(jp(e)g|gif|png)?$/, use: [ &#123;loader: &#x27;file-loader&#x27;, options: &#123; name: &#x27;img/[name].[ext]&#x27; &#125;&#125; ] &#125;] &#125;, devServer: &#123; contentBase: path.resolve(__dirname, &#x27;src&#x27;), host: &#x27;127.0.0.1&#x27;, port: 4000, hot: true &#125;&#125;; Production(배포모드) 배포용 설정 파일인 webpack.config.prod.js를 아래와 같이 수정한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112// webpack.config.prod.jsconst path = require(&#x27;path&#x27;);const CleanWebpackPlugin = require(&#x27;clean-webpack-plugin&#x27;);const webpack = require(&#x27;webpack&#x27;);const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);const autoprefixer = require(&#x27;autoprefixer&#x27;);const ExtractTextPlugin = require(&#x27;extract-text-webpack-plugin&#x27;);module.exports = &#123; entry: [ &#x27;./src/entry-index.js&#x27; ], output: &#123; path: path.join(__dirname, &#x27;build&#x27;), filename: &#x27;js/[name].bundle.js&#x27; &#125;, plugins: [ new CleanWebpackPlugin([&#x27;build&#x27;]), new webpack.DefinePlugin(&#123; &#x27;process.env.NODE_ENV&#x27;: JSON.stringify(&#x27;production&#x27;) &#125;), new webpack.optimize.UglifyJsPlugin(&#123; compressor: &#123; warnings: false, &#125; &#125;), new webpack.optimize.OccurrenceOrderPlugin(), new HtmlWebpackPlugin(&#123; template: &#x27;./src/index.html&#x27;, minify: &#123; collapseWhitespace: true, keepClosingSlash: true, removeComments: true, &#125;, xhtml: true &#125;), new ExtractTextPlugin(&#123; filename: &#x27;./css/bundle.min.css&#x27;, disable: false, allChunks: true, &#125;) ], module: &#123; rules: [&#123; test: /\\.js$/, use: [ &#123;loader: &#x27;babel-loader&#x27;, options: &#123; presets: [ [&#x27;latest&#x27;, &#123;moduels: false&#125;] ] &#125;&#125; ] &#125;, &#123; test: /\\.css$/, use: ExtractTextPlugin.extract(&#123; fallback: &#x27;style-loader&#x27;, use: [ &#123;loader: &#x27;css-loader&#x27;, options: &#123;minimize: true&#125;&#125;, &#123;loader: &#x27;postcss-loader&#x27;, options: &#123; plugins: (loader) =&gt; [ autoprefixer(&#123; browsers: [&#x27;last 2 version&#x27;, &#x27;ie &gt;= 10&#x27;] &#125;) ] &#125;&#125; ], publicPath: &#x27;../&#x27; &#125;) &#125;, &#123; test: /\\.(scss|sass)$/, use: ExtractTextPlugin.extract(&#123; fallback: &#x27;style-loader&#x27;, use: [ &#123;loader: &#x27;css-loader&#x27;, options: &#123;minimize: true/*, url: false*/&#125;&#125;, &#123;loader: &#x27;sass-loader&#x27;, options: &#123;outputStyle: &#x27;compact&#x27;&#125;&#125;, &#123;loader: &#x27;postcss-loader&#x27;, options: &#123; plugins: (loader) =&gt; [ autoprefixer(&#123; browsers: [&#x27;last 2 version&#x27;, &#x27;ie &gt;= 10&#x27;] &#125;) ] &#125;&#125; ], publicPath: &#x27;../&#x27; // background-url 경로 prefix 값으로 들어간다. &#125;) &#125;, &#123; test: /\\.woff(2)?(\\?v=[0-9]\\.[0-9]\\.[0-9])?$/, use: [ &#123;loader: &#x27;url-loader&#x27;, options: &#123; limit: 10000, mimetype: &#x27;application/font-woff&#x27;, name: &#x27;fonts/[name].[ext]&#x27; &#125;&#125; ] &#125;, &#123; test: /\\.(ttf|eot|svg)(\\?v=[0-9]\\.[0-9]\\.[0-9])?$/, use: [ &#123;loader: &#x27;file-loader&#x27;, options: &#123; name: &#x27;fonts/[name].[ext]&#x27; &#125;&#125; ] &#125;, &#123; test: /\\.(jp(e)g|gif|png)?$/, use: [ &#123;loader: &#x27;file-loader&#x27;, options: &#123; name: &#x27;img/[name].[ext]&#x27; &#125;&#125; ] &#125;] &#125;&#125;; 웹팩의 설정 파일의 기본적인 이름은 webpack.config.js이다.그래서 webpack 이라는 명령어만 붙여도 자동으로 webpack.config.js 파일을 인식했는데,우리는 임의로 설정 파일의 이름을 바꿨기 때문에 달리 진행해야한다. 개발을 진행하기 위해서는 터미널에 아래와 같이 입력을 해야한다. 1$ webpack-dev-server -d --config webpack.config.dev.js 배포를 진행하기 위해서는 아래와 같이 입력을 해야한다. 1$ webpack --config webpack.config.prod.js package.json 의 script 에 개발&#x2F;배포 script 지정 하지만 위와 같은 작업은 번들링 할때마다 매우 번거롭게 느낄수 있다. npm의 스크립트를 이용하면 좀 더 간단하게 명령어로 번들링 할 수 있다.우선 위의 개발&#47;배포 명령어를 package.json 의 scripts 부분에 아래와 같이 추가해준다. 12345&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server -d --config webpack.config.dev.js&quot;, &quot;build&quot;: &quot;webpack --config webpack.config.prod.js&quot;, &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;&#125; 이제는 개발을 진행하고자 할 때는 아래와 같이 입력해주면 된다. 1$ npm run dev 배포를 진행하고자 할 때는 아래과 같이 입력해주면 된다. 1$ npm run build 테스트 샘플로 진행한 전체 package.json 파일은 다음과 같다. 123456789101112131415161718192021222324252627282930313233343536373839404142&#123; &quot;name&quot;: &quot;webpack-test&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server -d --config webpack.config.dev.js&quot;, &quot;build&quot;: &quot;webpack --config webpack.config.prod.js&quot;, &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [ &quot;webpack&quot; ], &quot;author&quot;: &quot;woonyzzang&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;devDependencies&quot;: &#123; &quot;autoprefixer&quot;: &quot;^7.1.0&quot;, &quot;babel-core&quot;: &quot;^6.24.1&quot;, &quot;babel-loader&quot;: &quot;^7.0.0&quot;, &quot;babel-preset-latest&quot;: &quot;^6.24.1&quot;, &quot;clean-webpack-plugin&quot;: &quot;^0.1.16&quot;, &quot;css-loader&quot;: &quot;^0.28.1&quot;, &quot;extract-text-webpack-plugin&quot;: &quot;^2.1.0&quot;, &quot;file-loader&quot;: &quot;^0.11.1&quot;, &quot;html-webpack-plugin&quot;: &quot;^2.28.0&quot;, &quot;node-sass&quot;: &quot;^4.5.3&quot;, &quot;postcss-loader&quot;: &quot;^2.0.5&quot;, &quot;raw-loader&quot;: &quot;^0.5.1&quot;, &quot;sass-loader&quot;: &quot;^6.0.5&quot;, &quot;style-loader&quot;: &quot;^0.17.0&quot;, &quot;url-loader&quot;: &quot;^0.5.8&quot;, &quot;webpack&quot;: &quot;^2.5.1&quot;, &quot;webpack-browser-plugin&quot;: &quot;^1.0.20&quot;, &quot;webpack-dev-server&quot;: &quot;^2.4.5&quot;, &quot;webpack-strip&quot;: &quot;^0.1.0&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;bootstrap&quot;: &quot;^3.3.7&quot;, &quot;font-awesome&quot;: &quot;^4.7.0&quot;, &quot;jquery&quot;: &quot;^3.2.1&quot; &#125;&#125; 참조 https://perfectacle.github.io/2016/11/18/Module-bundling-with-Webpck/","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Module","slug":"Frontend/Module","permalink":"https://woonyzzang.github.com/categories/Frontend/Module/"},{"name":"Webpack","slug":"Frontend/Module/Webpack","permalink":"https://woonyzzang.github.com/categories/Frontend/Module/Webpack/"}],"tags":[{"name":"bundler","slug":"bundler","permalink":"https://woonyzzang.github.com/tags/bundler/"},{"name":"webpack","slug":"webpack","permalink":"https://woonyzzang.github.com/tags/webpack/"}]},{"title":"Webpack-v2 Module Plugin","slug":"webpack-v2-module-plugin","date":"2017-05-20T07:30:48.000Z","updated":"2024-06-07T09:27:28.383Z","comments":true,"path":"2017/05/20/webpack-v2-module-plugin/","permalink":"https://woonyzzang.github.com/2017/05/20/webpack-v2-module-plugin/","excerpt":"","text":"Webpack2 Loader Modulewebpack의 로더 모듈을 사용할려면 webpack이 기본적으로 설치 되어 있어야 한다.기본 설치 및 사용법은 webpack 내용 참조webpack 모듈 로더의 경우 작성 문법이 기존과 다르게 변경이 되었다. 여기서는 현재 최신 버전인 webpack2 문법 기준으로 정리한다. babel 로더 webpack 은 babel을 이용하여 EcmaScript2015(ES6) 문법으로 코드 작성이 가능하다. 1$ npm i -D babel-core babel-preset-latest babel-loader babel-core: requireJS 문법을 이용해도 모듈 번들링을 할 수 있지만, ES6의 import, export를 사용해보기 위해 babel을 사용 babel-preset-latest: babel에는 plugin이라는 게 존재한다. 이 plugin은 es6의 애로우 펑션을 지원하는 플러그인, 클래스를 지원하는 플러그인 등등이 있다. 그러한 플러그인을 모아놓은 걸 preset이라고 부른다. es2015 preset은 es6의 플러그인들을 모아놓은 것이고, latest preset은 ES2015~ES2017까지의 프리셋들을 모아놓은 것이다. 시간이 지나면 latest의 지원 프리셋 범위는 더 늘어날 수도 있다. babel-loader: 웹팩과 바벨을 연동해서 사용하기 위한 로더.123456789101112131415161718// webpack.config.jsmodule.exports = &#123; module: &#123; rules: [&#123; test: /\\.js$/, // exclude: /(node_modules|bower_components)/, use: [ &#123;loader: &#x27;babel-loader&#x27;, options: &#123; presets: [ // [&#x27;es2015&#x27;, &#123;moduels: false&#125;] [&#x27;latest&#x27;, &#123;moduels: false&#125;] ] &#125;&#125; ] &#125;] &#125;&#125;; CSS 로더 webpack 은 javascript 모듈뿐만 아니라 css, sass, less도 지원한다. 1$ npm i -D style-loader css-loader node-sass sass-loader postcss-loader autoprefixer style-loader css-loader: css 모듈을 import 시키기 위한 로더 node-sass sass-loader: scss 모듈을 import 시키기 위한 로더 postcss-loader autoprefixer: (s)css 파일 등등에 벤더 프리픽스를 자동으로 붙이는 로더123456789101112131415161718192021222324252627282930313233343536// webpack.config.jsmodule.exports = &#123; module: &#123; rules: [&#123; test: /\\.css$/, // exclude: /node_modules/, use: [ &#x27;style-loader&#x27;, &#123;loader: &#x27;css-loader&#x27;, options: &#123;sourceMap: true&#125;&#125;, &#123;loader: &#x27;postcss-loader&#x27;, options: &#123; plugins: (loader) =&gt; [ autoprefixer(&#123; browsers: [&#x27;last 2 version&#x27;, &#x27;ie &gt;= 10&#x27;] &#125;) ] &#125;&#125; ] &#125;, &#123; test: /\\.(scss|sass)$/, // exclude: /node_modules/, use: [ &#x27;style-loader&#x27;, &#123;loader: &#x27;css-loader&#x27;, options: &#123;sourceMap: true&#125;&#125;, &#123;loader: &#x27;postcss-loader&#x27;, options: &#123; plugins: (loader) =&gt; [ autoprefixer(&#123; browsers: [&#x27;last 2 version&#x27;, &#x27;ie &gt;= 10&#x27;] &#125;) ] &#125;&#125;, &#123;loader: &#x27;sass-loader&#x27;, options: &#123;sourceMap: true&#125;&#125; ] &#125;] &#125;&#125;; file 로더, url 로더 webpack은 css 파일이나 이미지 파일 및 폰트도 하나의 모듈로 인지하기 때문에, 기본적으로 html 파일에서 &lt;img src&#x3D;”image.png”&gt; 요소를 사용하려면, js 파일에서 require(.&#x2F;image.png) 를 따로 선언해주어야 한다.부트스트랩, 폰트어썸, 제이쿼리, 이미지 모듈을 사용하기 위해서는 url-loader와 file-loader 로더를 사용해야 한다. 1$ npm i -D url-loader file-loader 123456789101112131415161718192021222324252627282930// webpack.config.jsmodule.exports = &#123; module: &#123; rules: [&#123; test: /\\.woff(2)?(\\?v=[0-9]\\.[0-9]\\.[0-9])?$/, use: [ &#123;loader: &#x27;url-loader&#x27;, options: &#123; limit: 10000, mimetype: &#x27;application/font-woff&#x27;, name: &#x27;fonts/[name].[ext]&#x27; &#125;&#125; ] &#125;, &#123; test: /\\.(ttf|eot|svg)(\\?v=[0-9]\\.[0-9]\\.[0-9])?$/, use: [ &#123;loader: &#x27;file-loader&#x27;, options: &#123; name: &#x27;fonts/[name].[ext]&#x27; &#125;&#125; ] &#125;, &#123; test: /\\.(jp(e)g|gif|png)?$/, use: [ &#123;loader: &#x27;file-loader&#x27;, options: &#123; name: &#x27;img/[name].[ext]&#x27; &#125;&#125; ] &#125;] &#125;&#125;; webpack2 Pluginwebpack의 플러그인은 js 난독화 플러그인, 번들 파일을 html에 자동으로 삽입해주는 플러그인 등 기본적으로 제공하는 플러그인 외 다양한 종류가 많다. 1$ npm i -D html-webpack-plugin clean-webpack-plugin extract-text-webpack-plugin html-webpack-plugin: html에 번들링 된 bundle.js 파일을 자동으로 삽입하는 플러그인. tmplate에 ejs 등등의 html 템플릿 엔진으로 작성한 걸 넣어주고, filename에 그 템플릿을 토대로 새롭게 만들어질 html 파일을 지정해주면 된다. clean-webpack-plugin: 배포용 파일을 빌드하기 전에 배포용 디렉토리를 지워주는 플러그인 extract-text-webpack-plugin: 스타일 시트를 따로 빼기 위한 플러그인1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// webpack.config.jsmodule.exports = &#123; plugins: [ // 빌드를 시작하기 전에 먼저 배포용 &#x27;build&#x27; 디렉토리를 삭제한다. new CleanWebpackPlugin([&#x27;build&#x27;]), // process.env.NODE_ENV는 개발환경인지 배포환경인지 알고자 할 때 쓰인다. // production이면 배포 모드, development이면 개발환경이다. // 이는 HTML을 핫리로드하게 만들지 안 만들지를 결정하기 위해 썼다. new webpack.DefinePlugin(&#123; &#x27;process.env.NODE_ENV&#x27;: JSON.stringify(&#x27;production&#x27;) &#125;), // Webpack 자동 리로드 new webpack.HotModuleReplacementPlugin(), // Webpack에서 필요로 하는 js 코드를 압축(난독화) new webpack.optimize.UglifyJsPlugin(&#123; compressor: &#123; warnings: false, &#125; &#125;), // 모듈을 할당하고 발생 카운트 아이디들을 발생(?chunk)시킨다. // ID들은 종종 적은(짧은) id들을 얻는데 사용된다. // 이것은 id가 예상가능하며 파일 전체 크기를 경감시켜 추천한다. new webpack.optimize.OccurrenceOrderPlugin(), // HTML bundle.js 자동 삽입 new HtmlWebpackPlugin(&#123; template: &#x27;./src/index.html&#x27;, minify: &#123; collapseWhitespace: true, keepClosingSlash: true, removeComments: true, &#125;, xhtml: true &#125;), // 번들링한 스타일 시트 파일을 병합/압축 및 외부파일로 내보내기 // 내부적으로 css-loader, style-loader를 사용하여 // 한곳에 CSS파일 코드들을 합치고 외부에 bundle.min.css 파일로 결과를 추출한다. new ExtractTextPlugin(&#123; filename: &#x27;./css/bundle.min.css&#x27;, disable: false, allChunks: true, &#125;) ]&#125;; 참조 https://webpack.js.org/ http://d2.naver.com/helloworld/0239818 https://perfectacle.github.io/2016/11/18/Module-bundling-with-Webpck/","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Module","slug":"Frontend/Module","permalink":"https://woonyzzang.github.com/categories/Frontend/Module/"},{"name":"Webpack","slug":"Frontend/Module/Webpack","permalink":"https://woonyzzang.github.com/categories/Frontend/Module/Webpack/"}],"tags":[{"name":"bundler","slug":"bundler","permalink":"https://woonyzzang.github.com/tags/bundler/"},{"name":"webpack","slug":"webpack","permalink":"https://woonyzzang.github.com/tags/webpack/"}]},{"title":"Webpack","slug":"webpack","date":"2017-05-20T05:42:36.000Z","updated":"2024-06-07T09:27:28.384Z","comments":true,"path":"2017/05/20/webpack/","permalink":"https://woonyzzang.github.com/2017/05/20/webpack/","excerpt":"","text":"Webpack 이란?Webpack은 자바스크립트의 모듈링을 도와주는 모듈 번들러 이다.모듈 시스템을 구성하는 기능(CommonJS와 AMD 모듈링 방식을 모두 지원) 외에도 여러가지 리소스를 처리할 수 있는 강력한 로더 기능 사용, 기존의 다른 번들러들보다 빠른 컴파일 속도 및 유용한 플러그인 등 장점이 많다. webpack 사용 방법 webpack은 Node.js가 설치된 환경에서 실행된다. Node.js를 사용하는 환경에서 webpack을 설치하고 모듈을 컴파일하는 방법은 다음과 같다. 설치와 컴파일 webpack은 다음과 같이 npm 명령어로 설치할 수 있다. 12345// 터미널에서 webpack 명령어를 사용하기 위해 글로벌로 웹팩을 설치$ npm i -g webpack// 현재 프로젝트에서 웹팩을 사용하기 위해 설치$ npm i -D webpack webpack이 설치되면 다음 예와 같이 webpack {엔트리 파일 경로} {번들 파일 경로} 형식으로 명령어를 실행해 모듈을 컴파일한다. 1$ webpack ./entry.js bundle.js 엔트리 파일은 다음 그림과 같이 서로 의존 관계에 있는 다양한 모듈을 사용하는 시작점이 되는 파일이다. 번들 파일은 브라우저에서 실행할 수 있게 모듈을 컴파일한 파일이다.webpack에서 컴파일은 엔트리 파일을 시작으로 의존 관계에 있는 모듈을 엮어서 하나의 번들 파일을 만드는 작업이다. JavaScript를 사용하는 HTML 코드에서는 컴파일 결과로 만들어진 번들 파일만 포함하면 된다. 엔트리 파일이 여러 개일 때는 엔트리 파일마다 번들 파일이 생성된다. 설정 파일 사용 CLI(command line interface)로 webpack을 실행해 컴파일할 때 엔트리 파일이 많거나 옵션이 많으면 입력하기 불편하다. 설정 파일을 만들어 컴파일하면 이런 불편을 줄일 수 있다. webpack 설정 파일의 기본 형태는 다음과 같다. 1234567891011121314151617181920212223// webpack.config.js// __dirname은 현재 폴더를 나타낸다.module.exports = &#123; // devtool - 디버깅을 지원한다. // 오류가 발생하는 경우, 크롬 개발자 콘솔과 같은 도구를 이용하여 실수한 위치를 확인하는 데 도움된다. // source-map과 cheap-eval-source-map의 차이에 대해서는 문서를 읽고도 이해하기가 조금 어려웠지만, // 확실히 알 수 있었던 것은 source-map이 제품용 모드에서 오버헤드가 많다는 점과, // cheap-eval-source-map이 더 작은 오버헤드를 가지며, // 이것은 단지 개발을 위한 것이라는 점이다. devtool: &#x27;source-map&#x27;, // 생략 가능 // 번들의 엔트리 파일 포인트 entry: &#123; app: &#x27;./app.js&#x27; &#125;, // Webpack의 최종 결과물이 되는 형태를 명시 output: &#123; path: __dirname + &#x27;/dist&#x27;, // 번들 파일 폴더 filename: &#x27;[name].bundle.js&#x27; // 번들 파일 이름 규칙 &#125;&#125;; 위와 같은 형태로 webpack.config.js 파일을 작성해 저장한다. 설정 파일이 있는 디렉토리에서 다음과 같이 간단하게 명령어를 입력하면 컴파일을 실행한다. 1$ webpack webpack 명령어를 치면 기본적으로 webpack.config.js 파일을 찾는다. 하지만 보통 프로덕션, 테스팅, 로컬 환경에 따라 다른 파일을 쓰게 되므로 다른 설정파일을 쓰고 싶은 경우 webpack –config 설정파일경로 로 설정한다 1$ webpack --config &#123;@파일명&#125;.js // 특정한 이름의 사용자가 정의한 Webpack 설정 파일을 사용하는 경우 컴파일 명령어에 --watch 나 -w 옵션을 사용하면 모듈 파일이 변경될 때마다 변경된 모듈을 자동으로 다시 컴파일한다. 12// Webpack에서 파일의 상태가 변경되면 자동으로 빌드$ webpack --watch || -w webpack을 사용할 때는 다양한 설정을 함께 사용하는 경우가 대부분이라 설정 파일로 컴파일하는 사례가 많다. 더 다양한 설정 옵션과 자세한 설명은 webpack 문서의 Configruation에서 확인할 수 있다. 참조 https://webpack.js.org/ http://d2.naver.com/helloworld/0239818","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Module","slug":"Frontend/Module","permalink":"https://woonyzzang.github.com/categories/Frontend/Module/"},{"name":"Webpack","slug":"Frontend/Module/Webpack","permalink":"https://woonyzzang.github.com/categories/Frontend/Module/Webpack/"}],"tags":[{"name":"bundler","slug":"bundler","permalink":"https://woonyzzang.github.com/tags/bundler/"},{"name":"webpack","slug":"webpack","permalink":"https://woonyzzang.github.com/tags/webpack/"}]},{"title":"Windows VMware Mac OS","slug":"windows-vmware-mac","date":"2017-05-18T09:57:46.000Z","updated":"2024-06-07T09:27:28.386Z","comments":true,"path":"2017/05/18/windows-vmware-mac/","permalink":"https://woonyzzang.github.com/2017/05/18/windows-vmware-mac/","excerpt":"","text":"Windows의 VMware에 macOS Sierra 설치하기윈도우 환경에서 VMware인 가상머신을 이용하여 Mac OS 시에라 버전을 설치하는 방법을 정리한다. 다운로드 VMware Unlocker v2.0.8 macOS Sierra 이미지 파일 VM Tool 설치 방법 VMware를 설치한다. Unlocker를 영문으로 된 폴더에 압축을 푼다.(폴더 경로 상에 한글이 포함되지 않도록 주의) Unlocker 폴더에서 win-install.cmd를 관리자 권한으로 실행한다. VMware에서 ‘Create a New Virtual Machine’ 선택 Typical 선택 I will install the operating system later. 선택 Guset operating system에서 Apple Mac OS X, Version에서 macOS 10.12 선택(만약 선택 리스트에서 Apple 제품이 표시되지 않는다면 위의 Unlocker 실행이 정상적으로 되지 않은 것이므로, 관리자 권한으로 다시 실행해 보시기 바란다.) 원하는 이름과 경로 선택 디스크 크기는 변경하지 않고 ‘Store virtual disk as a single file’ 선택 Edit Virtual Machine Setting에서 Hard Disk (SATA) 40 GB 선택하고 Remove 선택 Add 클릭하고 Hard Disk, SATA, Use an Existing Virtual Disk 선택 아까 다운로드 받은 Sierra 이미지 파일을 영문 폴더에 압축을 푼다. 마찬가지로 경로 상에 한글이 포함되지 않아야 한다. Sierra 이미지 파일을 선택한다. Ram을 4 GB로 변경하고 Processor를 4 core로 변경한다. 아까 원하는 경로를 선택한 곳에서(ex. \\Documents\\Virtual Machines\\macOS 10.12) &#96;vmx’ 파일을 메모장으로 연다. 맨 마지막 줄에 smc.version &#x3D; “0”이라고 추가하고 저장한다. 버추얼 머신을 실행하여 맥을 설치한다. 맥 설치 후 실행한 후에, VM – Removable Devices – CD&#x2F;DVD – Setting…을 선택한다. VM Tool.iso를 선택하면 맥에서 설치 창이 뜨는데 설치를 진행한다. 18, 19번 과정은 필수 과정은 아니며, VMware로 맥을 더 편하게 사용하기 위해 추가로 소프트웨어를 설치하는 과정이다. VMware 버전에 따라서 알아서 자동으로 설치를 유도하는 경우도 있다. 설치 후 해상도 이슈 해결 VMware로 맥을 설치하니 크기가 너무 작게 표시된다면 이를 해결하기 위해 맥을 실행한 후에 터미널에서 아래 명령어를 실행하면 된다. 1sudo defaults write /Library/Preferences/com.apple.windowserver.plist DisplayResolutionEnabled -bool true 그런 후에 재부팅을 하면 디스플레이 설정에 해상도가 추가로 노출될 것이다. 해당 해상도를 선택하면 레티나가 적용되어 적당한 크기로 화면에 표시된다. 참조 http://bimmermac.com/2228","categories":[{"name":"OS","slug":"OS","permalink":"https://woonyzzang.github.com/categories/OS/"},{"name":"Windows","slug":"OS/Windows","permalink":"https://woonyzzang.github.com/categories/OS/Windows/"}],"tags":[{"name":"vmware","slug":"vmware","permalink":"https://woonyzzang.github.com/tags/vmware/"},{"name":"windows","slug":"windows","permalink":"https://woonyzzang.github.com/tags/windows/"}]},{"title":"Fiddler Proxy Mobile Web Debugging","slug":"fiddler-proxy-mobile-web-debugging","date":"2017-05-17T11:38:24.000Z","updated":"2024-06-07T09:27:28.300Z","comments":true,"path":"2017/05/17/fiddler-proxy-mobile-web-debugging/","permalink":"https://woonyzzang.github.com/2017/05/17/fiddler-proxy-mobile-web-debugging/","excerpt":"","text":"fiddler proxy 설정으로 모바일웹 디버깅 하기모바일의 특성상 디버그하기기 좀 까다로운 부분이 있다.그래서 fiddler 툴을 활용하여 proxy 셋팅 후 활용하는 방법을 소개한다.(모바일 디바이스 기기하고 로컬 pc하고 같은 네트워크 Wifi 안에 물려있어야 있어야 한다) 안드로이드 폰은 무선랜을 연결할 때 proxy를 설정할 수가 있다.이 기능을 이용해 정상적인 url로 호출되고 있는지 등을 확인이 가능하다. 설정 방법 1.안드로이드 폰 계열 무선랜 설정(갤럭시 노트 디바이스로 테스트를 진행했다.)무선랜을 연결할 때 proxy 설정을 해준다. (피들러에서 설정한 port 번호, fiddler가 설치된 PC의 IP) 사용자 로컬 PC IP 확인하는 방법 Windows: 콘솔창에 ipconfig 명령어 입력해서 확인.Max OSX: 터미널에 ifconfig 명령어 입력해서 확인. 2.피들러 설정피들러 옵션은 Allow remote computer to connect 설정을 체크(활성화)하고 Fiddler listens on port만 확인하면 된다. 3.확인하고 싶은 부분을 호출한다.4.피들러에서 캡쳐되는 정보를 확인한다.(PC 웹에서 확인하는 것과 동일하게 정보를 확인한다)","categories":[{"name":"Tools","slug":"Tools","permalink":"https://woonyzzang.github.com/categories/Tools/"},{"name":"Fiddler","slug":"Tools/Fiddler","permalink":"https://woonyzzang.github.com/categories/Tools/Fiddler/"}],"tags":[{"name":"fiddler","slug":"fiddler","permalink":"https://woonyzzang.github.com/tags/fiddler/"},{"name":"mobile","slug":"mobile","permalink":"https://woonyzzang.github.com/tags/mobile/"},{"name":"tip","slug":"tip","permalink":"https://woonyzzang.github.com/tags/tip/"}]},{"title":"EcmaScript This Binding","slug":"javascript-ecmascript-this","date":"2017-05-16T13:20:33.000Z","updated":"2024-06-10T04:53:59.555Z","comments":true,"path":"2017/05/16/javascript-ecmascript-this/","permalink":"https://woonyzzang.github.com/2017/05/16/javascript-ecmascript-this/","excerpt":"","text":"ECMAScript this자바스크립트에서는 매번 함수의 호출마다 새로운 실행 구문(Execution Context)가 생성된다. Execution Context는 Lexical Environment, Variable Environment, 그리고 ThisBinding에 대한 정보를 가지고 있는데, 바로 this 키워드가 이 이 thisbinding이라고 할 수 있겠다. this값은 해당 함수가 현재 어느 Execution Context에서 구동하고 있는지를 알려준다. Context는 함수 호출에 의해 새로이 생성되며, thisBinding 값은 함수 호출시점에 정해지게 된다.쉽게 설명하자면 자바스크립트에서 this는 기본적으로 전역객체(브라우저에서는 window)지만 상황(실행 구문)에 따라 다른 값을 반환 한다고 생각하면 된다. 우선 몇 가지 먼저 기억해 둘 사항 1.자바스크립트에서 코드는 다음 세 가지 영역에서 수행된다: global 영역 function 영역 eval 영역 2.this 키워드는 다음 두 가지 조건에 의해 값이 결정된다. 어떤 실행 구문(Execution Context)에서 수행되었는가 호출자가 누구인가 3.global 객체에 대해 이해해야 한다. 자바스크립트가 구동 될 때에는 언제나 global 객체가 존재한다. 브라우저에서는 window 객체가 그 역할을 하고 있고, node.js에서는 그냥 global object로 불리는 객체가 하나 있다. ES5 [함수로서 호출할 경우] 123456789&#x27;use strict&#x27;;var a = function() &#123; // 함수로서 호출할 때 // strict mode에서는 undefined // non-strict mode에서는 Window console.log(this);&#125;;a(); [생성자 함수로서 호출할 경우] 1234567891011&#x27;use strict&#x27;;var b = function() &#123; // 생성자로서 호출할 때 this.a = &#x27;1&#x27;; this.b = function() &#123;&#125;; // this === &#123;a: 1, b: function() &#123;&#125;&#125; // 인스턴스 멤버(변수, 메소드)를 포함하고 있는 객체 console.log(this);&#125;;new b(); [객체의 메소드로서 호출할 경우] 123456789101112131415161718192021222324&#x27;use strict&#x27;;var C = &#123; a: function() &#123; // 메소드로서 호출할 때 console.log(this); // C &#125;, b: function() &#123; // 메소드로서 호출할 때 var a = function() &#123; // 함수로서 호출해버리면 this를 재바인딩함. // strict mode에서는 undefined // non-strict mode에서는 Window console.log(this); &#125;; a(); &#125;, c: function() &#123; // 메소드로서 호출할 때 // 메소드를 호출 this.a(); // C &#125;&#125;;C.a();C.b();C.c(); ES6 새로 나온 애로우 펑션은 this를 바인딩하지 않는다.call, apply, bind 메소드로도 강제 바인딩이 이루어지지 않는다. 상위 스코프로부터 상속 받을 뿐이다. [일반 함수로서 호출할 경우] 1234567const a = function() &#123; // 함수로서 호출할 때 // strict mode에서는 undefined // non-strict mode에서는 Window console.log(this);&#125;;a(); [애로우 펑션으로서 호출할 경우] 12345678910111213141516const b = () =&gt; &#123; // 애로우 펑션은 strict mode 여부에 상관없이 Window // 전역에서 this가 Window이기 때문에 상속받는 것임. console.log(this); // Window&#125;;b();const _b = () =&gt; &#123; console.log(this);&#125;;// 전부 다 Window가 출력됨_b.call(&#123;a: 1&#125;);_b.apply(&#123;a: 1&#125;);_b.bind(&#123;a: 1&#125;)(); // ES5에서는 this값을 넘기기 위해서 bind를 사용할 수도 있다. 중첩된 함수 내에서 this의 컨텍스트를 보존하는 용도로 종종 사용된다. [클래스]ES6 들어서 생성자 함수를 대체할 수 있는 클래스란 개념이 추가되었다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147// 함수를 통해 객체의 인스턴스를 생성하던 것 대신에 클래스가 등장함.// 멤버: 변수와 메소드// 클래스 멤버: new 생성자 함수를 통해 생성된 인스턴스마다 동일한 값을 가짐.(공유함)// 클래스의 인스턴스가 생기기 전에도 클래스이름.멤버로 사용 가능.// static으로 생성된 메소드 및 prototype이 이에 해당.// 인스턴스 멤버: new 생성자 함수를 통해 생성된 인스턴스마다 다른 값을 가짐.(공유하지 않음)// 클래스의 인스턴스가 생기기 전에는 사용 불가능, 인스턴스이름.멤버로 사용 가능// 생성자 함수 내부에 작성된 애들이나 static 키워드를 쓰지 않고 생성한 메소드들이 해당됨.class C &#123; constructor() &#123; // 생성자 함수 외부에서 인스턴스 변수를 선언하지 못한다. this.a = 1; this.b = () =&gt; &#123;&#125;; // 인스턴스 멤버(변수, 메소드)를 포함하고 있는 객체 // &#123; // a: 1, // b: () =&gt; &#123;&#125;, // __proto__: &#123; // 상속받는 놈이기 때문에 바로 this.d()와 같이 사용 가능. // 위에 있는 놈들과 이름이 같다면 위에 있는 놈들이 우선 순위를 가짐. // d: function() &#123;&#125;, // e: function() &#123;&#125;, // f: function() &#123;&#125;, // g: function() &#123;&#125; // &#125; // &#125; console.log(this); &#125; // 클래스 메소드의 this는 // 클래스 멤버(변수, 메소드) 등등을 담고있는 생성자 함수이다. // 클래스 변수는 클래스 내에서 선언하지 못하고, // className.prototype.variable = value 와 같이 선언한다. static a() &#123; // function, 함수 또한 객체기 때문에 프로퍼티로 접근이 가능하다. console.log(typeof this); // new this(); 이렇게 생성자를 호출할 수도 있다. // __proto__는 상속받는 놈들이기 때문에 바로 this.머시기로 사용할 수 있었으나 // prototype은 상속해주는 놈들이기 때문에 this.prototype.머시기로 사용해야한다. // &#123; // a: function() &#123;&#125;, // b: function() &#123;&#125;, // c: function() &#123;&#125;, // prototype: &#123; // a: 1 // &#125; // &#125; console.dir(this); &#125; static b() &#123; const a = function() &#123; // 함수로서 호출하면 this를 재바인딩 // strict mode에서는 undefined // non-strict mode에서는 Window console.log(this); &#125;; a(); &#125; static c() &#123; const a = () =&gt; &#123; // 애로우 펑션은 this를 상속받음. // function, 함수 또한 객체기 때문에 프로퍼티로 접근이 가능하다. console.log(typeof this); // new this(); 이렇게 생성자를 호출할 수도 있다. // __proto__는 상속받는 놈들이기 때문에 바로 this.머시기로 사용할 수 있었으나 // prototype은 상속해주는 놈들이기 때문에 this.prototype.머시기로 사용해야한다. // &#123; // a: function() &#123;&#125;, // b: function() &#123;&#125;, // c: function() &#123;&#125;, // prototype: &#123; // a: 1 // &#125; // &#125; console.dir(this); &#125;; a(); &#125; // 인스턴스 메소드의 this는 생성자 내의 this와 일치한다. d() &#123; // 인스턴스 멤버(변수, 메소드)를 포함하고 있는 객체 // &#123; // a: 1, // b: () =&gt; &#123;&#125;, // __proto__: &#123; // 상속받는 놈이기 때문에 바로 this.d()와 같이 사용 가능. // 위에 있는 놈들과 이름이 같다면 위에 있는 놈들이 우선 순위를 가짐. // d: function() &#123;&#125;, // e: function() &#123;&#125;, // f: function() &#123;&#125;, // g: function() &#123;&#125; // &#125; // &#125; console.dir(this); &#125; e() &#123; const a = function() &#123; // 역시 ES5식 함수는 this를 덮어버린다. // strict mode에서는 undefined // non-strict mode에서는 Window console.log(this); &#125;; a(); &#125; f() &#123; const a = () =&gt; &#123; // 역시 애로우 펑션은 this를 상속 받음. // 인스턴스 멤버(변수, 메소드)를 포함하고 있는 객체 // &#123; // a: 1, // b: () =&gt; &#123;&#125;, // __proto__: &#123; // 상속받는 놈이기 때문에 바로 this.d()와 같이 사용 가능. // 위에 있는 놈들과 이름이 같다면 위에 있는 놈들이 우선 순위를 가짐. // d: function() &#123;&#125;, // e: function() &#123;&#125;, // f: function() &#123;&#125;, // g: function() &#123;&#125; // &#125; // &#125; console.log(this); &#125;; a(); &#125; g() &#123; // 인스턴스의 this에 클래스 멤버는 없다. // 따라서 클래스 멤버를 사용할 수는 없다. // this.a(); // 클래스 메소드 사용 불가. this.f(); // 인스턴스 멤버(메소드, 변수)는 사용 가능하다. &#125;&#125;// 클래스 변수는 클래스 내에서 선언하지 못함.// 레거시 환경을 지원하기 위해 프로토타입 방식의 상속을 포기하지 못했기 때문인 듯 하다.C.prototype.q = 1;const c = new C();C.a();C.b();C.c();c.d();c.e();c.f();c.g(); [객체의 메소드로서 호출할 경우]ES6에서 객체의 메소드를 key: function() {} 대신에 key() {}와 같이 줄여쓸 수 있게 됐는데 두 개는 동일하다고 봐도 된다. 12345678910111213141516171819202122232425262728293031323334353637const d = &#123; a: function() &#123; // 메소드로서 호출할 때 console.log(this); // d &#125;, b: () =&gt; &#123; // 애로우 펑션은 바로 상위 스코프인 전역의 this를 상속받음. console.log(this); // Window &#125;, c() &#123; // a 메소드와 다를 바가 없다. console.log(this); // d &#125;, d() &#123; // 메소드로서 호출할 때 const a = function() &#123; // 역시 그냥 펑션은 this를 재바인딩함. // strict mode에서는 undefined // non-strict mode에서는 Window console.log(this); &#125;; a(); &#125;, e() &#123; // 메소드로서 호출할 때 const a = () =&gt; &#123; // 애로우 펑션은 상위 스코프에 있는 this를 상속 받음. console.log(this); // d &#125;; a(); &#125;&#125;;d.a();d.b();d.c();d.d();d.e(); [별도의 컨텍스트를 만드는 함수]setTimeout, setInterval 함수는 함수 선언 시점과 함수 호출 시점에 별개의 컨텍스트를 가지는 대표적인 함수이다. 1234567891011121314151617181920212223242526272829const e = &#123; a() &#123; console.log(this); &#125;, b() &#123; // setTimeout은 별개의 컨텍스트를 만든다. // 바로 실행시점에 컨텍스트를 만드는데, 실행 시점의 this는 전역의 this(Window)가 된다. setTimeout(this.a, 1000); &#125;, c() &#123; setTimeout(function() &#123; // setTimeout은 별개의 컨텍스트를 만든다. // 바로 실행시점에 컨텍스트를 만드는데, 실행 시점의 this는 전역의 this(Window)가 된다. console.log(this); &#125;, 2000); &#125;, d() &#123; setTimeout(() =&gt; &#123; // setTimeout은 별개의 컨텍스트를 만든다. // 바로 실행시점에 컨텍스트를 만드는데, 실행 시점의 this는 전역의 this(Window)가 된다. // 하지만 애로우 펑션을 쓰면 클로저가 형성된다. // 실행 시점의 this(Window)와 선언 시점의 this(e 객체)가 달라서 그것을 동기화(?)시키기 위해서 클로저가 형성되는 듯 하다. console.log(this); // e &#125;, 3000); &#125;&#125;; 하지만 애로우 펑션으로 래핑하면 클로저를 형성해서 원하는 결과를 얻어낼 수 있다. 참조 https://perfectacle.github.io/2017/02/15/es-this/","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Javascript","slug":"Frontend/Javascript","permalink":"https://woonyzzang.github.com/categories/Frontend/Javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://woonyzzang.github.com/tags/js/"},{"name":"es6","slug":"es6","permalink":"https://woonyzzang.github.com/tags/es6/"}]},{"title":"CSS3 Conditional Statements","slug":"css3-conditional-statements","date":"2017-05-16T12:56:57.000Z","updated":"2024-06-07T09:27:28.276Z","comments":true,"path":"2017/05/16/css3-conditional-statements/","permalink":"https://woonyzzang.github.com/2017/05/16/css3-conditional-statements/","excerpt":"","text":"CSS3 Conditional Statements미디어 쿼리에 대한 스펙 ‘CSS 3 Conditional Statements’에서는 미디어쿼리 @media 외에도 @supports와 @document 지시자를 사용한 새로운 기능에 대해서도 정의를 하고 있다. @supports 특정 css 속성을 브라우저가 지원하는지 또는 하지 않는지 판단하여 특정 스타일이 적용 되도록 할수 있다. 12345678910111213/* box-shadow 속성을 지원하는 경우 적용 */@supports (box-shadow: 0 0 10px rgba(0,0,0,.1)) &#123; CSS code... &#125;/* animation-duration 속성이 지원되지 않는 경우 적용 */@supports not (animation-duration: 1s) &#123; CSS code... &#125;/* and, or 연산자를 사용한 조건식을 사용할 수도 있다. */@supports ((border-radius:4px) and (transition-duration: 1s)) or (transform-origin: 5% 5%) &#123; CSS Code...&#125;/* @supports를 활용하면 특정 속성이 지원되는 브라우저의 경우, 별도의 css 파일을 로딩하도록 처리할 수 있다. */@supports (box-shadow: 0 0 10px rgba(0,0,0,0.1)) &#123; @i-port url(&#x27;box-shadow.css&#x27;);&#125; 지원 브라우저: FF 17.0+ Spec: http://dev.w3.org/csswg/css3-conditional/#at-supports 참고: https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;CSS&#x2F;@supports @document 조건식에 부합되는 주소를 갖는 페이지에만 스타일이 적용되도록 할수 있다. 1234567891011/* www.naver.com 인덱스 페이지에만 적용 */@document url(&quot;http://www.naver.com/&quot;) &#123; CSS Code... &#125;/* www.naver.com/css로 시작되는 모든 페이지에 적용 */@document url-prefix(&quot;http://www.naver.com/css&quot;) &#123; CSS Code... &#125;/* naver.com 도메인에 속하는 모든 페이지에 적용 */@document domain(&quot;naver.com&quot;) &#123; CSS Code... &#125;/* 정규식을 사용해 https:로 시작되는 모든 주소 페이지에 적용 */@document regexp(&quot;https:.*&quot;) &#123; CSS Code... &#125; 지원 브라우저: FF 6.0+ Spec: http://dev.w3.org/csswg/css3-conditional/#at-document 참고: https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;CSS&#x2F;@document 참조 http://egloos.zum.com/jaures/v/2989183","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"CSS","slug":"Frontend/CSS","permalink":"https://woonyzzang.github.com/categories/Frontend/CSS/"}],"tags":[{"name":"css","slug":"css","permalink":"https://woonyzzang.github.com/tags/css/"},{"name":"css3","slug":"css3","permalink":"https://woonyzzang.github.com/tags/css3/"}]},{"title":"fiddler","slug":"fiddler","date":"2017-05-16T12:34:59.000Z","updated":"2024-06-07T09:27:28.300Z","comments":true,"path":"2017/05/16/fiddler/","permalink":"https://woonyzzang.github.com/2017/05/16/fiddler/","excerpt":"","text":"피들러란?컴퓨터와 인터넷 사이의 HTTP(s) 트래픽에 대한 모든 로그를 확인할 수 있는 무료 웹 디버깅툴이다.클라이언트(컴퓨터)에서 서버로 요청한 내역과 결과의 모든 데이터를 확인이 가능하고 실서비스 되는 페이지의 이슈나 버그를 해결하고자 할 때 실서버에 파일을 올리지 않고도 미리 확인해 볼 수 있는 유용한 기능을 가지고 있다. 피들러 주요 기능 HTTP&#x2F;HTTPS Traffic Recording Web Session Manipulation Web Debugging Security Testing Performance Testing Customizing Fiddler 다운로드http://www.telerik.com/download/fiddler","categories":[{"name":"Tools","slug":"Tools","permalink":"https://woonyzzang.github.com/categories/Tools/"},{"name":"Fiddler","slug":"Tools/Fiddler","permalink":"https://woonyzzang.github.com/categories/Tools/Fiddler/"}],"tags":[{"name":"server","slug":"server","permalink":"https://woonyzzang.github.com/tags/server/"},{"name":"fiddler","slug":"fiddler","permalink":"https://woonyzzang.github.com/tags/fiddler/"}]},{"title":"Ubuntu OS Install Partition","slug":"ubuntu-os-install-partition","date":"2017-05-16T07:16:35.000Z","updated":"2024-06-07T09:27:28.378Z","comments":true,"path":"2017/05/16/ubuntu-os-install-partition/","permalink":"https://woonyzzang.github.com/2017/05/16/ubuntu-os-install-partition/","excerpt":"","text":"효과적인 우분투의 파티션 구성우분투를 처음 설치하는 분들은 이런저런 고민이 많을 것이다. 처음보는 생소한 단어나 용어들의 어려움이 있을 것이다. 그 중 대표적인 것 하나가 바로 우분투 설치시 파티션의 구성 및 설정들의 대한 부분이다.이번엔 우분투에서 효과적으로 파티션을 구성하는 방법에 대해 알아보도록 하겠다. 한 개의 하드디스크에 우분투만 사용할 경우 이 경우에는 대부분 리눅스나 우분투의 초보자들이 하는 실수 중 하나가 하드디스크에 통째로 우분투를 설치하는 것이다.이렇게 설치하게 되면 우선 피치 못 할 사정으로 포맷을 해야 할 경우 기존의 자료들을 백업조차 할 수 없게 된다. 굳이 윈도우(Windows)에 비유하자면 오직 ‘C 드라이브’만 있는 경우에 해당된다. 이런 경우에는 ‘&#x2F;, &#x2F;home, 스왑 영역’으로 총 세개의 파티션을 만드는 것이 좋다. ‘스왑 영역(Swap space)’이란 리눅스에서 ‘물리적 메모리(physical memory, RAM)’이 가득 찼을 경우 사용하게 되는 공간이다. 보통은 램(RAM)의 크기에 비례해서 설치하는데 2GB(약 2000메가바이트)면 충분하다. ‘&#x2F;‘파티션은 윈도에 비유하면 ‘C:&#x2F;Windows’ 라 생각하면 된다. 윈도의 경우 ‘C 드라이브’의 크기를 고려할 때 이후 설치할 프로그램의 용량까지 계산해야 하지만, 리눅스의 경우는 설치된 프로그램의 경로가 ‘&#x2F;home’인 경우가 대부분이므로 5GB~20GB정도만 설정하면 된다. ‘&#x2F;home’파티션은 윈도에 비유하면 ‘D 드라이브 + Documents and Settings + C:&#x2F;Program Files’ 라 생각하면 된다. 결국 앞으로 포맷해서는 안 될 상당히 중요한 부분인 것이다. ‘&#x2F;home’파티션의 용량은 나머지 용량 전체를 사용하면 된다. 예를 들어, 130GB의 하드디스크 한 개에 우분투만 사용하는 경우 ‘스왑 영역 &#x3D; 2000메가바이트(2GB)’, ‘&#x2F; &#x3D; 15000메가바이트(15GB)’, ‘&#x2F;home &#x3D; 약 113000메가바이트(113GB)’ 정도로 잡으면 충분하다. 한 개의 하드디스크에 우분투와 윈도우를 사용할 경우 이 경우 더 고려해야 할 부분이 생긴다. 바로 어떤 OS로 부팅할 것인지 선택하게 도와주는 GRUB 때문인데 가장 편리한 방법은 윈도우를 먼저 설치하고 이후에 우분투를 설치하는 것이다.이렇게 되면 GRUB가 정상적으로 두가지 OS를 모두 인식할 수 있게 된다. 반대로 우분투를 먼저 설치하고 윈도우를 설치할 경우 부트로더 문제로 윈도우가 아예 설치가 되지 않는 이슈가 생긴다. 이런 경우에는 파티션을 ‘NTFS(윈도우 설치), &#x2F;(리눅스 설치), 스왑 영역, FAT32(이후 NTFS로 변경 후 백업 공간)’으로 만드는 것을 추천한다.‘&#x2F;home’파티션을 따로 만들지 않는 것은 윈도우와 공유 할 파티션이 필요하기 때문에 이것을 NTFS파티션으로 대체하는 것이다. 용량은 사용하는 패턴에 따라 다르겠지만, ‘NTFS(윈도우 설치) &#x3D; 50GB’, ‘&#x2F; &#x3D; 30GB’, ‘스왑 영역 &#x3D; 2GB’, ‘FAT32 &#x3D; 48GB’정도로 잡는 것을 권장한다. ‘&#x2F;‘파티션의 용량을 위의 경우보다 크게 잡은 까닭은 ‘&#x2F;home’파티션을 따로 만들지 않을 경우 저절로 ‘&#x2F;‘파티션 밑에 생성되기 때문이다. 적어도 몇가지 프로그램을 설치하고 여유있게 사용하기 위해선 30GB정도는 필요하다.‘FAT32’는 이후에 NTFS로 포맷하여 두가지 OS에서 모두 이용할 수 있도록 한다. 두 개의 하드디스크에 우분투와 윈도우를 사용할 경우 우선 한가지 알아둬야 할 점은, 우분투에서는 첫번째 하드디스크를 ‘sda’, 두번째 하드디스크를 ‘sdb’라고 인식한다. 그리고 뒤에 번호가 붙으면서 해당 파티션의 이름이 정해지는 것이다. 1234// 멀티 하드디스크 예)첫번째 하드디스크(320GB): &#x27;/(100GB), 스왑 영역(4GB), 저장공간1(EXT4, 216GB)&#x27; // 우분투두번째 하드디스크(500GB): &#x27;시스템 예약(105MB), NTFS(윈도우 설치, 200GB), 저장공간2(NTFS, 200GB), 저장공간3(NTFS, 100GB)&#x27; // 윈도우 우분투가 sda1(첫번째 하드디스크의 첫번째 파티션)에 설치되는 바람에 위에 언급했듯이 부트로더 문제로 윈도 설치가 제대로 되지 않는 현상이 생긴 경우라면 바로 첫번째 하드디스크를 제거한 후 두번째 하드디스크에 윈도를 설치한다. 즉, 본체에서 첫번째 하드디스크를 제거한 후 두번째 하드디스크밖에 없다고 인식한 상태에서 윈도를 설치하는 것이다.이 경우 윈도 설치가 끝나고 첫번째 하드디스크를 다시 연결하면 GRUB가 저절로 윈도 파티션을 인식해서 이용할 수 있다. GRUB나 부트로더에 대한 접근이 어려운 사용자들에게 좋은 방법이 아닐까 생각된다. 두 개의 하드디스크를 사용하는 분들은 파티션 나누는데 워낙 자유롭기 때문에 별도의 예를 생략하고 위의 두 경우를 예로 설치하는 것이 좋겠다. 우분투 파티션 구성후 OS 설치하는 방법모든 경우에 맞는 파티션을 나누는 방법을 설명하기엔 다소 한계가 있으니 ‘한 개의 하드디스크에 우분투만 사용할 경우’를 예를 들어 설명한다.우분투 OS 설치 참조 우선 우분투 설치 진행 도중 기타를 선택한다. 아무것도 설치되지 않은 하드디스크의 경우 위와 같이 ‘&#x2F;dev&#x2F;sda’만 표시된다.‘새 파티션 테이블’을 클릭한다. ‘계속’을 클릭한다. 이제부터 파티션을 설정한다. ‘추가’를 클릭한다. ‘주 파티션’을 선택하고, 크기를 정한 뒤, 용도(형식)를 ‘EXT4 저널링 파일 시스템’으로, 마운트 위치를 ‘&#x2F;‘을 선택하고 확인을 누른다. 다시 ‘추가’를 클릭하고 ‘논리 파티션’, 크기를 정한 뒤, 용도를 ‘스왑 영역’으로 선택하고 확인을 누른다. 다시 ‘추가’를 클릭하고 ‘논리 파티션’, 남은 용량을 모두 정한 뒤, 용도를 ‘EXT4 저널링 파일 시스템’, 마운트 위치를 ‘&#x2F;home’으로 선택하고 확인을 누른다. 이제 위와 같이 설정했다면 위와 같이 표시되는데 ‘지금 설치’를 클릭해서 OS 설치를 진행하면 된다. 참조 http://deviantcj.tistory.com/434","categories":[{"name":"OS","slug":"OS","permalink":"https://woonyzzang.github.com/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"https://woonyzzang.github.com/categories/OS/Linux/"},{"name":"Ubuntu","slug":"OS/Linux/Ubuntu","permalink":"https://woonyzzang.github.com/categories/OS/Linux/Ubuntu/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://woonyzzang.github.com/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://woonyzzang.github.com/tags/ubuntu/"}]},{"title":"Ubuntu OS Install","slug":"ubuntu-os-install","date":"2017-05-15T17:01:35.000Z","updated":"2024-06-07T09:27:28.379Z","comments":true,"path":"2017/05/16/ubuntu-os-install/","permalink":"https://woonyzzang.github.com/2017/05/16/ubuntu-os-install/","excerpt":"","text":"Ubuntu OS 설치하기Ubuntu Linux는 데비안 계열의 리눅스 배포본으로 APT, Unity등 사용자 편의성에 초점을 맞춘 툴들이 많이 존재하고 가장 대중적인 리눅스로 리눅스를 처음 접하는 사람이 사용하기에 적당하다. 설치 버전 선택 현재 Ubuntu Desktop의 최신버전 배포버전은 17.04 이다.하지만 Ubuntu는 최신 버전보다는 더 오래 지원해주는 LTS(Long Term Support) 버전을 받는 것이 좋다.LTS버전은 매 짝수년 4월에 출시되는 04버전이다. (… 12.04, 14.04, 16.04, 이후 18년4월에 LTS버전이 나올 예정)마지막 LTS버전은 16년 4월에 출시한 16.04.2 이므로 16.04.2 LTS 버전을 추천 한다. Ubuntu 설치 방식 우분투 설치 방식에는 아래와 같이 여러가지 방법이 있다. Native 설치: 가장 보편적인 설치법으로 하드디스크의 시스템에 설치하는 방식이다. Wubi (Windows UBuntu Installer): 가장 쉬운 설치법으로 가상 하드디스크의 시스템에 설치하는 방식이다. 가상화 시스템에 설치: 가장 안전한 설치법으로 Virtual Box등 가상화 시스템을 이용한다. 가상 하드디스크의 가상시스템에 설치하는 방식이다. Wubi 방식은 Windows 8 배포후 SecureBoot, EFI 등 여러 신기술의 등장으로 개발이 중단되어 더이상 정식 지원이 되지 않는다. 또한 최신 노트북에서 호환성 문제가 있어 사용하지 못한다.가상화 방식은 안전하지만 컴퓨터 사양이 좋지 않다면 속도가 느리고 제한적인 그래픽 가속으로 실제 사용에는 무리가 있다.(간단한 테스트용으로는 적합하다.)그래서 남은 방식의 Native 설치를 기준으로 설명한다. Ubuntu OS 이미지 다운로드 Ubuntu 공식 홈페이지 https://www.ubuntu.com/에 접속한다.메뉴에서 Desktop &gt; Download Ubuntu 버튼을 클릭하거나 Downloads &gt; Desktop을 누른다. 윈도우 환경의 사용자는 32-bit&#x2F;64-bit를 선택할 수 있는데 컴퓨터 사양이 램(RAM)이 8GB 이상이면 64-bit를 권장한다. 우분투 다운로드 홈페이지에서는 2GB 이하의 램에는 32-bit 버전을 권장하고 있다.그럼 사용자 환경에 맞는 설치할 버전의 확인 후 우측 ‘Download’ 버튼을 눌러 진행한다. 이와 같은 화면에서 아래로 내리면 총 $15 라는 안내와 함께 ‘Pay with Paypal’ 이라는 버튼이 보이는데 이건 유료 결제(기부) 이므로 무시하고, 좌측의 Not now, take me to the download 를 클릭하면 무료로 바로 다운로드가 가능하다.그럼 Download가 시작되는데, 1.4GB의 Ubuntu OS image 파일을 다운받기 시작한다. Ubuntu 설치 Ubuntu 설치를 시작하면 위와 같은 화면이 나오는데 설치할 OS 시스템 언어를 선택하고 우측의 Install Ubuntu 버튼을 클락하여 진행한다. 설치중에 업데이트를 할 수 있도록 위 체크박스를 선택하고, 서드파티 외부 드라이버 다운을 위해 아래 체크박스도 선택한 뒤 Continue 버튼을 클릭하여 진행한다.(체크박스를 비활성화로 진행하도 추후 업데이트 및 서드파티 외부 드라이버 다운로드 설치가 가능하다.) 새로 설치하는 것이므로 Erase disk and install ubuntu를 선택한다.만일 가상머신이 아닌 기존 PC에 설치하는 것이라면, 해당 항목설정이 필요하다. 파티션이 어떻게 설치될 것인지 경고성으로 안내해준다. 확인 후 Continue 버튼을 클릭하여 진행한다. 시간&#x2F;날짜 표시를 위해 원하는 지역(지도를 클릭하여 설정 변경)으로 설정 후 Continue 버튼을 클릭하여 진행한다. 원하는 언어의 키보드 레이아웃을 설정 후 Continue 버튼을 클릭하여 진행한다. 사용자 이름과 패스워드 등을 계정을 설정 후 Continue를 눌러 진행한다. 만약 자동로그인을 원한다면 Log in automatically를 선택하면 된다. 설치가 진행된다. 설치가 완료되면 위와 같은 메시지와 함께 Restart를 하라고 팝업을 띄워준다. Restart Now 버튼을 클릭하면 설치가 완료되고 재부팅이 시작된다. 별다른 에러없이 위 화면이 나왔다면, 성공적으로 우분투 설치가 완료된 것이다. 참조 http://inasie.tistory.com/38","categories":[{"name":"OS","slug":"OS","permalink":"https://woonyzzang.github.com/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"https://woonyzzang.github.com/categories/OS/Linux/"},{"name":"Ubuntu","slug":"OS/Linux/Ubuntu","permalink":"https://woonyzzang.github.com/categories/OS/Linux/Ubuntu/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://woonyzzang.github.com/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://woonyzzang.github.com/tags/ubuntu/"}]},{"title":"Javascript Animation Performance2","slug":"javascript-animation-performance2","date":"2017-05-15T14:33:47.000Z","updated":"2024-06-10T04:53:59.553Z","comments":true,"path":"2017/05/15/javascript-animation-performance2/","permalink":"https://woonyzzang.github.com/2017/05/15/javascript-animation-performance2/","excerpt":"","text":"JavaScript 애니메이션 성능을 높이는 방법 2편최신 웹, 모바일 디바이스 브라우저에서 모션을 구현하고자 한다면 자바스크립트 애니메이션 성능 높이는 방법 1편 에서 설명한 구현 방법 보다는 CSS will-change 프로퍼티 속성이란 것을 활용해볼 수 있다. 웹킷 계열 브라우저에서 CSS transform이나 animation 같은 프로퍼티를 사용할 때 발생하는 깜빡이는 현상에 관해 알고 있는 사람은 “하드웨어 가속”이라는 용어를 한번쯤 들어본 적이 있을 것이다. CPU, GPU, 하드웨어 가속 하드웨어 가속은 그래픽 처리 장치(GPU)를 이용하여 중앙 처리 장치(CPU)의 처리량을 줄이고, 브라우저의 렌더링을 효율화하는 것을 말한다. CSS 작업에 하드웨어 가속을 활성화하면, 작업 처리가 빨라져서 웹페이지의 렌더링을 보다 빠르게 할 수 있다. 이름을 보면 알 수 있듯이 CPU와 GPU는 모두 처리 장치다. CPU는 컴퓨터의 메인보드에 장착돼 있는 부품으로 거의 모든 연산 처리를 담당하는 이른바 컴퓨터의 두뇌다. 한편 GPU는 그래픽 카드에 탑재돼 있는 부품으로 이미지나 영상 등 그래픽 처리 등을 담당한다. 거기에 그래픽 표현에 필요한 복잡한 기하학적 연산 처리도 담당한다. 이러한 GPU에 처리를 분담하면 컴퓨터의 성능을 최대한으로 끌어올릴 수 있고, 모바일 디바이스에서 주로 발생하는 CPU의 부하를 줄일 수 있다. 하드웨어 가속(또는 GPU 가속)으로 페이지를 출력할 경우 레이어라고 하는 개념을 이용한다. 페이지에 있는 엘리먼트에 어떠한 지시(예를 들어 3D transforms)를 내리면 그 엘리먼트는 자신의 “레이어”에 분류되고 페이지에 있는 다른 엘리먼트와 독립되어 렌더링 된다. 그 뒤, 페이지 내에 다시 합쳐진다(즉, 화면 위에서 그려진다). 특정 엘리먼트의 변환 처리가 유일한 변경 사항인 경우 그 이외의 엘리먼트까지 렌더링 될 필요가 없는데 하드웨어 가속을 이용하면 대상이 되는 엘리먼트만 가져와 보다 빠르게 렌더링 처리를 할 수 있게된다. 하지만 이 방법은 3D transforms에만 적용되는 것으로 2D transforms는 해당하지 않는다. CSS animation, transform, transition 속성에 자동으로 GPU 가속이 활성화 되지 않는다. 게다가 이 속성을 실행하는 브라우저의 렌더링 엔진은 다소 동작이 느리다. 하지만 일부 브라우저에는 렌더링 처리 능력을 향상시킬 수 있는 몇가지 속성이 구현돼 있으며 이를 이용해 하드웨어 가속을 활성화 할 수 있다. 예를 들면 opacity 속성이 있다. 이 속성은 GPU에 의해 효율적으로 처리되기 때문에 고속으로 처리될 수 있는 몇 안되는 속성 중 하나다. CSS transition이나 animation에서 투명도를 변경하려는 레이어가 있는 경우 브라우저는 그 엘리먼트의 처리를 GPU에게 담당하도록 넘긴다. 따라서 렌더링이 정말 빠르게 처리된다. CSS 속성 중에서 opacity는 아주 유용한 도구이며 이 속성을 사용하는데 큰 문제는 없을 것이다. CSS 3D transform도 하드웨어 가속을 위한 속성으로 자주 사용된다. 예전 방법 : translateZ(또는 translate3d) CSS 핵 오랜시간동안 우리들은 하드웨어 가속을 활성화하는 방법으로 브라우저를 속여 강제로 animation이나 transform의 시키는 방법을 이용했다. 이 방법은 translateZ(또는 translate3d)라고 부르는 CSS 핵(때때로 null transforms 핵이라 불리는)을 이용하여, 3차원적 변형이 필요하지 않은 엘리먼트에 단순히 3D 변형을 지시를 하여 렌더링 처리를 고속화한다. 예를 들어 2차원 공간에서 애니메이션되는 엘리먼트에 아래와 같은 단순한 CSS 코드를 작성함으로써 하드웨어 가속을 활성화할 수 있다. 1transform: translate3d(0, 0, 0); 이러한 방법으로 하드웨어 가속을 행하면 합성 레이어라는 것이 생성된다. 이것은 GPU 위에 올려져 GPU에 의해 합성되는 레이어다. 하지만 CSS 핵을 이용해 생성한 레이어는 성능 병목을 해소하는데 항상 도움이 되지는 않는다. 합성 레이어를 생성하는 것은 페이지 출력 속도를 빠르게 할지는 모르겠지만 그만한 비용이든다. RAM이나 GPU의 메모리 사용량이 커지며 레이어를 많이 생성하면 할수록 그만큼 악영향을 끼치고, 특히 모바일 기기에서 이 점은 더 두드러지게 나타난다. 따라서 핵을 사용할때는 신중하게 다뤄야한다. 하드웨어 가속의 실행에 의해 정말 페이지의 출력이 빨라지는지 그리고 이로 인한 또다른 성능 병목이 발생하지 않는지를 확인한 상태에서 테크닉을 사용해야만 한다. 레이어 생성을 증가시키는 CSS 핵을 대체할 수 있는 새로운 CSS 속성이 등장했다. 이 속성은 엘리먼트의 변경이 시작하기 전에 그것이 어떤 변경인지를 브라우저에 알리는 효과가 있어서, 브라우저가 특정 엘리먼트에 조작을 가하기 전에 최적화할 수 있게 된다. 예를 들어 애니메이션처럼 비용이 필요한 처리가 실제로 시작되기 전에 브라우저가 준비할 수 있다는 뜻이다. 이 속성이 바로 will-change다. 새로운 방법 : 끝내주는 will-change 엘리먼트에 어떠한 변경을 할 것인지를 미리 브라우저에 알려주는 것이 will-change 속성의 역할이다. 이것을 사용하면 그 변경이 시작되기 전에 적절히 최적화할 수 있다. 즉, 페이지 출력에 악영향을 줄 수 있는 처리 비용을 줄일 수 있다는 것이다. 그로인해 효율적으로 엘리먼트의 변경 또는 렌더링을 처리할 수 있고 페이지는 순식간에 갱신돼 부드러운 화면 처리가 가능하게 된다. CSS 3D Transforms를 예로 들어보겠다. 「CPU, GPU, 하드웨어 가속」절에서 말했듯이 이 속성을 어느 특정 엘리먼트에 사용하면 그 엘리먼트와 컨텐츠는 레이어로 관리되고 나중에 다시 합쳐진다. 새로운 레이어로 엘리먼트를 분리하는 것은 비교적 비용이 필요한 작업이다. 따라서 애니메이션에 몇 분의 1초 단위의 눈에 띄는 지연 현상이 발생한다. 이것이 화면에서 깜빡이는 현상으로 이어지는 것이다. 이 지연 현상을 회피하려면 엘리먼트의 변경이 실제로 발생하기 전에 그 변경에 관해 브라우저에 알려주면 된다. 그러면 브라우저는 여유를 가지고 그 변경에 대비할 수 있게된다. 변경이 실제로 일어나게 되면 엘리먼트의 레이어가 준비되고 애니메이션 및 엘리먼트의 렌더링은 적절히 처리되며 페이지는 신속히 갱신된다. will-change 속성을 사용해 앞으로 일어날 변경에 관해 브라우저에게 알려주고자 할때는 대상이 되는 엘리먼트에 아래와 같이 CSS 코드를 작성하면 된다. 1will-change: transform; 무엇을 변경하고 싶은지를 정확하게 기술하면 그 변경에 대비한 최적화를 브라우저가 시행한다. 핵을 사용해 불필요한 비용을 발생시키는 레이어를 브라우저에게 억지로 생성시키는 방법보다 이 방법이 명확히 고속화에 도움이된다. will-change는 엘리먼트의 변경을 브라우저에 알려주는 이외에 엘리먼트 자체에 영향을 끼치는가? 이 질문에 관해서는 “그럴 수도 있고 아닐 수도 있다.”라는 답변을 줄 수 있다. 변경할 때 사용하는 속성의 종류에 따라 상황이 달라진다. 엘리먼트에 스택 컨텍스트(참고)를 생성하는 초기화하지 않은 속성이 있다면 그것을 will-change에 지정하는 것으로 엘리먼트에 스택 컨텍스트가 생성될 수 있다. 예를 들어 clip-path와 opacity 속성은 모두 기본 값 이외의 값을 지정할 때 대상이 되는 엘리먼트에 스택 컨텍스트를 생성한다. 즉, will-change의 값으로 두 속성(혹은 모두)을 지정하면 엘리먼트에 관한 실제 변경이 발생하기 전(즉, opacity 기본 값을 변경하기 전)에 그 엘리먼트에 스택 컨텍스트가 만들어지는 것이다. 이와 같은 원리는 엘리먼트에 스택 컨텍스트를 생성하는 또다른 속성 역시 동일하게 적용된다. 또, 일부 속성은 위치가 고정된 엘리먼트(fixed-position elements)에서 컨테이닝 블럭(containing block) 생성을 일으킨다. 예를 들면 transform을 적용한 엘리먼트는 위치가 고정(position: fixed)돼 있더라도 모든 자식 엘리먼트에 대해 컨테이닝 블럭을 생성한다. 즉, 컨테이닝 블럭의 생성을 발생시키는 속성을 will-change의 값으로 지정한 경우 위치가 고정된 엘리먼트에 컨테이닝 블럭이 만들어진다는 뜻이된다. 앞서 설명한 스택 컨텍스트와 컨테이닝 블럭, 두 가지 예외를 제외하면 will-change 속성은 대상 엘리먼트에 직접적인 영향을 끼치지 않는다. will-change는 브라우저에 앞으로 일어난 변화를 알려줘 최적화를 실시할 뿐이다. will-change 사용법：”할 것”과 “하지 말아야할 것” will-change의 역할을 이해하고 나면 “브라우저에 모든 것을 최적화하면 좋지 않을까”라고 생각할 수도 있을 것이다. 누구라도 모든 변경에 관한 최적화가 한번에 됐으면 좋겠다고 생각할 수 있다. 확실히 will-change는 파워풀하고 훌륭한 도구지만, 또다른 훌륭한 도구들과 마찬가지로 위력이 있는 만큼 책임을 가지고 다뤄야한다. will-change는 무분별하게 사용하면 성능저하가 발생하고 결과적으로 페이지의 작동이 중단될 것이다. will-change는 성능저하뿐 아니라 바로 감지하기 어려운 사이드 이펙트(원래 will-change는 보이지 않는 곳에서 브라우저에 명령하는 방법이므로 감지하지 못하는 건 당연하다)를 발생시키기 때문에 사용하기 까다로운 속성이다. 이 속성을 사용해 최대한 효과를 발휘하고 발생할 수 있는 문제를 피하기 위해서는 아래 몇 가지 규칙을 이해해야한다. 너무 많은 속성이나 엘리먼트에 will-change를 사용하지 않는다. 이전 절에서도 말했듯이 모든 속성, 모든 엘리먼트에 대해 일어날 변경을 전부 브라우저에 최적화 처리를 하려한다면 CSS로 다음과 같이 작성할 수 있다. 언뜻 보기엔 그렇게 틀려보이지 않을 수 있다. 12345*,*::before,*::after &#123; will-change: all;&#125; 이 코드는 동작할 것으로 보이지만(나도 처음엔 이치에 맞고, 잘 될 것 같다고 생각했음) 실제론 상당히 해롭고 무엇보다 전혀 효과가 없다. 모든 키워드가 will-change 대해 무효한 값이 될 뿐 아니라(유효한 값과 무효한 값은 뒤에서 소개하겠다) 위 코드와 같이 모든것에 적용되도록 하는 규칙(룰)은 유용하지 않다. 이유는 브라우저는 이미 가능한한 최적화를 시행하고 있으므로(opacity나 3D transform의 예를 기억해보자) 최적화를 명확히 지시하더라도 아무것도 바뀌지 않고 결국 아무 것도 행하지 않기 때문이다. 사실, 이 설정을 하므로써 더 많은 폐단이 생길 수 있다. 왜냐하면 will-change에 연결된 강력한 최적화가 머신의 자원을 대량으로 소비하는 결과를 낳고, 결국 페이지의 속도 지연이나 때때로 크래쉬까지 일으키는 원인이 되기 때문이다. 즉, 일어날지 일어나지 않을지 모르는 변경에 대비해 브라우저를 최적화 시키는 것은 현명하지 못하고 효과가 없을 뿐더러 문제를 발생시키니 하지 말자. 브라우저에 충분한 시간을 준다 will-change 속성의 명칭의 유래에는 명확한 이유가 있다. will-change가 브라우저에게 알려주는 것은 현재 일어날 변화가 아닌 미래에 일어날 변화다. will-change를 사용하여 브라우저에게 앞으로 일어날 변경에 관해 최적화를 시키는 것이기 때문에 이를 위해 브라우저도 최적화를 위한 시간이 필요하다. 이는 실제로 변화가 생길 때 지연 없이 최적화를 적용할 수 있도록 하기 위함이다. 변화가 생길 직전에 엘리먼트에 관해 will-change를 설정해도 거의 효과는 없다(오히려 더 나쁠지도 모른다. 이전 절의 예는 애니메이션이 필요하지 않는 엘리먼트까지 새로운 층을 만들 가능성이 있었다). 예를들어 호버로 변경이 생기는 경우를 살펴보자. 12345.element:hover &#123; will-change: transform; transition: transform 2s; transform: rotate(30deg) scale(1.5);&#125; 위의 코드가 브라우저에 알려주고 있는 것은 이미 일어난 변화에 관한 최적화다. 효과가 없을 뿐 아니라 will-change의 포괄적인 개념을 부정하는 것이다. 더 나은 방법은 적어도 변화가 생길 아주 조금 전에 그 변화를 알려줄 방법을 생각해 will-change를 설정하는 것이다. 예를 들어 엘리먼트를 클릭한는 순간 변화한다면 마우스 커서를 올릴 때(hover) will-change를 설정하면 브라우저가 변경에 관해 최적화하는 시간을 벌 수 있다. 사용자가 엘리먼트에 마우스 커서를 올린 후 실제 클릭할 때까지의 시간 차는 브라우저가 충분히 최적화를 실시할 수 있는 시간이기 때문이다. 인간의 반응은 비교적 시간이 걸리기 때문에 실제 변경이 생기기 전 까지 약 200밀리세컨드의 시간이 브라우저에게 주어진다. 브라우저가 최적화를 하는데는 그만큼 시간이면 충분하다. 12345678910.element &#123; /* 스타일 선언 */ transition: transform 1s ease-out;&#125;.element:hover &#123; will-change: transform;&#125;.element:active &#123; transform: rotateY(180deg);&#125; 그러면, 선택이 아니라 마우스 커서를 엘리먼트에 올렸을 때 변경이 필요한 경우는 어떻게 처리할까? 아까도 말했듯이 처음 선언한 코드는 소용이 없다. 그러나 이 경우에도 변경이 발생하기 전에 예측할 수 있는 방법을 찾아낼 수 있다. 예를 들어, 변경하는 엘리먼트의 조상에 :hover로 will-change를 선언하면 최적화에 필요한 시간을 벌 수 있다. 1234567891011.element &#123; transition: opacity .3s linear;&#125;/* 마우스 커서가 조상 엘리먼트에 오는 경우에 변경사항에 대해 선언한다 */.ancestor:hover .element &#123; will-change: opacity;&#125;/* 엘리먼트에 마우스 커서가 오는 경우의 변경 사항을 적용한다 */.element:hover &#123; opacity: .5;&#125; 하지만, 조상 엘리먼트에 마우스 커서를 둔다고 해서 대상의 엘리먼트에 반드시 상호 작용이 발생한다고 할 수는 없다. 그러므로 애플리케이션에서 뷰가 활성화 될 때나 엘리먼트가 뷰포트에 보이는 위치에 있을 때 will-change를 설정하면 엘리먼트가 상호 작용할 가능성을 높일 수 있다. 변경이 종료되면 will-change를 삭제한다 브라우저가 앞으로 발생할 변화에 관해 최적화를 하면 일반적으로 비용이 든다. 「너무 많은 속성이나 엘리먼트에 will-change를 사용하지 않는다」 절에서 잠깐 이야기했듯이 머신의 자원을 대량으로 소비하는 일이 있기 때문이다. 브라우저는 보통, 적용한 최적화를 삭제하고 가능한한 빨리 평소의 행동(nomal behavior)으로 돌아온다. 하지만 will-change는 이 행위를 무시하고 본래 브라우저가 하는 것보다 훨씬 길게 최적화를 유지해버린다. 그러니, 엘리먼트에 변경이 종료되면 반드시 will-change를 삭제하도록 하자. 그렇게하면 브라우저는 최적화때문에 사용하고 있던 자원을 회수할 수 있다. 스타일시트에 선언한 will-change는 삭제할 수 없다. 따라서 대부분 자바스크립트를 사용해 설정 및 삭제하는 것을 권장한다. 스크립트에서 브라우저에 변경을 선언하고 그 변경이 종료될 때 즈음에 이벤트를 등록하면 변경이 종료된 후 will-change를 삭제할 수 있다. 예를 들어 앞 절에서 소개한 스타일 규칙과 동일하게 엘리먼트(또는 그 조상)에 mouseenter 이벤트를 이용해 마우스가 호버될 때를 리슨하여 will-change를 설정할 수 있다. 엘리먼트에 애니메이션을 적용하는 경우에는 DOM 이벤트의 animationEnd 이벤트를 사용해 애니메이션이 종료하여 animationEnd가 발생하면 will-change를 삭제한다. 12345678910111213141516// 간단한 예제// 클릭할 때 애니메이션을 재생할 엘리먼트를 선택합니다.var el = document.getElementById(&#x27;element&#x27;);// 엘리먼트에 마우스 커서가 올라가면 will-change를 설정합니다.el.addEventListener(&#x27;mouseenter&#x27;, hintBrowser);el.addEventListener(&#x27;animationEnd&#x27;, removeHint);function hintBrowser() &#123; // 애니메이션의 키프레임 블럭을 최적화할 수 있는 속성을 사용합니다. this.style.willChange = &#x27;transform, opacity&#x27;;&#125;function removeHint() &#123; this.style.willChange = &#x27;auto&#x27;;&#125; 크레이그 버클러(Craig Buckler)가 자바스크립트로 CSS의 애니메이션을 캡쳐하는 방법에 관해 글(How to Capture CSS3 Animation Events in JavaScript)을 작성했다. 스크립트를 이용한 조작 방식에 익숙치 않은 분은 참고하길 바란다. 또 CSS-TRICKS의 CSS animtaion과 transition을 조작하는 방법에 관한 글(Controlling CSS Animations and Transitions with JavaScript)도 참고가 될 것이다. 스타일시트에서는 will-change를 소극적으로 사용한다 전 절에서 살펴본 것 처럼 will-change는 엘리먼트에 변경이 생기기 몇 밀리세컨트 전에 브라우저에게 그 일을 알리고자 할 때 사용할 수 있다. 이번 절에서는 스타일시트에서 will-change를 선언하는 좋은 사례를 소개한다. will-change의 설정 및 삭제엔 자바스크립트를 이용하는 것을 추천하지만 몇몇은 will-change를 스타일시트에서 설정(또는 유지)하는게 적절한 경우도 있다. 하나의 예로 사용자가 지속해서 상호 작용하는 것이 전제되고 빠른 응답을 요구하는 소수의 엘리먼트에 will-change를 설정하는 경우를 들 수 있다. 한정된 엘리먼트에 설정한다면 너무 과한 최적화로 연결되지 않아 그에 따른 폐해도 적다. 예를 들어 유저의 요청에 따라 사이드바를 슬라이드하는 경우라면 아래 규칙이 적절할 수 있다. 123.sidebar &#123; will-change: transform;&#125; 또다른 예로 거의 항상 변경되는 엘리먼트에 관해 will-change를 이용하는 경우를 들 수 있다. 예를 들면, 유저의 마우스 이벤트에 반응해 마우스의 움직에 맞춰 엘리먼트를 이동시키는 경우가 있다고 하자. 이 경우엔 스타일시트로 will-change를 선언해도 문제 없다. 왜냐하면 엘리먼트가 항상 혹은 정기적으로 변화하기 때문에 최적화도 유지될 필요성이 있기 때문이다. 123.annoying-element-stuck-to-the-mouse-cursor &#123; will-change: left, top;&#125; will-change 속성의 값 will-change 속성은 4개의 설정 가능한 값(auto, scroll-position, contents,)을 제공한다. 의 값으로는 변경하고 싶은 1개 이상의 속성 이름을 지정한다. 여러 개의 속성을 작성하는 경우에는 쉼표(,)로 구분한다. 아래 코드는 속성 이름으로 지정한 유효한 will-change 선언이다. 123will-change: transform;will-change: opacity;will-change: top, left, bottom, right; 의 값은 보통 에서 제외되는 키워드와 함께 will-change, none, all, auto, scroll-position, contents의 키워드도 제외된다(identifier-value). 이 글의 처음에도 언급했듯이 will-change: all은 무효이기 때문에 브라우저가 무시한다. auto라는 값은 특별한 변경 의지를 보이지 않기 때문에 브라우저는 평소에 하는 최적화 이외에 또 다른 최적화를 실시하지 않는다. scroll-position 값은, 이름 그대로 후에 엘리먼트의 스크롤 위치를 변경할 것을 나타낸다. 이 값을 설정하면 브라우저는 스크롤 가능한 엘리먼트를 포함해 윈도우에 보이는 컨텐츠를 위해 미리 최적화하여 준비한 후 렌더링하기 때문에 유용하다. 브라우저는 스크롤 윈도우에 보이는 컨텐츠만을 렌더링하는 경우가 많지만, 그 중에는 윈도우에서 벗어난 컨텐츠도 있다. 렌더링을 생략하는 것으로 메모리 및 시간 절약과 미려한 스크롤링 그리고 밸런스를 맞춘다. will-change: scroll-position을 사용하면 한층 더 렌더링의 최적화가 이뤄지기 때문에, 한번에 많은 양을 스크롤 하거나 빠른 스크롤이 필요한 경우에도 매끄러운 화면을 선보일 수 있다. contents의 값은, 엘리먼트의 컨텐츠의 변화를 나타낸다. 브라우저는 보통 엘리먼트의 렌더링 결과를 오랫동안 캐쉬한다. 왜냐하면 대부분의 엘리먼트는 변화가 잦지 않으며, 변화하더라도 위치를 바꾸는 정도이기 때문이다. 브라우저가 이 값을 통해 전달받는 신호는 엘리먼트의 캐시를 덜하거나 아예 하지 않아야 한다는 것이다. 그 이유는 엘리먼트의 컨텐츠가 정기적으로 변화하는 경우 그 엘리먼트를 캐쉬하더라도 도움이 되지 않고, 시간만 낭비하기 때문이다. 따라서 브라우저는 단순하게 캐쉬를 그만두고 컨텐츠가 변화할 때마다 처음부터 렌더링하게 된다. 앞에서 말했듯이 will-change를 지정해도 아무 영향을 받지 않는 속성도 있다. 왜냐하면 브라우저는 대부분의 속성 변화에 관해 어떤 특별한 최적화를 행하지 않기 때문이다. 그러한 속성을 will-change에 지정해도 안전하지만 별다른 영향도 주지 않는다. 기타 속성은 스택 컨텍스트(opacity, clip-path 등)나 컨테이닝 블럭 또는 양쪽 모두 생길 수 있다. 지원 브라우저 2016년 7월 기준으로 will-change 속성을 지원하는 브라우저는 Chrome 36+, Opera 24+, Firefox 36+, Safari 9.1이다. iOS Safari 9.3 그리고 Android Browser 50 에서도 지원한다. 자세한 내용은 caniuse#will-change에서 참고한다. Edge는 “under consideration” 상태이며 곧 모든 현대 브라우저에서 지원할 것으로 기대한다. 정리 will-change 속성은 핵을 사용하지 않으면서도 성능 최적화 코드를 작성할 수 있게 도와준다. 이는 CSS 작업에서 속도와 성능의 중요성을 강조하는 부분이기도 한다. 그러나 어떤 방법이든 강력한 힘을 가진 데에는 큰 책임이 뒤따른다는 사실을 유념해야 한다. will-change는 단순히 성능향상을 목적으로 가볍게 접근하기 보다는 현명한 사용 방안에 대한 고민이 요구되는 속성이다. will-change는 실제로 변화시키는 속성과 실제로 변화가 발생할 엘리먼트에 설정하고 변화가 종료되면 삭제하는 것을 권장한다. 참조 https://dev.opera.com/articles/ko/css-will-change-property/","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Javascript","slug":"Frontend/Javascript","permalink":"https://woonyzzang.github.com/categories/Frontend/Javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://woonyzzang.github.com/tags/js/"}]},{"title":"Mobile Web Debbuging","slug":"mobile-web-debbuging","date":"2017-05-15T13:02:03.000Z","updated":"2024-06-07T09:27:28.344Z","comments":true,"path":"2017/05/15/mobile-web-debbuging/","permalink":"https://woonyzzang.github.com/2017/05/15/mobile-web-debbuging/","excerpt":"","text":"모바일 웹 디버깅처음 모바일 웹 개발을 시작하는 사람이 느끼는 가장 큰 어려움은 아마도 모바일 웹어서 디버깅하는 것일 것이다. 모바일 기기는 데스크톱에 디해 화면도 작고 입력장치도 불편해 실제로 개발하고 디버딩하는 데 많은 어려움이 있다. 특히, 데스크톱에서 지원하는 디버깅 도구에 익숙한 개발자라면 답답한 정도가 더할 것이다. 모바일 웹 개발자 도구 개발이 완료된 프로그램을 대상으로 디버깅하기도 하지만 개발하고 있을 때도 개발된 부분을 확인하고 테스트하기 위해 디버깅을 실시한다. 실제 기기에 개발한 소스코드를 반영하고, 테스트하고, 디버딩하는 것은 매우 번거로운 일이다. 이러한 번거로움을 해소하려고 에뮬레이터나 시뮬레이터, 브라우저 개발자 도구를 이용해 데스크톱 화녕에서 테스트와 디버깅을 한다. 개발자 도구 실행환경 대상 장비 특징 안드로이드에뮬레이터와 DDMS 모든 OS 안드로이드 안드로이드 SDK에 포함된 에뮬레이터와 DDMS.DDMS로 안드로이드의 상세 로그를 볼 수 있고,에뮬레이터를 이용해 기능을 확일 할 수 있다. iOS Simulator와iWebinspecor OSX iOS 4.x 이상 iWebinspecor를 이용해 브라우저 개발자 도구와같이 디버깅 할 수 있다.iOS Simulator를 이용해 테스트 할 수 있다. 크롬 브라우저개발자 도구 모든 OS 안드로이드,iOS UserAgent 정보를 변경할 수 있고, 터치 이벤트를발생시킬 수 있다.데스크톱과 같은 디버깅 환경을 제공한다.특히 웹킷 기반의 안드로이드와 iOS 브라우저의작동 원리는 유사하다.데스크톱 크롬 31 이상에서는 USB로 원격 디버딩이가능하다.단, 안드로이드 4.0 이상의 안드로이드용 크롬에서만가능하다. 사파리 브라우저개발자 도구 모든 OS 안드로이드,iOS UserAgent 정보를 변경할 수 있다.데스크톱과 같은 디버깅 환경을 제공한다.특히 웹킷 기반의 안드로이드와 iOS 브라우저의작동 원리는 유사하다.사파리 6 이상, Mac OSX Lion 이상, XCode 4.5와iOS 6 SDK가 있을 경우, iOS 6.x 부터는 원격디버깅 환경을 제공한다. 안드로이드 SDK에 있는 에뮬레이터와 DDMS는 많은 정보를 제공하지만 에뮬레이터 자체의 속도가 느려서 현실적으로 개발 도중에 기능을 확인하면서 개발을 진행하기가 번거롭다. 반면 iOS Simulator 나 iWebinspecor는 맥에서만 사용할 수 있기 때문에 윈도우를 사용하는 개발자는 사용하기 어렵다. 또한 두 가지 도구 모두 각각 모바일 OS에만 사용할 수 있기 때문에 범용적으로 사용하기 힘들다.모바일 웹 사이트를 개발할 때 기기나 운영체제에 제한을 받지 않고 범용적으로 사용할 수 있는 방법으로 브라우저의 개발자 도구를 이용하는 방법이 있다. 원격 디버깅 도구 모바일 웹 페이지를 개발할 때는 가상 모바일 웹 개발 환경을 이용해 기능을 구현하지만 서비스를 시작하려면 실제 모바일 기기에서 동작 여부를 확인해야 한다. 하지만 모바일 환경은 작은 화면과 불편한 입력 장치로 인해 작성한 코드에 문제가 있어도 그 문제의 원인을 파악하기가 어렵다. 이러한 문제를 해결하려고 다양한 원격 디버딩 도구가 개발됐고 지금도 계속 개발되고 있다. 다음은 현재 많이 사용되고 있는 원격 디버깅 도구다. 도구 사용 환경 특징 크롬DevTools 설치환경: Chrome Android SDK대상장비: Chrome for Android연결방식: USB 연결관련 URL 참조 안드로이드 4.0 부터 지원하는 안드로이드용크롬에서만 가능하다.안드로이드 SDK의 ADB를 이용해 USB로 연결한다. 사파리Web Inspector 설치환경: -사파리 6 이상-OSX Lion 이상-XCode 4.5대상장비: iOS 6.x 이상연결방식: USB 연결관련 URL 참조 iOS 6.0 SDK가 설치돼 있어야 사용할 수 있다.USB로 연결해 실제 장비와 가상장비(iOS Simulator)에서 디버깅 할수 있다. weinre 설치환경: Node.js대상장비: 모든 기기연결방식: 네트워크 연결관련 URL 참조 Node.js가 설치된 모든 장비에서 테스트 할 수 있다.중단점(break point)과 같은 고급 디버깅 기술은사용할 수 없다. 크롬 Dev Tool 이나 사파리 Web Inspector 모두 USB 연결만으로 데스크톱의 브라우저 개발자 도구에서 기기를 원격으로 디버깅 할수 있다. USB로 연결된 구조이기 때문에 원격이지만 데스크톱에서 디버깅하는 것과 같은 속도로 디버깅 할 수 있고, 브라우저의 개발자 도구에 있는 기능을 모두 사용할 수 있다. 하지만 초기 설치가 복잡하고 일부 모바일 장비에서만 사용할 수 있기 때문에 범용적으로는 사용할 수는 없다.기기와 운영체제에 제한을 받지 않고 번용적으로 사용할 수 있는 디버깅 도구로는 네트워크 연결 방식을 이용하는 weinre가 있다. weinre weinre는 “Web Inspector Remote”의 약자로써, 웹 페이지를 디버깅하기 위한 용도로 만들어진 도구다. 원격에 있는 모바일 장비를 디버딩할 수 있는 구조라는 점을 제외하면 파이어폭스의 파이어버그와 웹킷 기반의 개발자 도구와 같은 웹 디버깅 도구다. 기본개념 weinre는 네트워크 연결 방식으로 모바일 기기와 데스크톱을 연결한다. 여기서 모바일 기기는 디버깅 대상(target)이 되고, 디버깅하는 데스크톱은 클라이언트가 된다. 디버깅 대상 기기와 클라이언트 사이에서 정보를 전달하고 처리하는 역활은 weinre 서버가 담당한다. 여기에서는 다양한 모바일 환경에서 범용적으로 디버깅하고 테스트할 수 있는 방법을 설명했다.그러나 실제로 모바일 웹 사이트를 개발할 때는 기준이 되는 기기에 최적화된 디버깅 도구를 이용하는 편이 가장 효과적이다. 예를 들어 iOS 6 이상일 때는 safari Remote Debugging을 사용하고, 안드로이드 4.0 이상일 때는 Chrome Remote Debugging을 사용한다. 그래야 중단점 설정과 같은 고급 디버깅 기술을 사용할 수 있다. 또한 네크워크 연결 방식이 아닌 USB 연결 방식이라서 훨씬 안정적으로 디버딩할 수 있다. 여기서는 자세하게 설명하지 않았지만 프락시 도구를 이용해 실제 운영 중인 서비스를 디버딩 할 수도 있다.도구 사용법과 디버깅 방법을 주로 설명하였으나 궁극적으로는 현재 모바일 디버깅 환경을 이해해야 하고 새로운 디버깅 도구가 나왔을 때 적극적으로 활용할 수 있는 능력을 키우는 것이 더 중요하다.","categories":[{"name":"Web","slug":"Web","permalink":"https://woonyzzang.github.com/categories/Web/"},{"name":"Mobile","slug":"Web/Mobile","permalink":"https://woonyzzang.github.com/categories/Web/Mobile/"}],"tags":[{"name":"mobile","slug":"mobile","permalink":"https://woonyzzang.github.com/tags/mobile/"},{"name":"tip","slug":"tip","permalink":"https://woonyzzang.github.com/tags/tip/"}]},{"title":"Javascript Animation Performance","slug":"javascript-animation-performance","date":"2017-05-15T12:35:47.000Z","updated":"2024-06-10T04:53:59.552Z","comments":true,"path":"2017/05/15/javascript-animation-performance/","permalink":"https://woonyzzang.github.com/2017/05/15/javascript-animation-performance/","excerpt":"","text":"JavaScript 애니메이션 성능을 높이는 방법애니메이션이 많은 화면에서는 성능과 관련된 문제가 일어나기 쉽다. 특히, 하드웨어 성능이 PC에 비해 열악한 모바일 환경에서는 성능이 문제가 되는 경우가 더욱 많다. 브라우저 렌더링 과정 웹 브라우저의 애니메이션 성능을 이야기하기 전에 이해해야 할 것이 브라우저의 렌더링 과정이다. 애니메이션도 브라우저 렌더링 과정의 한 형태이기 때문에 브라우저 렌더링 과정을 이해하면 성능에 미치는 부분을 찾을 수 있다. HTML 렌더링 순서 브라우저가 HTMl을 파싱한다. DOM 트리를 구성한다. DOM 트리에서 화면에 표시되는 엘리멘트를 렌더 객체(RenderObject) 트리로 구성한다. 렌더 객체 트리는 DOM 트리에서 화면에 보이는 요소를 노드를 구성한다. 가령 display:none 속성인 요소나 HEAD, SCRIPT와 같이 화명에 보이지 않는 노드는 렌더 객체에서 제외된다. 렌더 객체 트리에서 별도의 영역으로 구성할 수 있는 노드를 렌더 레이어(RenderLayer) 트리로 구성한다. 렌더 레이어 트리는 렌더 객체 트리에서 transform과 같은 특수 속성이 적용된 노드로 구성된다. 브라우저는 구성된 정보를 바탕으로 비동기식으로 화명을 표현한다. 크롬 개발자 도구에 있는 Timeline 탭에서 실제 렌더링이 어떻게 이뤄지는지 확인 할 수 있다. Timeline 탭에서 HTML 을 불러오면 다음과 같이 렌더링 과정이 나타난다. ParseHTML : HTML을 파싱할 때 발생한다. Recalculate Sytyle : 요소에 스타일이 적용될 때 발생한다. Layout : 적용된 스타일에 의해 위치나 크기가 변경되어 계산이 필요할 때 발생한다. Paint : 요소를 화면에 다시 그려야 할 때 발생한다. Composite Layer : 변경되지 않은 각 렌더 레이어를 합성할 때 발생한다. 브라우저는 문서를 화면에 표시하려고 위와 같은 다양한 과정을 수행한다. 로컬환경에서의 Timeline 탭에서는 HTML 파싱에 가장 많은 시간이 걸렸지만 실제 애니메이션은 HTML 파싱이 완료된 후 사용자의 동작에 의해 실행되기 때문에 애니메이션 성능에 영향을 미치는 요소는 다르다. 애니메이션이 동작할 때는 레이아웃 계산이나 연속적인 페인트(Paint) 작업으로 성능 문제가 발생한다. 애니메이션 성능을 높이는 방법 크롬 개발자 도구에서 알 수 있듯이 렌더링 과정 중에 DIV 요소에 적용된 스타일의 속성이 무엇이냐에 따라 레이아웃 작업이 발생하기도 하고, 레이어 병합(composite layers)작업이 이뤄지기도 한다. 레이어 구성하기 레이어는 얇은 투명막과 같이 여러 장을 겹쳐서 화면을 구성할 수 있는 요소로, 여기서는 렌더 객체를 지칭한다. 브라우저가 레이어를 구성하는 목적은 변경될 요소가 많은 영역을 별도로 관리해 해당 영역이 변경됐을 때 해당 부분만 반영하라는 것이다. 다음 그림은 한 화면이 레이어로 구성된 것을 표현한 그림이다. 1234567891011121314&lt;!-- [I] 레이어 구성 구조 03. 앞면레이어 02. 마스크레이어 01. 영상레이어 00. 배경레이어--&gt;&lt;div&gt; &lt;!-- 00. 배경레이어 --&gt; &lt;div&gt; &lt;!-- 01. 영상레이어 --&gt; &lt;div&gt; &lt;!-- 02. 마스크레이어 --&gt; &lt;div&gt;&lt;!-- 03. 앞면레이어 --&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 하나의 화면이 4개의 레이어로 구성돼 있고, 실제 화면에 표시될 때에는 4개의 레이어가 합쳐져 화면에 보이게 된다. 휴대폰 화면 속 영상이 변경될 때 실제 변경되는 부분은 전체 화면이 아니라 휴대폰 화면 속의 영상만이다. 배경과 휴대폰 모양의 사진은 기존 레이어(배경 레이어, 휴대폰 모양 사진 레이어)를 그대로 사용할 수 있다. 즉, 변경된 부분만 바꾸고 나머지 부분을 합쳐 빠르게 화면을 수성할 수 있다. 이를 레이어 병합이라고 한다. 레이어 병합을 사용하면 페인트나 레이아웃 작업이 발생하지 않기 때문에 변경된 화면을 빠르게 구성성할 수 있다. 이러한 레이어 구성은 브라우저가 판단하며, 그 규칙은 다음과 같다. 3D(translate3d, preserve-3d 등) 나 perspective transform을 사용하는 경우 &lt;video&gt; 태그나 &lt;canvas&gt; 태그를 사용하는 경우 플래시나 ActiveX 컨트롤을 사용하는 경우 CSS 애니메이션, CSS 필터를 사용하는 경우 자식 요소가 레이어로 구성돼 있을 경우 z-index가 낮은 형제 요소가 레이어로 구성돼 있을 경우 대상 요소도 레이어로 구성된다.애니메이션은 대상 요소의 스타일을 주기적으로 변경해서 이동한다. 스타일 변경 때문에 페인트나 레이아웃 작업이 연속적으로 발생해 애니메이션의 성능을 저하시키는 경우가 있다. 이때 레이어 병합을 이용해 페인트와 레이아웃 작업이 일어나지 않도록 유도하면 애니메이션의 성능을 높일 수 있다. GPU 가속 사용하기 GPU 가속은 앞에서 설명한 레이어 병합 방식으로만 동작한다. 하지만 브라우저의 레이어 병합 방식과 달리 각 레이어를 GPU 메모리에 비트맵 형태의 텍스처(texture)로 저장해 실제 레이어를 병합할 때는 GPU의 메모리에서 실행 한다. 그래서 굉장히 빠르다. 다음 스타일이 적용되면 브라우저는 해당 요소 영역(layer)을 GPU 메모리에 텍스처로 저장한다. 1234-webkit-transform : translate3d-webkit-transform : translateZ-webkit-transform : rotate3d-webkit-transform-style : preserved-3d 그러나 GPU는 하드웨어에 따라 성능이 달라지기 때문에 GPU 가속을 사용할 때는 주의를 기율여랴 한다. 무분별한 GPU 사용은 오히려 브라우저를 느리게 한다.요소에 GPU 사용 속성이 부여되는 순간 브라우저가 대상 영역을 GPU 메모리에 로딩하기 때문에 콘텐츠가 클 경우에는 화면이 깜빡이는 현상이 발생할 수 있다. 요소에 GPU 사용 속성이 부여되면 레이어로 분리되며 레이어는 변경되는 내용이 없는 한 다시 요소의 내용을 GPU 메모리에 올리지 않는다. GPU 사용 속성을 사용한 요소의 내용이 변경되면 GPU 메모리가 갱신되기 때문에 요소의 내용을 미리 변경하고 그 이후에 GPU 사용 속성을 부여한다. 성능이 안 좋은 휴대폰에서 하드웨어 가속을 사용하는 것은 오히려 성능 저하의 주범이 된다. 경험상 iOS 3.x 이상과 안드로이드 4.1 이상을 지원하는 기기에서 GPU 가속을 적용했을 때 더 성능이 좋았다. 애니메이션 동작 시 레이아웃을 변경하는 스타일이나 메서드 사용하지 않기 브라우저 렌더링 과정 중 가장 느린 작업 가운데 하나가 레이아웃 작업이다. 이작업은 요소의 위치나 크기를 계산하는 작업이라서 비용이 높고, 자주 하면 성능에 치명적이다. 특히, 주기적으로 요소의 스타일을 변경하는 애니메이션에서 너비나 높이와 같이 대상의 크기를 변경하는 레이아웃 작업이 발생하면 부드러운 애니메이션을 기대하기 어렵다. 다음은 레이아웃 작업을 유발하는 스타일이나 메서드를 정리한 표다. 대상 메서드 및 속성 요소 clientHeight, clientLeft, clientTop, clientWidth, focus(),getBoundingClientRect(), getClientRects(), innerText, offsetHeight,offsetLeft, offsetParent, offsetTop, offsetWidth, outerText, scrollByLines(),scrollByPages(), scrollHeight, scrollIntoView(), scrollIntoViewIfNeeded(),scrollLeft, scrollTop, scrollWidth 위치 left, top, position, float 박스, 테두리 height, width, padding, margin, display,border-width,border 범위 getBoundingClientRect(),getClientRects() window 객체 getComputedStyle(), scrollBy(), scrollTo(), scrollX, scrollY,webkitConvertPointFromeNodeToPage(), webkitConvertPointFromeNode() 따라서 되도록 애니메이션을 동작할 때 위의 표에 나열된 메서드와 속성은 호출하거나 변경하지 않는 편이 좋다. 혹시 변경이 필요하다면 애니메이션을 동작할 때가 아니라 동작 전후에 미리 작업을 하거나 레이아웃 작업이 발생하지 않는 대체 속성을 사용하는 것이 좋다. 다음 속성을 대체하면 레이아웃 작업 대신 레이어 병합이 발생한다. width, height -&gt; transform:scaleleft, top -&gt; transform:translateX, translateY 또는 translate(x,y), translate3d(x,y,0)","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Javascript","slug":"Frontend/Javascript","permalink":"https://woonyzzang.github.com/categories/Frontend/Javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://woonyzzang.github.com/tags/js/"}]},{"title":"Javascript Effective Animation","slug":"javascript-effective-animation","date":"2017-05-15T11:52:08.000Z","updated":"2024-06-10T04:53:59.557Z","comments":true,"path":"2017/05/15/javascript-effective-animation/","permalink":"https://woonyzzang.github.com/2017/05/15/javascript-effective-animation/","excerpt":"","text":"JavaScript 효과적인 애니메이션 구현하기애니메이션은 하나 이상의 이미지(frame)을 일정한 시간(second) 간격으로 순차적으로 호출해 이미지가 움직이는 것처럼 보이도록 착시 현상을 유도하는 기술이다. 이때 보이는 이미지의 개수와 시간 간격의 비를 FPS(frames per cecond)라고 하며, FPS 값이 클수록 더 자연스러운 애니메이션을 표현할 수 있다. 보통 눈의 잔상효과를 이용해 움직이는 동작을 표현할 때는 2530FPS 정도를 사용하면 애니메이션 효과를 느끼게 할 수 있다. 하지만 더 자연스러운 애니메이션을 표현하려면 60120FPS를 유지해야 한다. 웹에서는 60FPS 정도면 충분히 자연스러운 효과를 낼 수 있다. 자바스크립트 기반의 애니메이션 웹 기술의 발전과 더불어 현재는 자바스크립트 외의 다양한 방법으로 애니메이션을 구현할 수 있다. 하지만 웹이 생겼던 초기에는 애니메이션을 구현하는 방법이 많지 않았다. 그 가운데 가장 전통적이고 전형적인 방법은 setTimeout() 메서드와 setInterval() 메서드를 이용한 방법이다. 자바스크립트 기반의 애니메이션 구현 방법은 ‘애니메이션 동작을 처리하는 함수’를 일정 시간(ms)마다 호출해 ‘애니메이션 대상(DOM)’을 이동하거나 상태를 변경해서 애니메이션을 구현하는 방법이다. 구현하기 자바스크립트 기반의 애니메이션은 대개 다음과 같은 순서로 구현한다. 1.애니메이션 대상이 되는 DOM을 작성한다. 다음 예제에서는 100 x 100px 크기의 빨간색 사각형 영역을 마크업으로 구성했다. 1&lt;div id=&quot;box&quot; style=&quot;position:absolute;left:0;bordr:1px solid red;width:100px;height:100px&quot;&gt;&lt;/div&gt; 2.원하는 FPS에 해당하는 단위 시간(ms)을 구하고 단위 시간마다 애니메이션을 처리하는 함수를 호출한다. 단위시간은 다음과 같은 공식으로 구할 수 있다. 123단위 시간(ms) = 1000 / 원하는 FPS예를 들어, 60FPS라면 &#x27;1000/60 = 약 16.7ms&#x27;의 단위 시간을 구할 수 있다. 즉, 16.7ms마다 이미지를 하나씩 보여주거나 상태를 변경하면 60FPS의 애니메이션을 표현할 수 있다. 3.애니메이션 대상이 될 DOM 요소의 상태를 변경하는 함수를 작성한다. 이 예제에서는 fAnimate() 함수로 작성했다. 4.setTimeout() 메서드 또한 setInterval() 메서드를 이용해 fAnimate() 함수를 단위 시간(ms) 마다 호출한다.다음은 setTimeout() 메서드를 이용해 아이디가 ‘box’인 DIV 요소를 1000&#x2F;60초(약 16.7ms)마다 5px씩 오른쪽으로 300px 이동하는 예다. 123456789101112var elBox = document.getElementById(&#x27;box&#x27;), nAnimateTimer = null, fAnimate = function() &#123; elBox.style.left = parseInt(elBox.style.left, 10) + 5 + &#x27;px&#x27;; //종료시점 if (parseInt(elBox.style.left, 10) &lt; 300) &#123; nAnimateTimer = setTimeout(fAnimate, 1000/60); &#125;&#125;;nAnimateTimer = setTimeout(fAnimate, 1000/60); 다음은 setInterval() 메서드를 사용해 아이디가 ‘box’인 DIV 요소를 1000&#x2F;60초(약 16.7ms)마다 5px씩 오른쪽으로 300px 만큼 이동하는 예다. 123456789101112var elBox = document.getElementById(&#x27;box&#x27;), nAnimateinterval = null, fAnimate = function() &#123; elBox.style.left = parseInt(elBox.style.left, 10) + 5 + &#x27;px&#x27;; //종료시점 if (parseInt(elBox.style.left, 10) &lt; 300) &#123; clearInterval(nAnimateinterval); &#125;&#125;;nAnimateinterval = setInterval(fAnimate, 1000/60); setTimeout() 메서드는 함수를 한 번만 호출하고, setInterval() 메서드는 함수를 반복해서 호출한다는 차이가 있다. 하지만 종료 시점이 있고, 단위 시간마다 반복되는 구조라는 점에서 기본적인 구조는 동일하다. 자바스크립트 기반 애니메이션의 문제점 setTimeout() 메서드나 setInterval() 메서드로 애니메이션을 구현할 수 있지만, 이방법에는 두 가지 치명적인 문제점이 있다.setTimeout() 메서드와 setInterval() 메서드를 사용할 때마다 브라우저는 애니메이션 대상인 DOM 요소를 변경하고, 이로 인해 리렌더링(re-rendering)이 단위 시간마다 발생한다. 과도한 리렌더링은 CPU의 점유율을 높여 모바일 기기의 전력이 빠르게 소모된다. 또한 브라우저가 백그라운드에서 실행되고 있을때, 최소화됐을 때, 화면에 보이지 않을 때 등 모든 상황에서 애니메이션이 계속 호출되어 전력이 소모된다. 자바스크립트 엔진은 단일 스레드 기반으로 동작하며 비동기로 발생하느 이벤트를 큐(queue)에 쌓아 순차적으로 처리한다. 그래서 setTimeout() 메서드와 setInterval() 메서드에서 사용한 시잔의 정확성을 보장하지 못한다. 이로 인해 실제 애니메이션은 매끄럽지 못하게 표현되거나 부자연스럽게 표현된다.setTimeout() 메서드나 setInterval() 메서드를 이용하더라도 앞에서 언급한 문제점을 모두 완벽하게 해결 할 수 없다. 하지만 그 영향을 최소화 할 수는 있다. 첫 번째 방법은 DOM 기반의 스타일 변경을 최소화해 리렌더링을 최소화하는 방법이다. 다음과 같이 구현하면 스타일 변경을 줄일 수 있다.애니메이션 대상의 위치 속성을 ‘position:absolute’로 지정하면 이러한 대상 요소의 위치를 변경할 때 다른 요소의 미치는 영향을 줄일 수 있다. 대상 요소의 투명도와 배경 이미지의 변경을 자제한다. 배경 이미지 대신 고정된 크기의 IMG 요소로 대체 하루 있으면 좋다.두 번째 방법은 setTimeout() 메서드 대신 requestAnimationFrame API를 사용하는 방법이다. requestAnimationFrame API와 setTimeout() 메서드는 기능이 거의 같다. 하지만 setTimeout() 메서드가 단위 시간마다 무조건 애니메이션을 호출하는 것과 달리, requestAnimationFrame API는 브라우저에서 화면 업데이트가 가능한 시기를 통보받아 애니메이션을 호출한다. 그렇기 때문에 끊김 없는 부드러운 애니메이션을 구현할 수 있으며, 불필요한 자원 사용을 방지해 전력소비를 줄일 수 있다. 다음은 requestAnimationFrame API를 사용해 애니메이션을 구현한 예다. 123456789101112131415161718window.requestAnimationFrame = (function() &#123; return window.requestAnimationFrame || window.webktRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function() &#123; window.setTimeout(callback, 1000/60); &#125;&#125;)();var elBox = document.getElementById(&#x27;box&#x27;), nAnimateTimer = null, fAnimate = function() &#123; elBox.style.left = parseInt(elBox.style.left, 10) + 5 + &#x27;px&#x27;; //종료시점 if (parseInt(elBox.style.left, 10) &lt; 300) &#123; nAnimateTimer = requestAnimationFrame (fAnimate); &#125;&#125;;nAnimateTimer = requestAnimationFrame (fAnimate); requestAnimationFrame API는 W3C의 명세 초안(draft)으로 애니메이션을 위한 효과적인 그래픽 타이머다. 하지만 안타깝게도 현재는 크롬 10 이상, 인터넷 익스 플로러 10 이상, 오페라 모바일, 파이어폭스4 이상에서 고유의 접두어(prefix)를 붙여야 사용할 수 있고, 모바일 웹 브라우저에서는 이 메서드가 동작하지 않는다. 그러나 머지않아 모든 모바일 브라우저에서 사용 할 수 있을 것이다. CSS3 기반의 애니메이션 CSS3 기반의 애니메이션은 자바스크립트 기반의 애니메이션과 달리 애니메이션의 처음과 끝은 개발자가 아닌 브라우저가 인지하고 관리한다. 따라서 다음과 같은 장점이 있다. 웹 브라우저는 단일 스레드를 사용하기 때문에 애니메이션이 동작하는 도중에 비동기식 작업이 진행되면 애니메이션이 매끄럽게 진행되지 못하지만 CSS3 기반의 애니메이션을 이용할 때는 이러한 간섭이 발생하지 않는다.하드웨어인 GPU의 가속 기능을 사용할 수 있어서 속도가 빠르다.복잡한 계산으로 얻을 수 있는 애니메이션 이동 곡선을 속성값 설정만으로 간단하게 구현할 수 있다.CSS3에서는 동적인 애니메이션 처리를 쉽게 적용할 수 있는 transition 속성과 transform 속성, 직관적인 @keyframe 애니메이션등을 제공하고 있다. 구현하기 CSS3 트랜지션은 CSS 속성을 변경함으로써 대상 요소를 일정 시간 동안 자연스럽게 이동하는 기술이다. CSS만을 이용해 구현할 수도 있지만 자바스크립트를 함께 사용하면 더욱 효과적으로 애니메이션을 구현할 수 있다. CSS3 트랜지션을 이용한 애니메이션은 보통 다음과 같은 순서로 구현한다. 1.애니메이션 대상이 되는 DOM의 처음 스타일을 지정한다. 1&lt;div id=&quot;box&quot; style=&quot;position:absolute;border:1px solid red;left:0px;width:100px;height:100px;&quot;&gt;&lt;/div&gt; 2.애니메이션 대상 요소에 트랜지션을 지정한다. 12345678910// -webkit-transition : [변경될 대상의 스타일] [duration] [timing function] [delay]// 애니메이션을 적용할 스타일과 애니메이션 지속 시간(duration), 애니메이션 방식(timing function), 초기 지연(delay)을 지정할 수 있다. 다음은 애니메이션이 천천히 끝나게 하는 ease-out 방식으로 2초동안 left 속성을 변경하는 예다.&lt;style&gt;.leftTransition&#123;-webkit-transition:left 2s ease-out&#125;&lt;/style&gt;&lt;script&gt;var ele = document.getElementById(&#x27;box&#x27;);ele.className = &#x27;leftTransition&#x27;;&lt;/script&gt; 3.자바스크립트로 마지막 상태의 스타일을 지정한다. 4.애니메이션이 완료되면 onTransitionEnd 이벤트가 발생한다. 다은은 left 속성을 300px로 지정하는 예다. 12var ele = document.getElementById(&#x27;box&#x27;);ele.style.left= &#x27;300px&#x27;; transform 속성을 이용한 애니메이션 transform속성을 이용하면 left 속성과 top 속성을 변경하지 않고, translate 값을 변경해 애니메이션을 구현할 수 있다. 이 방법은 다음과 같은 장점이 있다. 레이어(layer)로 구성되어 애니메이션이 발생하는 동안에 레이어 병합을 사용하기 때문에 애니메이션 도중 렌더링이 계속 발생하지 않아 속도가 빠르다.traslate3d 속성을 사용해 GPU 가속 기능을 사용할 수 있다. 단 안드로이드는 3.0(허니콤) 이상에서 지원한다.transform 속성과 translate 속성을 이용하려면 다음과 같이 transition 속성에서 변경될 대상의 스타일을 transform으로 지정하고, translate 속성을 사용한다. 123&lt;style&gt;.leftTransition&#123;-webkit-transition:left 2s ease-out;-webkit-transform:translate(0,0)&#125;&lt;/style&gt; 이 때 GPU 기능을 사용하려면 translate 대신 translate3d로 지정하고, translate 속성에 z좌표를 하나 더 지정한다. 123&lt;style&gt;.leftTransition&#123;-webkit-transition:left 2s ease-out;-webkit-transform:translate3d(0,0,0)&#125;&lt;/style&gt; CSS3 기반 애니메이션의 문제점 웹킷 기반의 모바일 브라우저는 CSS3 트랜지션을 모두 활용해 최적의 애니메이션을 구현할 수 있다. 하지만 다음과 같은 문제점이 있다. CSS3 사용해서 얻을 수 있는 최고 효과인 성능 향상을 얻으려면 3D 속성을 사용해 GPU 가속을 활성화해야 하지만 3D 속성에 관련된 오류가 여럿 있어 현실적으로 트랜지션을 적용하는 데 많은 어려움이 있다.GPU 가속 기능을 사용하면 네이티브 앱과 같은 성능을 얻을 수 있는 반면, 전력 소모는 증가한다.애플의 모바일 기기는 안정적인 GPU를 탑재해 최고의 성능을 얻을 수 있다. 하지만 그 외 제조사의 기기에는 GPU가 있다고 해도 제조사에 따라 GPU의 성능에 확연한 차이가 있다.기술적으로는 웹에서 애니메이션을 구현하는 최고의 방법은 CSS3를 이용하는 것이다. CSS3를 이용하면 전력 소모 문제를 제외하고는 모든 면에서 다른 방법보다 우수하다. 하지만 실제로는 CSS3를 구현한 모바일 브라우저 및 제조사의 오류로 인해 이 방법을 사용하기는 힘들다. 그러나 브라우저 오류를 우회할 수 있는 여러 방법으로 CSS3와 관련되 오류를 피할 수 있다. iOS의 브라우저에서는 ‘애니메이션 대상’에 CSS3 Transform 3D(translate3d, preserve-3d) 속성을 처음에 지정할 때 해당 요소가 깜빡이는 문제가 있다. iOS는 CSS3 Transform 3D 속성을 지정할 때 애니메이션에 필요한 정보를 OpenGL Textrue 형태로 GPU에 저장한다. 이때 요소가 깜빡이는 현상이 나타난다. 이 문제를 해결할려면 애니메이션 대상이 되는 요소를 보이지 않게 하고 CSS3를 설정한 다음 요소를 보이게 한다. 그 외에도 iOS 브라우저에서는 화면 전체가 깜빡이는 현상이 나타날 때도 있다. CSS3의 translate3d 속성을 사용하는 웹 페이지에 em 값의 절대치가 큰(-9999em,200em 등) 요소가 있으면 페이지 전체가 깜빡이게 된다. 이 때는 em값을 -70 ~70em의 값으로 바꾸거나 단위를 em에서 px로 수정하면 문제를 해결할 수 있다. iOS 4에서 화면 깜빡거림 iOS 4는 1024 x 1024px의 텍스처(texture) 단위로 정보를 생성하는데, 1024 x 1024px 범위를 넘는 콘텐츠가 있을 때는 지속적으로 화면이 깜빡거리거나 애니메이션이 지연되는 문제가 생실 수 있다 iOS 5는 iOS 4보다 큰 텍스처 단위로 정보를 생성하기 때문에 문제가 발생되지 않는다. iOS에서 발생되는 애니메이션 관련 문제의 더 많은 사례는 http://joehewitt.com/2011/10/05/fast-animation-with-ios-webkit/ 을 참고한다.안드로이드 브라우저에서는 애니메이션 동작 후 링크를 눌렀을 때의 하이라이트가 정상적으로 나오지 않고, 이동 전 영역의 좌표가 터치한 영역으로 표시되는 문제가 있다. 이 문제를 해결하려면 다음과 같은 순서로 수정해야 한다. 애니메이션이 끝나면 자바스크립트로 지정한 CSS3 속성(translate, translate3d)을 해지하게 한다.자바스크립트로 대상 요소의 위치(left,top,offset)를 다시 지정한다.애니메이션 내부 영역 태그에서 focus() 메서드를 호출한다. 참고 &lt;a&gt; 태그에는 포커스가 이동해도 소프트 키보드가 나타나지 않기 때문에 내부 영역의 태그로는 &lt;a&gt; 태그를 사용한다. 1&lt;a href=&quot;javascript:void(0)&quot; style=&quot;position:absolute;left:-9999px&quot;&gt;&lt;/a&gt; 그 밖에 translate3d 속성과 함께 다른 속성을 사용하면 애니메인션이 작동하지 않는 문제도 있다. 1&lt;div style=&quot;-webkit-transition:-webkit-transform 2s ease-out;-webkit-transform:translate3d(30px,0,0),rotate(45deg)&quot;&gt;애니메이션&lt;/div&gt; 자바스크립트 기반 애니메이션과 CSS3기반 애니메이션의 혼합 앞에서 설명한 자바스크립트 기반 애니메이션과 CSS3 기반 애니메이션은 각기 장단점이 있다. 이번에는 이 두가지 방법을 혼용해서 애니메이션을 구현하는 방법을 설명하겠다. 이 방법의 핵심은 애니메이션 주기는 자바스크립트로 구현하고 DOM 요소의 이동 및 변경은 CSS3로 구현하는 것이다. 이렇게 혼용한 방식을 적용하면 다음과 같은 장점이 있다. CSS3를 사용해 DOM 요소를 이동하거나 DOM 요소의 상태를 변경하기 때문에 GPU 가속을 사용할 수 있고, 리렌더링이 발생하지 않는다.안드로이드 브라우저에서 translate() 메서드나 translate3d() 메서드로 인해 발생하는 잔상 및 깜빡임 현상이 거의 발생하지 않는다. 구현하기 자바스크립트로 단위 시간마다 함수를 호출하고, 함수가 호출될 때마다 처리되는 DOM 요소의 이동 및 상태 변화는 CSS3를 사용하도록 애니메이션을 구성한다. 자바스크립트 방식 CSS3 방식을 혼합한 애니메이션은 대게 다음과 같은 순서로 구현한다. 1.애니메이션 대상이 되는 DOM 작성한다. 1&lt;div id=&quot;box&quot; style=&quot;position:absolute;left:10px;border:1px solid red;width:100px;height:100px;&quot; class=&quot;leftTranslate3d&quot;&gt;&lt;/div&gt; 2.원하는 FPS에 해당하는 단위 시간(ms)을 구한다. 3.애니메이션 대상에 트랜지션을 지정한다. 이 때 애니메이션 지속 시간(duration)은 0으로 지정한다. 123456&lt;style&gt;.leftTransition&#123;-webkit-transition:left 2s ease-out&#125;&lt;/style&gt;&lt;body&gt;&lt;div id=&quot;box&quot; style=&quot;position:absolute;left:10px;border:1px solid red;width:100px;height:100px;&quot; class=&quot;leftTranslate3d&quot;&gt;&lt;/div&gt;&lt;/body&gt; 4.애니메이션 대상을 이동하는 fAnimate() 함수를 작성한다. DOM 요소의 이동은 CSS3를 사용해 구현한다. 123456var fAnimate = function() &#123; nLength += 5; elBox.style.webkitTransform = &#x27;translate3d(&#x27; + nLength + &#x27;px, 0px, 0)&#x27;; nAnimateTimer = setTimeout(1000/60);&#125;; 5.setTimeout() 메서드 setInterval() 메서드, requestAnimationFrame() 메서드 등을 이용해 fAnimate() 함수를 단위 시간(ms)마다 호출한다. 다음은 setTimeout() 메서도로 아이디가 ‘box’인 DIV 요소를 단위 시간(약 16.7ms)마다 5px씩 오른쪽으로 이동하는 예다. 12345678910var elBox = document.getElementById(&#x27;box&#x27;), nAnimateTimer = null, nLength = 0;, fAnimate = function() &#123; nLength += 5; elBox.style.webkitTransform = &#x27;translate3d(&#x27; + nLength + &#x27;px, 0px, 0)&#x27;; nAnimateTimer = setTimeout(1000/60); &#125;;nAnimateTimer = setTimeout(1000/60); 자바스크립트와 CSS3를 혼합한 애니메이션의 문제점 자바스크립트와 CSS3를 혼합해서 사용하기 때문에 이 방식 또한 자바스크립트 기반 방식에 있는 문제점을 똑같이 안고 있다. 애니메이션 시간 주기를 자바스크립트로 제어하기 때문에 구현이 어렵다.시간 주기가 자바스크립트로 구현되기 때문에 CSS3 방식에 비해 애니메이션이 매끄럽지 못하다.requestAnimationFrame API를 사용하지 못하는 지금의 모바일 환경에서는 setTimeout() 메서드나 setInterval() 메서드로 호출하기 때문에 시간의 정확성을 보장받지 못해 실제 애니메이션은 매끄럽지 못하거나 부자연스럽게 표현된다.자바스크립트와 CSS3 혼합한 애니메이션은 자바스크립트에 비해 더 훌륭한 성능을 보장하고 CSS3 문제점을 해셜 할 수는 있는 방법이지만, 위에서 언급한 애니메이션 구현 방법 및 품질, 전력 소모에 대한 문제는 여전히 남아있다. 다음 표를 살펴보면 성능 면에서는 자바스크립트와 CSS3를 혼용하는 방법과 CSS3에 기반을 둔 방법이 가장 우수하고, 애니메이션 품질면에서는 CSS3 기반 애니메이션이 좋다. 구현 난이도 부분에서는 자바스크립트 기반 방식이 유리하다는 점을 알 수 있다. 하지만 절대적으로 모든 면에서 우수한 방법은 없다. 구분 자바스크립트 기반 CSS3 기반 자바스크립트 + CSS3 기반 동작 방식 브라우저는 애니메이션을인지하지 못하고, 무조건DOM과 스타일을 변경하는 작업을 한다. 애니메이션 시작 시브라우저가 애니메이션의처음과 끝을 인지해서작동한다. 애니메이션 처리 함수호출 주기는 브라우저가인지하지 못하나, 변경되는대상의 상태 변화는 인지할 수 있다. 성능 보통단, requestAnimationFrameAPI를 적용할 때 효과적이다. 좋음 좋음 GPU 가속 사용 못함 사용 사용 애니메이션 품질 하 상 중 구현 난이도 상 하 중 전력 소모 많음 GPU 가속시 현저히 증가 GPU 가속시 현저히 증가 안정성 좋음 안드로이드 기기에서오류가 많음iOS 기기에서는 최고의성능과 품질을 제공함 좋음 향후 모바일 브라우저 개발 회사와 모바일 기기 제조사가 CSS3와 GPU 안정성을 확보함으로써 성능, 구현, 품질, 안정성이 뛰어난 CSS3 방식의 애니메이션을 사용할 수 있겠지만, 현재는 상황에 맞는 적절한 현실적인 대안을 찾아야 한다. 현재 가장 현실적인 대안은 운영체제와 모바일 기기에 따라 CSS3 방식 애니메이션을 사용하거나 자바스크립트와 CSS3를 혼용한 애니메이션을 사용하는 것이다. 물론 기기마다 약간의 특성이 있지만 다음과 같은 방법으로 애니메이션을 구현한다면 모바일 웹에서 최적의 애니메이션 성능을 나타낼 수 있을 것이다. 구현 방식 적용 운영체제와 모바일 기기 CSS3 CSS3 방식 애니메이션의 안정성이 확보된 iOS 기기GPU 가속이 원활히 이워지는 삼정전자의 안드로이드 기기 자바스크립트와 CSS3 혼용 CSS3 방식 애니메이션의 안정성이 낮은 대부분의 안드로이드 기기","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Javascript","slug":"Frontend/Javascript","permalink":"https://woonyzzang.github.com/categories/Frontend/Javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://woonyzzang.github.com/tags/js/"}]},{"title":"Javascript PagesShow PagesHide Event","slug":"javascript-pages-show-hide-event","date":"2017-05-15T11:36:45.000Z","updated":"2024-06-10T05:06:39.246Z","comments":true,"path":"2017/05/15/javascript-pages-show-hide-event/","permalink":"https://woonyzzang.github.com/2017/05/15/javascript-pages-show-hide-event/","excerpt":"","text":"JavaScript pageshow 이벤트, pagehide 이벤트네트워크 연결 속도가 느리고 연결 비용이 높은 모바일 환경에서는 pageshow 이벤트와 pagehide 이벤트가 중요하다. PC와는 다르게 모바일 브라우저에서는 이 이벤트가 페이지 캐시를 모두 지원하기 때문에 특별히 활용도가 높다. pageshow 이벤트와 pagehide 이벤트는 window 객체의 이벤트로서 lod 이벤트, unload 이벤트와 유사하게 동작하며, iOS 4.0 이상의 사파리와 안드로이드 2.2 이상의 기본 브라우저에서만 발생한다. pageshow 이벤트 pageshow 이벤트는 load 이벤트 다음에 발생하는 이벤트로, 페이지가 열릴 때 마다 항상 발생한다. 단 페이지가 캐싱됐을 때는 load 이벤트가 발생하지 않고 pageshow 이벤트만 발생한다. 페이지가 캐싱됐을 때는 pageshow 이벤트의 persisted 속성값이 true로 반환된다. 반명 페이지가 캐싱되지 않았을 때는 load 이벤트가 발생하고 persisted 속성값이 false로 반환된다. 페이지 캐싱 브라우저가 모바일 기기의 브라우저 세션에 대해 자바스크립트를 포함한 전체 웹 페이지를 메모리에 캐싱하는 것을 말한다. 페이지 캐싱을 사용하면 브라우저의 뒤로 이동 버튼과 앞으로 이동 버튼으로 페이지를 이동할때 페이지를 다시 로딩하지 않고 캐싱된 페이지를 빠르게 보여준다. 그렇기 때문에 네트워크 상황이 좋지 않은 모바일 환경에서는 페이지 캐싱을 중요하게 여긴다. pagehide 이벤트 pagehide 이벤트는 unload 이벤트처럼 페이지가 언로드(unload)될 때 발생한다. pageshow 이벤트와 마찬가지로 캐싱된 페이지에서는 unload 이벤트는 발생하지 않지만 pagehide 이벤트는 발생한다. 기기별 이벤트 특징 pageshow 이벤트와 pagehide 이벤트는 운영체제와 단말기에 따라 발생하는 시점이 다르고, 상태에 따라 페이지 캐싱 여부가 달라진다. 상황 아이폰에서의이벤트 발생여부(iOS 4.x ~ 7.x) 아이패드에서의이벤트 발생 여부(iOS 4.x ~ 7.x) 안드로이드에서의이벤트 발생 여부(안드로이드 2.x ~ 4.x) 브라우저에서 새창을 열 경우 이벤트 발생 이벤트 발생 안함 이벤트 발생 안함 브라우저 탭을 이동한 경우 이벤트 발생 이벤트 발생 안함 이벤트 발생 안함 홈 버튼을 누른 후 브라우저를다시 실행 한 경우 이벤트 발생 이벤트 발생 이벤트 발생 안함 전원 버튼을 눌러 잠긴 상태에서잠금을 해제한 경우 이벤트 발생 이벤트 발생 이벤트 발생 안함 브라우저 탭을 전환하거나 새 창을 여는 경우를 제외하고, iOS 환경에서는 대상 브라우저 페이지가 비활성화되고 다시 활성화됐을 때 모두 pageshow 이벤트와 pagehide 이벤트가 발생환다. 반면 안드로이드 환경에서는 현재 보고 있는 브라우저에 외부 영향이 있을 경우에는 모두 이벤트가 발생하지 않는다. 페이지 캐싱이 되지 않는 경우 모바일 웹에서는 기본적으로 페이지 캐싱을 사용한다. 하지만 브라우저의 특정 기능 사용으로 웹 페이지가 캐싱되되 않는 경우가 있다. 그 경우는 다음과 같다. onunload 이벤트 핸들러나 onbeforeunload 이벤트 핸들러를 사용한 경우 “cache-control:no-store”가 HTTP 헤더에 설정된 경우 페이지가 완전히 로딩되기 전에 페이지를 이동한 경우 iFrame을 사용한 경우 navigation.geolocation을 사용한 경우 모바일 브라우저의 전체 화면 사용하기 주소창을 감추고 브라우저의 전체 화면에 콘텐츠를 보여주는 UI를 구현할 때는 일반적으로 scrollTop() 메서드를 이용한다. scrollTop() 메서드로 문서의 처음으로 이동하면 모바일 브라우저의 주소창이 사라진다. 주소창을 사라지게 한 상태에서 브라우저의 크기를 확인하면 화면 전체의 크기를 구할 수 있다. 하지만 scrollTop() 메서드는 브라우저의 높이보다 문서(document)의 높이가 더 큰 상태에서 호출돼야 한다. 브라우저의 높이보다 문서의 높이가 작다면 scrollTop() 메서드를 호출해도 주소창이 사라지지 않는다. 콘텐츠의 양에 따라 문서의 높이가 브라우저보다 작을 수 있기 때문에 UI를 구현할 때는 scrollTop() 메서드를 호출하지 전에 브라우저 높이보다 큰 DIV 요소를 임시로 넣는 방법을 사용한다. 다음은 DIV 요소를 만들어 문서에 추가한 다음 요소의 높이가 브라우저의 높이보다 200px 더 크게 스타일을 적용하는 코드다. 브라우저의 높이는 window.innerHeight 속성으로 구할 수 있다. 123456if (!this._fullSizeCheckElement) &#123; this._fullSizeCheckElement = document.createElemet(&#x27;div&#x27;); document.body.appendChild( this._fullSizeCheckElement );&#125;this._fullSizeCheckElement.style.cssText = &#x27;&#x27;position:absolute;top:0px;width:100p%;height:&#x27; + parseInt(window.innerHeight + 200, 10) + &#x27;px;&#x27;; 임시 div 요소를 추가 했다면 주소창을 사라지게 한다. 브라우저에서 지원하는 API에는 주소창을 사라지게 하는 API가 없지만 자바스크립트의 scrollTop() 함수를 사용하면 모바일 웹 브라우저의 주소창을 사라지게 할 수 있다. 다음과 같이 문서의 위쪽에서 1px 위치로 이동하게 하면 주소창이 사라지면서 전체 화면이 나타난다. 1window.scrollTop(0, 1); 단, iOS 7의 사파리에서는 scrollTop() 함수를 사용해도 주소창이 사라지지 않는다. 이는 오류가 아닌 iOS 7의 특성이라고 볼 수 있다. 주소창이 사라졌다면 브라우저의 높이와 너비를 구할 차례다.브라우저의 너비와 높이는 window.innerWidth 속성과 window.innerHeight 속성으로 구할 수 있다. 주소창이 없는 상태에서 브라우저의 너비와 높이를 구한 다음에는 임시 div 요소의 높이를 0px로 바꾼다. 임시 div 요소의 목적이 브라우저의 주소창을 사라지게 하는 것이었으므로 더는 화면에 보일 필요가 없기 때문이다. 123456var htSize = &#123; width: window.innerWidth, height: window.innerHeight&#125;;this._fullSizeCheckElement.style.height = &#x27;0px&#x27;;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Javascript","slug":"Frontend/Javascript","permalink":"https://woonyzzang.github.com/categories/Frontend/Javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://woonyzzang.github.com/tags/js/"},{"name":"mobile","slug":"mobile","permalink":"https://woonyzzang.github.com/tags/mobile/"}]},{"title":"Javascript Mobile Browser Different Event","slug":"javascript-mobile-browser-different-event","date":"2017-05-15T10:59:34.000Z","updated":"2024-06-10T04:53:59.566Z","comments":true,"path":"2017/05/15/javascript-mobile-browser-different-event/","permalink":"https://woonyzzang.github.com/2017/05/15/javascript-mobile-browser-different-event/","excerpt":"","text":"JavaScript 데스크톱과 다르게 동작하는 이벤트모바일 브라우저에서도 화면이 스크롤되면 scroll 이벤트가 발생하고, 키보드와 마우스 관련 이벤트도 발생한다. 그러나 모바일 브라우저에서 발생하는 이런 이벤트는 데스크톱 브라우저에서 발생할 때와는 발생 순서나 발생 횟수 등이 다르다. scroll 이벤트 scroll 이벤트는 브라우저의 스크롤 막대가 움직일 때 발생하는 이벤트다. PC에서 스크롤 막대를 내리거나 올릴 때 고정된 위치에 요소가 계속 보이게 할 때 scroll 이벤트를 많이 사용한다. 그 외에도 콘텐츠 주위에 계속 나타나는 레이어 또는 메뉴들을 scroll 이벤트로 제어한다. 모바일 브라우저에서 scroll 이벤트의 특징 PC에서는 스크롤 막대가 이동할 때 이벤트가 발생한다. 모바일 브라우저에서도 스크롤 위치가 변동될 때 scroll 이벤트가 발생하지만 모바일의 특정상 몇 가지 특징이 있다.scroll 이벤트는 브라우저의 window 객체와 문서의 DOM 영역에서 발생한다. 하지만 overflow:scroll 속성을 지원하는 iOS 5 부터는 overflow:scroll 속성이 적용된 요소에서도 scroll 이벤트가 발생한다. scroll 이벤트는 스크롤 위치가 변경될 때, window.scrollTo() 메서드나 window.scrollBy() 메서드가 호출될 때 발생한다. 그리고 모바일 특정상 iOS에서는 주소창이 감춰졌다 화면에 나타나거나 콘텐츠 양에 따라 화면이 스크롤 되어 주소창이 사라질 때도 scroll 이벤트가 발생한다. 안드로이드에서는 주소창이 화면에 나타나거나 사라질 때 scroll 이벤트가 아니라 resize 이벤트가 발생한다. 다음은 iOS와 안드로이드에서 scroll 이벤트의 발생 시점을 비교한 표다. 구분 iOS 안드로이드 스크롤 위치 이동 발생 발생 scrollTo() 메서드 호출scrollBy() 메서드 호출 iOS 5 이상 : 발생iOS 4 이하 : 발생 안함 발생 주소창이 나타나거나 사라질 때 발생단, iOS 7 에서는 발생 안함 발생 안함resize 이벤트 발생 모바일 기기마다 scroll 이벤트 발생 시점과 발생 횟수가 다르다. iOS에서는 스크롤 이동이 끝난 상태에서 scroll 이벤트가 발생한다. 반면 안드로이드에서는 스크롤하고 있는 도중에 scroll 이벤트가 발생한다. 이벤트 발생 순서도 모바일 운영체제와 제조사, 버전에 따라 다르다. iOS의 scroll 이벤트 발생 순서 버전 이벤트 발생 순서 7.x6.x5.x4.x touchstart -&gt; touchmove(1~n개) -&gt; touchend -&gt; scroll 안드로이드의 scroll 이벤트 발생 순서 버전 제품 이벤트 발생 순서 4.2 갤럭시 S4 touchstart -&gt; touchmove -&gt; scroll((1n개)) -&gt; touchend -&gt; scroll(1n개) 4.1 갤럭시 S3 touchstart -&gt; touchmove -&gt; touchend -&gt; scroll(1~n개) 4.1 갤럭시 S2 touchstart -&gt; touchmove -&gt; scroll(1~n개) 4.1 옵티머스 G touchstart -&gt; touchmove -&gt; scroll((1n개)) -&gt; touchend -&gt; scroll(1n개 4.0 갤럭시 S3갤럭시 S2갤럭시 노트넥서스 S touchstart -&gt; touchmove -&gt; scroll(1~n개) 3.1 갤럭시 탭2 touchstart -&gt; touchmove -&gt; touchend 2.3.6 갤럭시 S2 touchstart -&gt; touchmove -&gt; scroll(1~n개) 2.1 갤럭시 S touchstart -&gt; touchmove -&gt; touchend -&gt; scroll(1~n개) 마우스 이벤트와 키보드 이벤트 모바일과 데스크톱의 차이점 가운데 하나는 사용자 인터페이스다. 데스크톱에서는 사용자가 키보드와 마우스를 사용하지만 모바일에서는 키보드 대신 소프트 키보드를 사용하고 마우스 대신 터치 화면을 사용한다. 기본적으로 모바일 웹에서는 모바일 기기에서 사용하지 않는 이벤트를 사용할 필요가 없다. 하지만 모바일과 데스크톱에 모두 대응해야 한다면 두 환경에서 일어나느 ㄴ이벤트의 차이를 알아야 사용자에게 더 적합한 서비스를 제공할 수 있다. 데스크톱에서는 빈번하게 사용하지만 모바일에서는 사용할 수 없는 사용자 인터페이스의 이벤트인 마우스 이벤트와 키보드 이벤트를 살펴보겠다. 마우스 이벤트 마우스는 대표적인 데스크톱 사용자 인터페이스다. 모바일 기기에서는 마우스를 사용ㄹ하지 않지만 실제로는 마우스 이벤트가 모바일 웹에서도 발생한다. 모바일 웹에서 사용자가 화면을 터치했을 때 마우스 이벤트가 함께 발생한다. 마우스를 사용하지 않기 대문에 마우스 이벤트가 발생하지 않는 것이 맞지만 데스크톱 브라우저에 근간을 둔 브라우저의 성격상 마우스 관련 이벤트가 함께 발생한다. 마우스 이벤트는 다음과 같다. 데스크톱의 마우스 이벤트는 모바일 웹의 터치와 비슷하다. 다만 mouseover 이벤트나 mousewheel 이벤트와 같이 마우스 포인터의 움직임으로 발생하는 이벤트나 마우스 휠의 동작으로 발생하는 이벤트는 다르게 동작한다. 이벤트 데스크톱에서 동작 모바일에서 특징 mousedown 요소 위에서 마우스 버튼을눌렀을 때 발생한다. touchstart 이벤트와 유사하다. mousemove 요소 위에서 마우스를움직였을 때 발생한다. touchmove 이베트와 유사하다.단, mousemove 이벤트와 다르게 touchmove 이벤트는touchstart 이벤트가 발생한 이후에 발생한다. mouseup 요소 위에서 누르고 있던마우스 버튼을 뗏을 때발생한다. touchend 이벤트와 유사하다. mousewheel 마우스의 휠을 움직일 때발생한다. overflow:scroll 속성이 있는 곳에서만 이벤트가 발생한다.iOS 5.0부터 이벤트가 발생하고, 안드로이드에서는이벤트가 발생하지 않는다. mouseover 요소 위에 마우스 포인터가있을때 발생한다. iOS에서는 요소에 처음으로 포커스가 이동할 때 한 번발생한다.안드로이드에서는 요소에 포커스가 이동할 때마다발생한다. 마우스 이벤트는 기본적으로 터치 이벤트보다 먼저 발생한다. 그래서 마우스 이벤트에서 이벤트를 중지시키면 뒤에 발생하는 터치 이벤트에도 영향을 미칠 수 있다. 모바일에서 마우스 이벤트와 터치 이벤트가 발생하는 순서는 mouseover 이벤트 -&gt; mousedown 이벤트 -&gt; touchstart 이벤트 -&gt; mousemove 이벤트 -&gt; touchmove 이벤트 -&gt; … -&gt; mouseup 이벤트 순서이다. 키보드 이벤트 데스크톱에는 키보드가 있고, 모바일에는 소프트 키보드가 있다. 소프트 키보드는 입력란이나 주소창을 선택했을 때 화면에 나타난다. 화면에 나타난 소프트 키보드의 배열은 입력란의 유형에 따라 달라진다. 키보드나 소프트 키보드는 데스크톱에서나 모바일에서나 같은 역활으 ㄹ하지만 실제 발생하는 이벤트는 약간 다르다. 모바일에서 키보드 이벤트의 특징은 다음과 같다. 이벤트 데스크톱에서 동작 모바일에서 특징 keydown 사용자가 키를눌렀을 때 발생한다. 한글을 입력할 때는 키코드(keyCode)값이 모두 0으로 나타난다.iOS에서는 이벤트가 정상적으로 발생하고, 안드로이드에서는2.3버전부터 이벤트가 발생한다. keypress 사용자가 기능키를제외한 키를 눌렀을 때발생한다. iOS에서는 이벤트가 정상적으로 발생하고, 키코드 값을정상적으로 반환한다.안드로이드에서는 4.1 버전부터 이벤트가 발생한다. input 폼 요소의 값이변경되면 발생한다. iOS에서는 한글을 입력하면서 글자가 만들어 질 때마다2번씩 발생한다.예를 들어’손’ 을 입력했을 때 이벤트 발생횟수는 다음과 같다.-ㅅ: 이벤트 1번 발생-소: 이벤트 3번 발생(이벤트가 2번 더 발생했다)-손: 5번 발생(이벤트가 2번 더 발생했다)안드로이드에서는 이벤트가 정상적으로 발생한다. keyup 사용자가 눌렀던 키를뗏을 때 발생한다. keydown 이벤트와 동일하다. 모바일에서는 대상 이벤트에서 발생하는 키코드 값이 한글일 때도 정상적인 값을 반환하지 못한다. 이는 모바일 운영체제에서 다국어 입력에 대한 고려가 부족한 발생하는 오류로 보인다. 이런 문제는 안드로이드와 iOS에서 모두 나타난다. 국내 기업인 삼성이나 LG에서 만든 안드로이드 폰에서는 이러한 문제가 발생하지 않는다. 모바일에서는 실제 마우스나 키보드가 존재하지 않지만 모바일 브라우저에서는 관련 이벤트가 발생한다. 이는 데스크톱에 근간을 둔 브라우저의 성격으로 인해 발생한 논리적인 문제로 보인다. 아마도 이부분에 대해서는 점차 표준화 작업이 진행될 것으로 보인다. 대표적인 예로, 인터넷 익스플로러 10부터는 Ponter 이벤트가 새로 생겼다. Pinter 이벤트는 포인터를 가리키는 마우스나 터치를 포괄하는 개념의 이벤트다. 실제 Pointer 이벤트는 데스크톱에서는 마우스가 동작할 때 발생하고, 모바일에서는 화면을 터치할 때 발생한다.","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Javascript","slug":"Frontend/Javascript","permalink":"https://woonyzzang.github.com/categories/Frontend/Javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://woonyzzang.github.com/tags/js/"},{"name":"mobile","slug":"mobile","permalink":"https://woonyzzang.github.com/tags/mobile/"}]},{"title":"Javascript Mobile Browser Event API","slug":"javascript-mobile-browser-event-api","date":"2017-05-15T09:49:00.000Z","updated":"2024-06-10T04:53:59.567Z","comments":true,"path":"2017/05/15/javascript-mobile-browser-event-api/","permalink":"https://woonyzzang.github.com/2017/05/15/javascript-mobile-browser-event-api/","excerpt":"","text":"JavaScript 모바일 브라우저 전용 이벤트모바일 브라우저 환경에서 특화되어 사용되는 이벤트 API를 살펴보자. 터치 이벤트 PC에서는 마우스나 키보드로 애플리케이션을 사용하는 데 필요한 동작과 정보를 입력한다면 모바일 환경에서는 사용자 터치로 필요한 동작과 정보를 입력한다. 동작과 정보를 입력하기 위해 기기의 화면에 손가락을 댔을 때 발생하는 이벤트가 터치 이벤트다. 모바일 환경에서도 마우스 이벤트가 발생하지만 터치 이벤트보다 느리고 비정상적으로 발생하기 때문에 이용하기 어렵다. 또한 마우스 이벤트로는 손가락 여러 개로 터치했을 때의 모든 터치 정보를 얻을 수 없다. 모바일 환경에서 사용자 터치를 이용하는 플리킹이나 스크롤 같은 기능을 구현하려면 터치 이벤트에 대해 알아야 한다. 터치 이벤트는 데스크톱 브라우저의 마우스 이벤트와 유사하나 몇 가지 다른 점이 있다. 터치 이벤트는 사용자가 2~3개의 손가락으로 화면을 조작할 경우 각 터치에 대한 정보를 모두 얻을 수 있다.mouseover 이벤트에 대응하는 터치이벤트는 없다. 정확한 좌표값을 얻을 수 있는 마우스 이벤트와 달리 손가락 접촉면이 큰 터치 이벤트는 접촉 표면의 평균 좌표값을 얻는다.터치 이벤트는 클릭 이벤트나, 스크롤 이벤트, 마우스 이벤트보다 먼저 발생한다. 터치 이벤트에서 기본 기능을 막거나 이벤트 버블링을 중지한다면 이후에 발생하는 이벤트에 영향을 줄 수 있으므로 주의해야 한다. 현재 터치 이벥트는 웹킷 계열의 브라우저(iOS용 사파리, 안드로이드)에서만 지원하고 그 밖의 브라우저(오페라 미니, 파이어폭스, 인터넷 익스플로러 모바일 등)에서는 지원하지 않는다. 최근 출시한 윈도우8 모바일에서는 포인터(MSPointer) 이벤트가 추가돼서 이를 터치 이벤트 대신 사용할 수 있다. 터치 이벤트의 종류와 이벤트 객체의 속성 터치 이벤트에는 이벤트가 발생하는 시정에 따라 다음과 같이 네 가지 종류의 이벤트가 있다. 이벤트 이름 설명 touchstart 화면에 손가락이 닿을 때 발생한다. touchmove 화면에 손가락을 댄 채로 움직일 때 발생한다. touchend 화면에서 손가락을 뗄 때 발생한다. touchcancel 시스템에서 이벤트를 취소시킬 때 발생한다.터치 이벤트를 취소한다는 것에 대한 표준이 정의돼 있지 않아 정확한 발생 조건은브라우저마다 다르다.touchend 이벤트로 간주해도 무방하다. 터치에 대한 정보는 이벤트 객체의 touches 속성과 targetTouches 속성, changedTouches 속성에 배열 형태로 저장된다. 배열의 크기는 터치한 손가락 개수에 따라 결정된다. 멀티 터치를 지원하지 않는 안드로이드 3.0 미만의 브라우저에서는 배열의 크기가 항상 1이다. 속성 설명 touches 화면상의 모든 터치를 저장한 배열 targetTouches ouches 속성과 유사하나 같은 요소 내에서 시작된 터치에 대한 정보만 반환 changedTouches 이전 이벤트로부터 변경이 있는 터치 정보를 저장한 배열 touchend 이벤트에서는 changedTouches 속성값만 제공하며, touches 속성과 targetTouches 속성의 배열 크기는 항상 0으로 반환한다. 그래서 touchend 이벤트에서 터치 정보가 필요할 때 touches 속성과 targetTouches 속성의 정보는 사용할 수 없다. 배열에 저장된 객체는 Touch 타입의 객체며 마우스 이벤트와 거의 차이가 없다. 다음표는 Touch 객체의 속성을 정리한 표다. 속성 설명 indentfier 터치한 인식점을 구분하기 위한 인식점 번호 screenX 기기 화면을 기준으로 한 X 좌표 screenY 기기 화면을 기준으로 한 Y 좌표 clientX 브라우저 화면을 기준으로 한 X 좌표 clientY 브라우저 화면을 기준으로 한 Y 좌표 pageX 문서를 기준으로 한 X 좌표 pageY 문서를 기준으로 한 Y 좌표 target 터치된 DOM 객체 터치 이벤트 발생 순서 터치 이벤트는 touchstart 이벤트 -&gt; touchmove 이벤트(n개) -&gt; touchend 이벤트의 순서로 모든 브라우저에서 동일하게 발생한다. 그러나 클릭 이벤트와 스크롤 이벤트, 마우스 이벤트까지 고려한 발생순서는 브라우저마다 다르다. 예를들어 iOS용 사파리의 스크롤 이벤트는 터치 이벤트 완료후 발생하지만 안드로이드 브라우저의 스크롤 이벤트는 touchmove 이벤트와 교차해서 발생하거나 여러번 발생하기도 한다. 다음은 모바일 브라우저에서 이벤트 발생 순서를 정리한 표다. 동작 발생순서 터치 touchstart -&gt; touchend -&gt; mousemove -&gt; mousedown -&gt;mouseup -&gt; mouseover -&gt; click마우스 이벤트는 touchend 이벤트 이후에 발생된다. 수직방향이동 사파리 touchstart -&gt; touchmove(n개) -&gt; touchend -&gt;(mousemove -&gt; mousedown - &gt; mouseup ) -&gt; scroll(0~n개)scroll 이벤트는 마지막에 한 번 발생한다.마우스 이벤트는 touchend 이벤트 이후에 발생한다. 수직방향이동 안드로이드 touchstart -&gt; [touchmove -&gt; mousemove](n 개) -&gt;scroll(0n개) -&gt;touchend -&gt; (mousemove) -&gt; scroll(0n개)안드로이드 브라우저에서는 스크롤 이벤트가 여러 번 발생한다.mousemove 이벤트는 종종 touchend 이벤트 이후나touchmove 이벤트 중간에 나타난다. 수직방향이동 안드로이드 2.3(갤럭시 S, 갤럭시 S2)안드로이드 3.0 이상 touchstart -&gt; touchmove -&gt; scroll(0~n번)갤럭시 S와 갤럭시 S2의 안드로이드 2.3에서는iOS용 사파리와 같은 형태로 scroll 이벤트가 마지막에한 번만 나타난다.안드로이드 3.0부터는 touchend 이벤트가 발생하지 않는다. 수평방향이동 touchstart -&gt; [touchmove -&gt; mousemove](n개) -&gt;touchend -&gt; mousemove(n개)mousemove 이벤트는 종종 touchend 이벤트 이후나touchmove 이벤트 중간에 나타난다.touchstart -&gt; touchmove -&gt; scroll(0~n개)안드로이드 3.0 부터는 수평방향으로 이동해도 scroll 이벤트가발생하며, touchend 이벤트가 발생하지 않는다. 제스처 이벤트 제스처 이벤트는 터치 이벤트와 비슷하다. 그러나 터치 이벤트는 한 손가락을 움직일 때 발생하는 이벤트고, 제스처 이벤트는 두 손가락을 움직을 때 발생하는 이벤트다. 휴대촌에서 손가락 두 개로 사진을 확대하고 축소할 때 브라우저에서 발생하는 이벤트가 제스처 이벤트다. 제스처 이벤트 객체에서는 사용자의 손가락 움직임이 확대 또는 축소 중인지, 회전 중인지에 대한 정보를 얻을 수 있다. 제스처 이벤트에는 이벤트가 발생하는 시점에 따라 gersturestart 이벤트와 gersturechange 이벤트, gestuerend 이벤트로 세 종류의 이벤트가 있다. 터치 이벤트의 touchstart 이벤트, touchmove 이벤트, touchend 이벤트처럼 이벤트가 시작할 때, 손가락이 움직일 때, 이벤트가 끝났을 때 발생한다. 단, 이 이벤트는 iOS에서만 발생하고 안드로이드에서는 발생하지 않는다. 이벤트 이름 설명 gersturestart 화면에 두 손가락이 닿을 때 발생한다. gersturechange 화면에서 두 손가락이 움직일 때 발생한다. gestuerend 화면에서 두 손가락을 뗄 때 발생한다. 두 손가락을 사용할 때 발생하는 제스처 이벤트 객체의 속성에는 두 가지가 있다. 하나는 두 손가락을 벌리거나 좁혀서 요소를 확대 또는 축소할 때 나타나는 정보인 scale 속성이고, 또 다른 하나는 두 손가락으로 요소를 회전할 때 나타나는 정보인 rotation 속성이다. (제스처 이벤트 객체의 속성) 속성 설명 scale 두 손가락을 벌리거나 좁혀서 확대 또는 축소한 비율 rotation 두 손가락을 돌려서 회전한 각도 orientationcange 이벤트 모바일 환경에서는 기기의 회전 상태에 따라 화면의 방향이 가로나 세로로 변한다. 기기가 회전하면 화면의 발향이 가로에서 세로로, 또는 세로에서 가로로 바뀌고, 이때 orientationcange 이벤트가 발생한다. orientationcange 이벤트는 기기의 회전 상태에 따라 사용자에게 다른 UI를 보여주는 반응형 웹을 구현하는데 필요한 기능이다.orientationcange 이벤트를 지원하는 환경은 다음과 같다. 안드로이드 2.2 이상의 브라우저 iOS 3.2 이상의 사파리 orientationcange 이벤트가 발생하지 않는 하위 버전의 브라우저에서는 orientationcange 이벤트 대신 resize 이벤트를 이용해 모바일 기기의 회전 상태를 파악할 수 있다. 운영체제별 orientationcange 이벤트 특징 orientationcange 이벤트는 운영체제가 기기마다 다르게 동작한다. 이는 운영체제의 오류이거나 기기의 특성 때문인 경우가 대부분이다. 특히, 제조사가 다양한 안드로이드 기반의 기기에서는 그 차이가 더욱 크다.이러한 차이는 모든 운영체제와 기기에서 회전 상태를 정상적으로 인식하고 동작하는 기능을 구현하려면 꼭 알아야 할 사항이다. iOS에서 orientationcange 이벤트 iOS에서는 orientationcange 이벤트의 동작에 오류가 매우 적어 기기의 회전 상태를 확인하는데 매우 유용하다. 다만 iOS의 버전에 따라 resize 이벤트와 scroll 이벤트, orientationcange 이벤트의 발생 순서가 달라 이벤트에 따라 동작하는 기능을 구현할 때 주의해야 한다. iOS의 각 버전별로 이벤트가 발생하는 순서는 다음과 같다. 버전 이벤트 발생 순서 6.x5.x orientationcange -&gt; resize -&gt; scroll 4.x3.x resize -&gt; orientationcange -&gt; scroll 안드로이드에서 orientationcange 이벤트 안드로이드에서 orientationcange 이벤트는 운영체제의 버전과 제품에 따라 다르게 동작한다. 그러나 다음과 같은 공통점이 있다. 버전에 상관없이 삼성에서 제조한 기기에서는 orientationcange 이벤트가 발생해도 window.innerHeight 속성값과 window.innerWidth 속성값은 회전하기 전의 값이다.안드로이드 4.0 이상을 사용하는 삼성계열 이외의 기기에서는 orientationcange 이벤트가 발생했을 때 window.innerHeight 속성값과 window.innerWidth 속성값은 회전하기 후의 값이 된다. 안드로이드 2.3부터는 기본 브라우저에서 모두 orientationcange 이벤트 -&gt; resize 이벤트 순서로 이벤트가 발생한다. 다음 표는 안드로이드 버전과 제품에 따른 orientationcange 이벤트의 특징이다. 버전 제품 이벤트 발생 순서와 특징 4.0 갤럭시 S3 LTE갤럭시 S3갤럭시 S2갤럭시 S갤럭시 노트옵티머스 LTE orientationcange -&gt; resizeorientationcange 이벤트가 발생할 때 window.innerHeight 속성과window.innerWidth 속성은 회전하기 전의 상태 값을 반환이다. 3.0 갤럭시Tab2 orientationcange -&gt; resizeorientationcange 이벤트가 발생할 때 window.innerHeight 속성과window.innerWidth 속성은 회전하기 전의 상태 값을 반환이다. 2.3 갤럭시 S2갤럭시 S갤럭시 노트 orientationcange -&gt; resizeorientationcange 이벤트가 발생할 때 window.innerHeight 속성과window.innerWidth 속성은 회전하기 전의 상태 값을 반환이다. 2.2 갤럭시 S갤럭시 K orientationcange -&gt; resize -&gt; orientationcange첫번 째 orientationcange 이벤트가 발생할 때 window.innerHeight 속성과window.innerWidth 속성은 회전하기 전의 상태 값을 반환이다.두번 째 orientationcange 이벤트가 발생할 때는 회전한 후의 상태값을 반환한다. 2.2 옵티머스 2X베가X orientationcange -&gt; resizeorientationcange 이벤트가 발생할 때 window.innerHeight 속성과window.innerWidth 속성은 회전하기 전의 상태 값을 반환이다. 갤럭시 탭 orientationcange -&gt; orientationcange -&gt;orientationcange -&gt; orientationcange첫 번째와 두 번째, 세 번째로 orientationcange 이벤트가 발생할 때는window.innerHeight 속성과 window.innerWidth 속성이 회전하기 전의상태 값을 반환한다.네 번째 orientationcange 이벤트가 발생할 때는 회전한 후의 상태 값을 반환한다. devicemotion 이벤트 devicemotion 이벤트는 모바일 기기가 움직이거나 회전할 때 발생하는 이벤트로, 움직일 떄의 가속도와 회전 각도에 대한 정보를 제공한다. devicemotion 이벤트를 이용하면 기기를 움직여서 동작하는 게임이나 수평계 등을 제작할 수 있다. 속성 이름 설명 acceleration 중력을 제거한 가속도 정보사용자가 모바일 기기를 움직일 때만 속성값에 변화가 생긴다. accelerationIncludingGravity 중력을 포함한 가속도 정보.모바일 기기를 가만히 뒤도 속성값에 변화가 생긴다. interval devicemotion 이벤트가 발생하는 시간의 간격(ms) rotationRate X축, Y축, Z축을 기준으로 한 모바일 기기의 회전 속도 devicemotion 이벤트는 이벤트가 발생할 때 모바일 기기를 움직이는 속도와 회전한 정도를 속성값으로 전달한다. devicemotion 이벤트의 속성은 읽기 전용이라 값을 확인만 할 수 있고 값을 설정할 수 는 없다.","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Javascript","slug":"Frontend/Javascript","permalink":"https://woonyzzang.github.com/categories/Frontend/Javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://woonyzzang.github.com/tags/js/"},{"name":"mobile","slug":"mobile","permalink":"https://woonyzzang.github.com/tags/mobile/"}]},{"title":"Javascript Mobile Event Step","slug":"javascript-mobile-event-step","date":"2017-05-15T09:40:25.000Z","updated":"2024-06-10T04:53:59.569Z","comments":true,"path":"2017/05/15/javascript-mobile-event-step/","permalink":"https://woonyzzang.github.com/2017/05/15/javascript-mobile-event-step/","excerpt":"","text":"JavaScript 모바일 이벤트 발생 순서프론트엔드 개발에서 이벤트 발생 순서를 이해하고 개발하는 것은 굉장히 중요하다. 특히 운영체제와 제조사별로 조금씩 다르게 처리되는 모바일에서는 더욱 중요하다. 여기서는 일반적인 이벤트 발생 순서를 알아본다. 선택이벤트(touch, scroll, mouse, click) touch 이벤트와 scroll 이벤트, mouse 이벤트, click 이벤트는 사용자가 대상을 선택하고, 이동하고, 선택을 해지 했을 때 발생하는 이벤트다. 이 이벤트는 iOS와 안드로이드에서 다르게 작동한다. 오른쪽 iOS에서 touchstart 이벤트부터 click 이벤트가 발생하는 순서를 나타내는 그림이다. iOS에서 선택 이벤트의 발생순서 123456789101112131415[touchstart]↓&lt; 스크롤은 하는가? &gt;↓[touchmove]↓&lt; 손을 뗏는가? &gt;↓[touchend]↓&lt; 스크롤 했는가? &gt;↓[scroll](예)↓[click](아니오) touchstart 이벤트가 발생한 다음 스크롤이 있으면 스크롤하는 동안 touchmove 이벤트가 발생한다. 터치를 마치고 touchend 이벤트가 발생하면 스크롤이 있었을 경우 scroll 이벤트가 발생한 다음 click 이벤트가 발생한다. 스크롤이 없었다면 touchend 이벤트 발생 이후 바로 click 이벤트가 발생한다. 다음은 안드로이드에서 touchstart 이벤트부터 click 이벤트가 발생하는 순서를 나타낸 그림이다. 안드로이드에서 선택 이벤트의 발생순서 12345678910111213[touchstart]↓&lt; 스크롤은 하는가? &gt;↓[touchmove]↓[scroll]↓&lt; 손을 뗏는가? &gt;↓[touchend]↓[click] touchstart 이벤트가 발생한 다음 스크롤이 있으면 스크롤하는 동안 touchmove 이벤트와 scroll 이벤트가 발생한다. 터치를 마치면 touchend 이벤트와 click 이벤트가 발생한다. 폼 요소 선택 이벤트(touch, focus) 사용자가 폼 요소를 선택했을 때 발생하는 이벤트다. 이벤트는 iOS와 안드로이드에서 다르게 작동한다. 아쪽은 iOS에서 touchstart 이벤트부터 focus 이벤트가 발생하는 순서를 나타낸 그림이다. 폼 요소를 눌렀다 떼면 touchstart 이벤트와 touchend 이벤트가 발생한다. 폼 요소를 처음 눌렀다면 focus 이벤트가 발생한다. 폼 요소를 처음 눌렀다면 focus 이벤트가 발생하고 소프트 키보드가 나타난다. iOS에서는 소프트 키보드가 나타나면 scroll 이벤트도 발생한다. **iOS에서 폼 요소 선택 이벤트의 발생 순서 ** 12345678910111213( 시작 )↓[touchstart]↓[touchend]↓&lt; 처음 선택했는가? &gt; - 아니오 → ( 종료 )|예↓[focus]↓[소프트 키보다가 보이면서 scroll] 다음은 안드로이드에서 touchstart 이벤트부터 focus 이벤트가 발생하는 순서를 나타낸 그림이다. 안드로이드에서 폼 요소 선택 이벤트의 발생 순서 1234567891011( 시작 )↓&lt; 처음 선택했는가? &gt; - 아니오 → ( 종료 )↓[touchstart]↓[touchend]↓[focus]↓[focus] 폼 요소를 처음 눌렀다 떼면 touchstart 이벤트, touchend 이벤트, focus 이벤트 순서로 이벤트가 발생한다. 한 가지 주의할 점은 안드로이드에서는 버전에 따라 입력상자(input, textarea)에서 focus 이벤트가 두 번 발생하는 오류가 있다는 것이다. 모바일 환경에서는 브라우저의 종류, 운용체제의 버전, 제조사, 모바일 기기의 종류에 따라 이벤트가 다르게 작동한다. 이러한 동작 유형을 정확히 파악하고 있어야 다양한 운영체제와 기기에서 동일한 기능과 동일한 인터페이스를 제공할 수 있다.","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Javascript","slug":"Frontend/Javascript","permalink":"https://woonyzzang.github.com/categories/Frontend/Javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://woonyzzang.github.com/tags/js/"},{"name":"mobile","slug":"mobile","permalink":"https://woonyzzang.github.com/tags/mobile/"}]},{"title":"Javascript Mobile Browser Event","slug":"javascript-mobile-browser-event","date":"2017-05-15T09:06:22.000Z","updated":"2024-06-10T04:53:59.568Z","comments":true,"path":"2017/05/15/javascript-mobile-browser-event/","permalink":"https://woonyzzang.github.com/2017/05/15/javascript-mobile-browser-event/","excerpt":"","text":"JavaScript 모바일 브라우저 이벤트모바일 환경의 사용자 인터페이스는 데스크톱 환경의 사용자 인터페이스와 다르다. 예를 들어, 모바일 기기에서는 데스크톱 PC의 키보드와 마우스 대신 소프트 키보드와 터치 액션을 제공한다. 그뿐만 아니라 데스크톱에서 지원하지 못하는 다양한 기기 정보를 제공한다. 이러한 차이점으로 모바일 브라우저는 데스크톱과 다른 별도의 이벤트를 제공하면서 데스크톱의 이벤트도 함께 제공한다.데스크톱에서 발생하는 이벤트라도 모바일 브라우저에서는 이벤트 발생 순서, 발생하는 요소, 발생 빈도가 다르기 때문에 그 차이점을 분명히 알아야 한다. 예를 들면, focus 이벤트와 blur 이벤트는 모바일 브라우저에서는 폼 요소에서만 발생하기 때문에 링크나 다른 요소에서는 사용할 수 없다. 모바일 브라우저 전용 이벤트 모바일 브라우저에서는 터치 사용자 인터페이스에서 발생하는 이벤트와 회전과 같이 기기의 상태에 따라 발생하는 이벤트가 추가로 지원된다. 추가로 지원되는 이벤트는 다음과 같다. 이벤트 설명 특징 터치 이벤트 스크린에 손가락을터치했을때 발생한다.ouchstart 이벤트,touchmove 이벤트,touchend 이벤트,touchcancel 이벤트가 발생한다. 안드로이드 2.1에서는 오류가 있다.마우스 이벤트보다 먼저 발생한다. 제스처 이벤트 스크린에 손가락을 2개 이상터치했을 때 발생한다.gesturestart 이벤트,gesturemove 이벤트,gestureend 이벤트가 발생한다. 안드로이드 3.0 이상과 iOS에서 지원한다. orientationchange 이벤트 기기가 회전할 때 발생한다. 안드로이드 2.0의 기본 브라우저부터지원하다. devicemotion 기기의 기월기와 가속도를알아낼 수 있다. 데스크톱 브라우저와 다르게 동작하는 이벤트 데스크톱 브라우저와 모바일 브라우저에서 공통적으로 발생하지만 동작 방식이나 순서가 다른 이벤트가 있다. 예를 들어, focus 이벤트와 blur 이벤트는 모바일 브라우저에서는 폼 요소에서만 발생한다. 그리고 mousewheel 이벤트는 iOS용 사파리에서만 발생한다. 또한 resize 이벤트는 모바일 브라우저의 주소창이 움직일 때 발생하기도 한다. [데스크톱 브라우저와 모바일 브라우저에서 다르게 발생하는] 이벤트 데스크톱 브라우저 특징 모바일 브라우저 특정 click 마우스를 눌렀다가뗄 때 발생 터치 이벤트와 마우스 이벤트 발생 이후에마지막에 발생한다.click 이벤트에 핸들러를 사용하면 체감 반응이 늦다.click 이벤트가 발생할 때 하이라이트가 발생한다. focus 객체에 포커스가들어올 때 발생 폼 요소에서만 발생한다.안드로이드 브라우저의 버전에 따라 2번씩발생하는 오류가 있다. blur 객체에서 포터스가나갈 때 발생 폼 요소에서만 발생한다.안드로이드 브라우저의 버전에 따라 2번씩발생하는 오류가 있다. scroll 사용자가 객체의 스크롤막대를 움직일 때 발생 사용자가 손가락으로 모바일 기기의 화면을스크롤할 때 발생한다.scrollBy() 메서드나 scrollTo() 메서드로호출할 때는 브라우저에 따라 발생하지 않을 수 있다. resize 객체의 크기가바뀔 때 발생 주소창이 보이거나 소프트 키보드가 보일 때,또는 모바일 기기가 회전했을 때 이벤트가 발생한다.모바일 브라우저에 따라 다양하게 발생한다. keydown 키보드 키를눌렀을 때 발생 모바일 브라우저엣 따라 한들을 입력할 때 keyCode 값이모두 0으로 출력되거나 이벤트가 발생하지 않기도 한다. keyup 눌렀던 키보드를뗄 때 발생 모바일 브라우저엣 따라 한들을 입력할 때 keyCode 값이모두 0으로 출력되거나 이벤트가 발생하지 않기도 한다. keypress 기능 키를 제외한키보드를 눌렀을 때 발생 모바일 브라우저에 따라 keydown 이벤트와keyup 이벤트의 keyCode 값이 다르게 나온다. mousewheel 마우스 휠을돌릴 때 발생 iOS용 사파리에서만 발생한다.overflow 속성이 scroll로 적용된 요소에서멀티 터치할 때 발생한다. 그 밖에 다음의 이벤트는 데스크톱 브라우저에서만 발생하고 모바일 브라우저에서는 발생 하지 않는 이벤트 이다. dbclick 이벤트 contextmenu 이벤트 cut 이벤트 paste 이벤트 copy 이벤트","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Javascript","slug":"Frontend/Javascript","permalink":"https://woonyzzang.github.com/categories/Frontend/Javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://woonyzzang.github.com/tags/js/"},{"name":"mobile","slug":"mobile","permalink":"https://woonyzzang.github.com/tags/mobile/"}]},{"title":"Mobile Web의 특징","slug":"mobile-web","date":"2017-05-14T15:49:40.000Z","updated":"2024-06-07T09:27:28.345Z","comments":true,"path":"2017/05/15/mobile-web/","permalink":"https://woonyzzang.github.com/2017/05/15/mobile-web/","excerpt":"","text":"많은 브라우저 환경초창기 웹에서는 표준이 거의 존재하지 않았다. 물론 W3C에 의해 1994년 10월부터 웹 표준이 개발되고 있었지만 당시에는 각 개발사가 브라우저를 임의로 만들고 있었다. 그래서 인터넷 익스플로러에 맞게 개발한 웹 페이지가 파이어폭스나 오페라에서 정상적으로 동작하지 않는 일이 비일비재했다. 이떄 플랫폼은 단일 플랫폼인 웹이지만 개발자는 서비스를 브라우저별로 따로 구현해야 했다.초창기 웹에 비해 웹표준이 지켜지고는 있지만 이러한 문제는 이제 태동기인 모바일 웹에서도 비슷하게 있다. 초창기 PC 에서 웹 브라우저가 웹 표준을 지키지 않아서 문제였다면, 모바일 웹에서는 웹 브라우저가 웹 표준을 미처 구현하지 못해서 문제가 발생한다. 또한 브라우저의 종류와 버전 때문에, 제조사가 기기에 맞춰 수정한 브라우저 차이 때문에, 앱에서 사용하는 웹뷰와 기본 브라우저 사이의 차이 때문에 브라우저 파편화(fragmentaion)가 발생한다. 다음은 브라우저와 기기, 실행 환경에 따른 다양한 모바일 환경을 정리한 표다. 브라우저 환경 구분 비고 iOS용 사파리 3.x, 4.x, 5.x, 6.x, 7.x 안드로이드 브라우저 2.x, 3.x, 4.x 기타 크롬, 파이어폭스, 모바일 오페라 등 모바일 기기 구분 비고 애플 아이팟 터치,아이폰 3GS,아이폰 4, 아이폰 4s,아이폰 5, 아이폰 5c, 아이폰 5s,아이패드, 아이패드 2, 아이패드 3, 아이패드 미니 등 안드로이드용 모바일 기기제조사(삼성,LG, 팬텍 등) 삼성, LG, 베가 안드로이드 폰 등갤럭시 S2, 갤럭시 S3, 갤럭시 S4,옵티머스, 옵티머스Z, 옵티머스Q 베가 등각 제조사별 다양한 제품 보유 실행환경 구분 비고 기본 브라우저 모바일 기기에서 제공하는 기본 브라우저, iOS용 사파리, 안드로이드 브라우저 등 하이브리드앱 네이티브 앱의 웹뷰(WebView) 주로 사용하는 iOS와 안드로이드를 기분으로 정리했는데도 경우의 수가 무수히 많다. 대략 다음과 같은 경우로 나눌 수 있으며, 산술적으로 n4에 해당할 정도로 많은 파편화가 발생할 수 있다. (모바일 웹에서 파편화가 발생할 수 있는 경우의 수)브라우저의 종류 || 브라우저의 버전 || 모바일 기기 || 실행 환경초창기 모바일 웹에서는 정말로 위와 같이 브라우저 종류와 버전에 따라, 기기의 종류에 따라 다양한 문제가 발생했지만 현재는 많이 안정화 됐다. 예를 들어, position:fixed 속성은 안드로이드 2의 기본 브라우저와 안드로이드 3의 기본 브라우저가 지원은 하지만 화면이 깜빡이는 기기도 있었고, 스크롤 이후에 다시 배치되는 경우도 있었다. 반면 하이브리드앱의 웹뷰에서는 정상으로 동작하는 경우도 있었다. 그래서 개발자가 position:fixed 속성을 사용할 때는 운영체제 종류, 버전, 기기 종유에 따라 position:fixed를 사용할 수 있는 경우와 사용할 수 없는 경우를 별도로 구현해야 했다. 하지만 다행이도 운영체제와 브라우저의 버전이 높아질수록, 새로운 기기가 출시 될수록 파편화가 점차 없어지고 있다. 젤리빈(안드로이드 4.1)부터 이러한 파편화가 거의 없어졌고, iOS는 운영체제 개발 회사와 기기 제조 회사가 동일하다 보니 브라우저의 버전별 이슈를 제외하고는 거의 문제가 없다. 물론 운영체제나 실행 환경, 기기에 따른 성능 차이는 여전히 있다. 기기별 다양한 해상도일반적으로는 PC 기반의 웹페이지는 1024 x 768px 또는 1280 x 1024px 등과 같이 고정된 해상도에 최적화되도록 구성한다. 하지만 모바일에서는 480 x 320px 이나 960 x 640px 등과 같이 기기마다 해상도가 다르기 때문에 모바일 웹을 개발할 때는 더 다양한 해상도를 고려해야 한다. 다음은 스마트폰 및 태블릿 PC의 새상도를 정리한 내용이다. 기종 해상도(가로 x 세로, 단위:px) 아이폰 3GS 320 x 480 아이폰 4, 아이폰 4s 640 x 960 아이폰 5, 아이폰 5c, 아이폰 5s 640 x 1136 아이패드, 아이패드 2, 아이패드 미니 768 x 1024 아이패드 3세대, 아이패드 4세대, 아이패드 미니 2 1536 x 2048 갤럭시 S, 갤럭시 S2, 갤럭시 S2 HD,옵티머스, 옵티머스Z, 옵티머스Q, 옵티머스 빅, 옵티머스 2X,베가, 디자이어HD, 넥서스원 480 x 800 갤럭시탭 600 x 1024 옵티머스 뷰 768 x 1024 갤럭시 S3, 갤럭시 S2 HD, 갤럭시 노트2, 옵티머스G 720 x 1280 갤럭시 S4, 갤럭시 노트3, G2, 옵티머스 Pro 1080 x 1920 넥서스 7 1200 x 1920 다양한 해상도에 대응하는 방법은 크게 두 가지로 볼수 있다. 하나는 CSS3의 미디어 쿼리(media query)를 이용해 브라우저의 크기에 사이트를 맞추는 방법이다. 다른 하나는 모바일 기기의 폭에 사이트를 맞추는 방법이다. 모바일 기기의 폭에 사이트를 맞추는 방법은 HTML의 태그에 viewport 속성을 설정하는 것이다. 일반적으로 모바일 앱과 같은 느낌을 주려고 웹 페이지를 확대하거나 축소하는 기능은 사용하지 않고, 모바일 기기의 폭에 해상도를 맞춘다. 네트워크국내에서는 Wi-Fi나 4G, 4G LTE 등 네트워크 속도가 빠른 서비스를 제공하느 ㄴ곳이 많지만, 여전히 PC에 비해 네트워크 속도가 느리다. 특히 3G 환경은 다른 통신 환경에 비해 네트워크 속도가 느리기 때문에 이런 점을 고려하지 않고 개발하면 성능과 관련된 문제가 많이 생길 수 있다. 속도가 보장된다고 해도 Wi-Fi를 사용할 수 없는 환경에서는 네트워크를 사용하는 것 자체가 사용자에게는 비용이 된다. 따라서 서버로부터 실시간으로 데이터를 주기적으로 가져오는 기능과 같은 것은 설계 단계에서부터 신중히 검토해야 한다. 한정된 전원모바일 웹은 휴대가 간편한기기에서 실행되기 때문에 PC와 다르게 기기에 전원이 계속 공급되지 않는다. 따라서 모바일 웹을 개발할 때는 전력 소모량도 고려해야 한다. 전력 소모가 심한 하드웨어 가속, 주기적인 요청등을 무분별하게 사용해서는 안된다.","categories":[{"name":"Web","slug":"Web","permalink":"https://woonyzzang.github.com/categories/Web/"},{"name":"Mobile","slug":"Web/Mobile","permalink":"https://woonyzzang.github.com/categories/Web/Mobile/"}],"tags":[{"name":"mobile","slug":"mobile","permalink":"https://woonyzzang.github.com/tags/mobile/"}]},{"title":"Mobile Web App 개발","slug":"mobile-web-app","date":"2017-05-14T15:17:09.000Z","updated":"2024-06-07T09:27:28.343Z","comments":true,"path":"2017/05/15/mobile-web-app/","permalink":"https://woonyzzang.github.com/2017/05/15/mobile-web-app/","excerpt":"","text":"모바일 웹과 모바일 앱‘모바일’은 ‘이동하는’ 또는 ‘움직임이 자유로운’ 이라는 뜻으로, 사무실이나 집에서만 사용할 수 있는 기기와 달리 이동하면서 사용할 수 있는 스마트폰, 태블릿 PC 등을 말한다.모바일 웹은 이러한 모바일 범주에 속하는 기기에 최적화된 웹을 말한다. 모바일 앱도 모바일 범주에 속하는 기기에 최적화된 앱을 말한다. 여기서 앱은 운영체제 혹은 플랫폼에서 제공하는 SDK(software development kit)를 기반으로 개발된 애플리케이션을 지칭하는 용어다. 즉, 브라우저에서 동작하는 서비스와 달른 별도의 애플리케이션으로 구성된 모바일 서비스를 지칭한다.모바일 웹과 모바일 앱은 서비스나 콘텐츠를 제공한다는 역활은 같지만 동작하는 플랫폼과 구현방식에 따라 구분된다. 이러한 기술적인 차이 때문에 서비스나 콘텐츠의 용도에 따라 모바일 웹으로 개발할 것인지 모바일 앱으로 개발할 것인지 나뉜다. 모바일 웹과 모바일 앱의 특징모바일 웹은 브라우저에서 동작하는 서비스라서 사용자는 URL 정보만 알면 사용할 수 있다. 또 한 웹표준에 맞게 개발하면 다양한 플랫폼에서 동작하기 때문에 개발 생산성이 높고 유지보수하기 쉽다.반면 모바일 앱은 운영체제 또는 플랫폼에 따라 각기 다르게 개발해야 하기 때문에 개발 생산성이 낮고 유지보수하기 어렵다. 또한 플랫폼에 따라 각기 다른 앱 스토어에서 다운로드해야 하기 때문에 배포와 설치가 쉽지 않다. 물론 모바일 웹에 비해 뛰어난 성능과 모바일 기기의 하드웨어를 제어할 수 있다는 점은 모바일 앱의 가장 큰 장점이다. 다음은 모바일 웹과 모바일 앱의 특징을 비교한 내용이다. 비교 항목 모바일 웹 설치 방식 설치단계 없음(브라우저 접속) 배포 방식 배포단계 없음(브라우저 접속) 구현 방식 웹 표준에 맞게 단일 개발 주요 서비스 블로그, 뉴스와 같은 콘텐츠 중심의 서비스 장점 플랫폼에 상관없이 개발할 수 있기 때문에 개발 생산성이 높고 유지보수하기 쉽다.설치 및 배포가 쉽다. 단점 웹에 비해 실행 속도가 느리다.모바일 기기의 하드웨어를 제어하기 어렵다. 비교 항목 모바일 앱 설치 방식 앱 스토어에서 바이너리 파일을 모바일 기기에 다운로드해서 설치해야 한다. 배포 방식 완성된 바이너리 파일을 앱 스토어의 배포 절차에 따라 진행한다. 구현 방식 모바일 기기의 운영체제 또는 플랫폼에 따라 다르게 개발해야 한다. 주요 서비스 게임, 음악 등 높은 하드웨어 성능과 하드웨어 제어가 필요한 서비스 장점 빠른 구동 속도와 함께 특정 플랫폼에서 제공되는 다양한 API에 대한활용 가능 수준이 높아짐에 따라 다양한 기능들을 구현 가능할 수 있다. 단점 플랫폼이나 기기에 따라 별도로 개발해야 하기 때문에 개발 생산성이 낮다유지보수하기 어렵다.배포 및 설치가 불편하다. 모바일 웹과 모바일 앱 모두 장단점이 있다. 모바일 웹의 성능과 하드웨어 제어에 한계가 있고, 모바일 앱은 크로스 플랫폼에 대응하기 위한 개발 비용이 높고 배포와 설치가 어렵다. 하지만 지금도 계속 이러한 기술적인 문제를 해결하기 위해 많은 사람들이 연구하고 있다. API 이름 설명 Battery Status 기기의 배터리 정보에 접근하기 위한 API Calendal 기기의 일정 정보에 접근하기 위한 API Contacts 기기의 주소록 정보에 접근하기 위한 API Media Capture 기기의 오디오, 이미지, 비디오 기능에 접근하기 위한 API HTML Media Capture HTML 폼(form)으로 기기의 마이크와 카메라에 접근하고오디오 파일과 사진 파일을 업로드하는 기능을 제공하는 API Messaging 기기의 SMS, MMS, 메일 기능에 접근하기 위한 API System Information 기기의 기본적인 속성(배터리 용량, 네트워크 대역폭,CPU 부하, 저장 용량, 입출력 기기)에 대한 정보를 얻는 API Gallery 기기에 있는 미디어 갤러리에 접근하는 API 2014년까지 API 작업을 완료하는 것을 목표로 진행하고 있기 때문에 늦어도 2015년 3분기 정도면 브라우저에서도 하드웨어를 제어할 수 있을 것이다.","categories":[{"name":"Web","slug":"Web","permalink":"https://woonyzzang.github.com/categories/Web/"},{"name":"Mobile","slug":"Web/Mobile","permalink":"https://woonyzzang.github.com/categories/Web/Mobile/"}],"tags":[{"name":"mobile","slug":"mobile","permalink":"https://woonyzzang.github.com/tags/mobile/"}]},{"title":"Javascript Event Bubbling 및 capture","slug":"javascript-event-bubbling-capture","date":"2017-05-14T15:09:11.000Z","updated":"2024-06-10T04:53:59.559Z","comments":true,"path":"2017/05/15/javascript-event-bubbling-capture/","permalink":"https://woonyzzang.github.com/2017/05/15/javascript-event-bubbling-capture/","excerpt":"","text":"JavaScript 이벤트 버블링과 이벤트 캡처링 차이컵에 들어 있는 탄산음료(사이다 같은)의 기포가 아래에서 위로 올라가는 것과 같이 DOM의 자식 요소로부터 부모 요소로 올라오며 이벤트 핸들러가 실행되는 것을 이벤트 버블링이라고 한다.반대로 DOM의 부모 요소에서 발생한 이벤트가 자식 요소로 내려가며 이벤트 핸들러가 실행되는 것을 이벤트 캡처링이라 한다. 다음 코드와 같이 구성된 HTML에서 이벤트 버블링일 경우에는 IMG 요소에 이벤트가 발생한 후 A 요소에 이벤트가 발생한다. 반명 이벤트 캡처링일 경우에는 A 요소에 이벤트가 발생하고 IMG 요소에 이벤트가 발생한다. 12345&lt;a&gt; &lt;img&gt; &lt;span&gt; ...&lt;/a&gt;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Javascript","slug":"Frontend/Javascript","permalink":"https://woonyzzang.github.com/categories/Frontend/Javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://woonyzzang.github.com/tags/js/"}]},{"title":"SublimeText Packages","slug":"sublimetext-packages","date":"2017-05-14T14:18:00.000Z","updated":"2024-06-07T09:27:28.376Z","comments":true,"path":"2017/05/14/sublimetext-packages/","permalink":"https://woonyzzang.github.com/2017/05/14/sublimetext-packages/","excerpt":"","text":"Sublime Text 패키지 활용서브라임 텍스트에 패키지들를 활용 하려면 패키지 컨트롤이 미리 설치 되어 있어야 한다. 패키지 컨트롤이 설치 안되어 있다면 아래 링크의 내용을 참조하면 된다.서브라임 패키지 컨트롤 설치 방법 Emmet 에멧(Emmet)은 간단한 글자 입력으로 복잡한 코드를 완성할 수 있는 플러그인 이다. 이전의 젠 코딩(Zen Coding)이었던 것이 Emmet으로 이름이 바뀌면서 기능도 더 좋아졌다. FTPSync(FTP 연결하기) 기본적으로 서브라임 텍스트에는 호스팅 서버와 연결해 작업할 수 있는 환경이 구비되어 있지 않다. 하지만 관련 플러그인을 설치하고 설정만 해주면 서버와 연결해서 작업 할 수 있다. FTP의 경우 무료 플러그인이 있고 SFTP는 유료 플러그인이 있다. SideBarEnhancements(사이드바 기능 향상) 기본적으로 서브라임 텍스트에는 사이드바의 폴더나 파일을 대상으로 마우스 오른쪽 버튼을 클릭했을 때 나오는 메뉴가 별로 없다. Sidebar로 검색하면 처음에 나타나고, 설치하면 바로 사용할 수 있다. Color Picker(컬러 피커) 패키지 설치에서 Color Picker로 검색해 설치한 후 CSS 파일을 열고 Ctrl + Shift + C 를 누르면 컬러피커가 나타난다. 컬러피커는 CSS 파일뿐 아니라 다른 파일에서도 열린다. 이미 컬러 피커가 열린 상태에서는 서브라임 텍스트에서 파일을 열거나 클릭할 수 없으므로 색상 코드를 입력할 곳을 미리 지정한 다음 열어야 한다. Minifier(축약 코드) 파일의 용량을 줄이기 위해 코드의 공백을 모두 제거하고 한줄로 만드는 패키지 이다.메뉴에서 Toos Minifier를 선택하면 축약형으로 변경 가능 하다. 자바스크립트에서도 사용할 수 있고 용량이 큰 경우 다소 시간이 걸리기도 한다. Minifier의 반대 기능을 하는 패키지는 Prettify 이다. HTML&#x2F;CSS&#x2F;JS Prettify 패키지 설치에서 위 제목과 같은 검색어로 검색한 후 설치한다.이전에 Minifier로 축약한 파일을 대상으로 Ctrl + Shift + H 를 누르면 예쁘게(Prettify) 볼수 있게 코드가 바뀐다. BracketHighlighter 기본적으로 서브라임 텍스트에서는 서로 일치하는 태그나 따옴표, 괄호를 구분하기가 어렵다. 하지만 BracketHighlighter 패키지를 설치하면 이를 쉽게 구분할 수 있다. AutoPrefix CSS3 속성은 아직 웹 표준으로 승인되지 않은 것이 많아서 브라우저별 접두어를 붙여서 사용해야 하는데 모든 브라우저의 접두어를 일일이 복사해 사용하기는 번거롭다. AutoPrefix 패키지는 바로 이러한 문제를 해결해 준다. Canluse 패키지 설치에서 CanIuse로 검색해서 설치하면 사용법과 단축키가 나온다. CSS 속성에 커서를 배치한 다음 단축키인 Ctrl + Alt + F 를 누르면 웹 브라우저에서 아래의 사이트로 이동하며 웹표준이 현재 어떤 상태인지 알 수 있다. CSSComb CSSComb는 스타일시트를 보기 좋게 정리해주는 패키지 이다.패키지 설치에서 CSSComb으로 검색해 설치하고 스타일시트 화면에서 Ctrl + Shift + C 를 누르면 자동으로 정리(스타일 순서)해 준다. 그룹이나 팀 단위로 프로젝트를 진행할 시 활용할 만한 패키지이다. Sublime Alignment Sublime Alignment는 코드를 &#x3D; 기호나 : 기호를 기준으로 보기 좋게 좌우로 나누어 정렬해주는 패키지 이다.패키지 설치에서 Sublime Alignment으로 검색해 설치한 후 정리하고자 하는 코드를 블록으로 설정한 다음 Ctrl + Alt + A(맥에서는 Cmd + Ctrl + A)를 누르면 코드가 정리되며, CSS의 경우 세미클론을 기준으로 좌우로 정렬된다. 1&#123;&quot;keys&quot;: [&quot;ctrl+alt+a&quot;], &quot;command&quot;: &quot;alignment&quot;&#125; 이 패키지는 별도의 메뉴를 제공하지 않아 단축키를 사용해야 하는데 다양한 패키지를 설치해서 사용하다 보면 단축키가 중복될 가능성도 있으므로 패키지가 작동하지 않을 경우 사용자 키 바인딩 파일을 열고 위 코드를 추가한 다음 편집기를 재시작해야 한다. Trimmer불필요한 공백을(Trailing Whitespace)를 제거하는 패키지 이다.패키지 설치에서 Trimmer로 검색해 설치하고 줄 끝에 공백이 있는 경우 Ctrl + Alt + S(맥에서는 Ctrl + S)를 누르면 줄 끝 공백이 제거된다. 마찬가지로 단축키가 중복될 경우 아래의 코드를 사용자 키 바인딩에 추가해야 한다. 1&#123;&quot;keys&quot;: [&quot;ctrl+alt+s&quot;], &quot;command&quot;: &quot;trimmer&quot;&#125; 이러한 패키지별 단축키는 메뉴에서 Preferences -&gt; Package Settings 에 설치된 패키지 목록이 있으니 해당 패키지에 마우스를 올리고 Key Bindings - Default를 선택하면 나타난다. HyperlinkHelper 도메인에 URL 링크를 자동으로 만들어주는 패키지 이다.도메인과 도메인 접미어를 입력한 뒤 Ctrl + Shift + Alt + L(맥에서는 Cmd + Shift + Ctrl + L)을 누르면 잠시 후에 a 태그와 href, title 속성이 자동으로 만들어진다. href와 title은 구글 검색을 통해 채워지기 때문에 해당 URL이 구글 검색 엔진에 등록된 상태여야 한다. Fetch(파일 가져오기) 파일이나 압축 파일을 가져와 원하는 폴더에 설치할 수 있는 패키지 이다. 패키지 설치에서 Fetch로 검색하면 Nettus + fetch가 나타난다. 이 패키지를 선택하고 엔터 키를 눌러 설치한Ctrl + Shift + P를 눌러서 커맨트 팔레트에서 fetch로 검색한 후 Fetch: Manage를 선택하고 엔터 키를 누르면 Fetch 설정 파일이 열린다. SublimeLinter SublimeLinter 패키지는 코드 작성 시 에러를 즉시 감지해서 알려주는 패키지 이다. 서브라임 텍스트3에서는 API가 달라지면서 서브라임 텍스트2와 달리 사용 언어별로 플러그인을 별로도 설치해야 한다. PackageResourceViwer( 패키지 리소스 보기) 서브라임 텍스트 3의 패키지는 압축돼 있는 경우가 많아서 파일 내용을 보거나 편집 할 수가 없는데, 이 플러그인을 설치하면 파일 내용을 보거나 편집할 수 있다. 서브라임 텍스트에서 커맨드 라인 열기 먼제 패키지 설치에서 Terminal로 검색해 설치한 다음 편집기에서 파일을 열고 Ctrl + Shift + T(맥에서는 Cmd + Shift + T)를 누르면 커맨드 라인이 열린다. 한가지 주의할 점은 동일한 단축키가 이미 서브라임 텍스트에서 사용하고 있어서 닫힌 파일 열기 기능이 작동되지 않는다는 것이다. 따라서 다른 키로 변경하는 것이 좋다. 12345678&#123; &quot;keys&quot;: [&quot;ctrl+alt+k&quot;], &quot;command&quot;: &quot;open_terminal&quot;, &quot;args&quot;: &#123; &quot;parameters&quot;: [&quot;-T&quot;, &quot;Custom Window Title&quot;] &#125;&#125;,&#123;&quot;keys&quot;: [&quot;ctrl+alt+t&quot;], &quot;command&quot;: &quot;reopen_last_file&quot;&#125; SublimeREPL 이 패키지는 서브라임 텍스트 편집기 내부에서 커맨드 라인 기능을 사용할 수 있게 만들어 준다. Goto Documentation 커서가 위치한 단어의 문서 사이트로 이동하는 패키지 이다.다음과 같이 중복되지 않게 원하는 단축키를 추가한다. 1&#123;&quot;keys&quot;: [&quot;ctrl+shift+h&quot;], &quot;command&quot;: &quot;goto_documentation&quot;&#125; JavaScript &amp; NodeJs Snippet 자바스크립트와 Node.js의 코드 조각 패키지 이다.","categories":[{"name":"Editor","slug":"Editor","permalink":"https://woonyzzang.github.com/categories/Editor/"},{"name":"SublimeText","slug":"Editor/SublimeText","permalink":"https://woonyzzang.github.com/categories/Editor/SublimeText/"}],"tags":[{"name":"sublimeText","slug":"sublimeText","permalink":"https://woonyzzang.github.com/tags/sublimeText/"}]},{"title":"SublimeText Setting","slug":"sublimetext-setting","date":"2017-05-14T13:05:58.000Z","updated":"2024-06-07T09:27:28.377Z","comments":true,"path":"2017/05/14/sublimetext-setting/","permalink":"https://woonyzzang.github.com/2017/05/14/sublimetext-setting/","excerpt":"","text":"Sublime Text 설정키 바인딩 Ctrl + &#96;를 눌러 콘솔 창을 열고 다음 명령어를 입력하고 엔터 키를 누른다. 1sublime.log_commands(True) 이것은 서브라임 텍스트에서 일어나는 모든 행동을 기록하라는 명령어 이다. 참고로 주의할 부분은 True는 대문자로 입력해야 한다. 명령어를 알아내면 콘솔 기록을 중지하기 위해 다음과 같은 명령어를 입력하고 엔터 키를 누른 다음 Esc 키를 눌러 콘솔 창을 닫는다. 1sublime.log_commands(False) 사용자 키맵을 열고 마지막 줄에 콤마를 입력한 다음 아래 코드를 입력하고 저장하면 메뉴에 단축키가 나타나게 된. 1&#123;&quot;keys&quot;: [&quot;ctrl+alt+m&quot;], &quot;command&quot;: &quot;@콘솔로 알아낸 키 바인딩 네임 입력&quot;&#125; 커맨드 라인에서 서브라임 텍스트 실행하기 시스템설정 -&gt; 고급 탭 -&gt; 환경변수 Path에 서브라임텍스트 (설치된)경로를 등록한다. 1C:\\Program Files\\Sublime Text 3\\ 관리자 권한으로 cmd 실행 후 1cd c:\\program files\\sublime text 3 경로가 바뀌면 다시 아래 명령을 입력하고 엔터키를 누른다. 1mklink subl.exe sublime_text.exe 그러면 기호화된 링크(Symbolic Link)가 만들어 졌다는 메세지가 나타나게 된다.그럼 이제 subl만 입력하고 엔터 키르 누르면 서브라임 텍스트가 실행된다. Git을 사용할 경우 Git Bash에서도 작동한다. 12subl.exe index.htmlsubl.exe style.css","categories":[{"name":"Editor","slug":"Editor","permalink":"https://woonyzzang.github.com/categories/Editor/"},{"name":"SublimeText","slug":"Editor/SublimeText","permalink":"https://woonyzzang.github.com/categories/Editor/SublimeText/"}],"tags":[{"name":"sublimeText","slug":"sublimeText","permalink":"https://woonyzzang.github.com/tags/sublimeText/"}]},{"title":"Javascript Hoisting","slug":"javascript-hoisting","date":"2017-05-13T16:46:57.000Z","updated":"2024-06-10T04:53:59.563Z","comments":true,"path":"2017/05/14/javascript-hoisting/","permalink":"https://woonyzzang.github.com/2017/05/14/javascript-hoisting/","excerpt":"","text":"JavaScript Hoisting(호이스팅) 이란?호이스팅은 끌어올리다라는 뜻인데, 풀이하자면 후선언된 변수나 함수들이 해당 Scope에서 최상위로 끌어 올려지는 걸 말한다.자바스크립트엔진은 해당 실행 문맥(Execution Context)의 생성시, 즉 Runtime 시점에서 변수 선언문이나 함수 선언문을 읽기 전에 선언된 변수와 함수들을 다른 무엇보다도 먼저 읽어 Scope(유효범위)의 최상위로 끌어올려 위치시킨다.이 덕에, 훨씬 뒤에서 선언된 함수들과 변수들을 그 전에 사용이 가능하다.참고로 변수의 경우에는 변수 선언(Variable Declaration)만 Hoisting 된다, 즉 Variable Initialization이 있다면 변수가 선언은 되나, 변수에 어떤 값도 들어가지 않는다는 뜻.또한 함수의 실행 문맥(Execution Context)의 생성은 함수 호출시 이뤄지므로, 함수 내부에서 선언된 변수들은 함수 호출시에서야 Hoisting 된다. 예제를 통해 살펴보기로 하자. 123456789101112console.log(asdf); // undefined, 오류가 나질 않는다. 즉 프로그램이 뻗질 않는다.console.log(qwer); // undefinedconsole.log(zxcv); // function zxcv() &#123; console.log(456); &#125;var asdf = &#x27;asdf&#x27;;var qwer = function() &#123; console.log(111);&#125;;function zxcv() &#123; console.log(456);&#125; 전통적인 프로그래밍 언어를 방식으로 다루는 개발자들은 이해하지 못하는 부분 중 하나가 바로 이 부분일 것이다.선언하기 전에 사용된 변수, 즉 상단에서 선언된적이 없는 변수인데 어디서 갑자기 나타나서 undefined를 콘솔에 출력하는데 프로그램이 왜 죽지 않는 것일까?그 이유는 바로 호이스팅이 일어났기 때문이다. 위의 코드는 호이스틩으로 인해 아래와 같이 변환되어 브라우저에 렌더링된다고 보면 된다. 123456789101112131415var asdf;var qwer;function zxcv() &#123; console.log(456);&#125;console.log(asdf);console.log(qwer);console.log(zxcv);asdf = &#x27;asdf&#x27;;qwer = function() &#123; console.log(111);&#125;; 함수 선언문에서는 변수 없이 함수를 선언한 것이므로 전체 코드가 호이스팅 된다.하지만 함수 표현식은 변수 선언과 할당을 구분할 수 있으므로 선언 부분만 호이스팅이 일어나게 된다.따라서 오류가 날 것으로 예상했던 코드가 예측한 대로 작동하질 않는데 호이스팅에 대한 개념이 없다면 이런 경우가 혼란스럽게 하기 마련이다.따라서 사용할 변수와 함수는 최소한 사용하기 전에 미리 선언하는 방식을 지향하는것이 안티패턴을 줄이고 개발자 의도대로 동작한다고 확신을 가질수 있는 좋은 코드 패턴일 것이다. ES2015(ES6) 호이스팅ES2015+에서는 호이스팅이 어떻게 처리되는지 알아보자.일단 ES2015+에서는 변수를 선언할 때 var 대신 const와 let으로 사용한다. 1234console.log(asdf); // Uncaught ReferenceError: asdf is not definedconsole.log(qwer);const asdf = &#x27;asdf&#x27;;let qwer = &#x27;qwer&#x27;; 1번 라인에서 오류가 나서 2번 라인은 실행도 못하고 바로 뻗어버린다.개발자의 바람대로 호이스팅이 사라진 것 같아 보인다.과연 정말 그런것일까…? TDZ(Temporal Dead Zone) 임시적 사각 지대, ‘변수가 임시로 죽어있는 공간’ 이라고 이해하면 될 것 같다.예제를 통해 살펴보자. 123456const asdf = &#x27;asdf&#x27;;const qwer = function() &#123; console.log(asdf); // Uncaught ReferenceError: asdf is not defined let asdf = &#x27;qwer&#x27;;&#125;qwer(); 호이스팅이 일어나지 않았다면 3번 라인에서는 ‘asdf’가 찍혀야 정상일 것이다.혹은 호이스팅이 일어났다면 undefined라도 찍혀야하는데 오히려 에러를 출력한다.이런 경우가 바로 TDZ 때문인데 위 코드를 다시 TDZ라는 것과 연관 지어서 풀어보면 아래와 같다. 123456789const asdf = &#x27;asdf&#x27;;const qwer = function() &#123; let asdf; // 사실 이렇게 변수 선언부가 호이스팅에 의해 스코프 상단으로 끌어올려진다. // 변수의 초기화 구문을 만나기 전까지 TDZ가 형성됨. console.log(asdf); // TDZ에서 해당 변수가 쓰였다면 에러를 발생! // 여기까지 TDZ. asdf = &#x27;qwer&#x27;;&#125;qwer(); TDZ는 변수 선언(호이스팅에 의해 스코프 상단으로 끌어올려진 부분)부터 변수의 할당을 만나기 전 부분까지 형성이 되는 구간인데 이 TDZ에서는 해당 변수가 임시적으로 죽어있는 구역인데 이 구역에 해당 변수가 끼어들면서 오류가 발생하게 되는 것이다. 참조 https://perfectacle.github.io/2017/04/26/js-002-hoisting/","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Javascript","slug":"Frontend/Javascript","permalink":"https://woonyzzang.github.com/categories/Frontend/Javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://woonyzzang.github.com/tags/js/"},{"name":"es6","slug":"es6","permalink":"https://woonyzzang.github.com/tags/es6/"}]},{"title":"EcmaScript","slug":"javascript-ecmascript","date":"2017-05-12T14:16:24.000Z","updated":"2024-06-10T04:53:59.556Z","comments":true,"path":"2017/05/12/javascript-ecmascript/","permalink":"https://woonyzzang.github.com/2017/05/12/javascript-ecmascript/","excerpt":"","text":"EcmaScript(ES)란?넷스케이프 사는 웹 페이지 동작을 향상시키는 자바스크립트를 지원하기 시작하고 자바스크립트가 사용자 층에서 성공을 거두자 MS에서도 IE3에 Jscript를 개발하여 탑재 하였다.이 때부터 브라우저 전쟁(1990년대 후반에 MS의 인터넷 IE와 넷스케이프 두 브라우저간 경쟁)이라고 불리는 시기가 시작된다.같은 기능이지만 둘의 기능 구현이 다르기 때문에 개발자들은 브라우저 호환성을 맞추기 위해 같은 기능을 구현할려면 둘 다 동작을 고려하기 위해 코드량이 늘어날수 밖에 없었다.이렇게 날이 가면 갈 수록 사용자를 끌어내기 위해 브라우저 벤더들간의 서로 특화된 기능을 넣다보니 JavaScript와 Jscript는 시간이 지날수록 달라지는 경향을 보였다.이에 심각성을 파악하고 ECMA International(European Computer Manufacturers Association) 표준 기구에서 브라우저에 사용되는 자바스크립트 부분만 표준을 정의하게 된다.또한 ECMA에서는 자바스크립트 표준 외에도 다른 표준안도 정하기 때문에 그와 구분짓기 위해 숫자 넘버링을 붙였는데 자바스크립트는 ECMA-262로 표준 정의 하였다.그렇기에 자바스크립트 명칭은 JavaScript가 아니라 ECMAScript 라고 표현해야 정확한 표현일 것이다.현재 대부분 사용하고있는 자바스크립트는 ES3이며, ES4는 논쟁요소가 많아 중도 폐기 되었으며 ES5부터 먼저 재정의 되었다. ES3 (1999) 대중적으로 많이 사용되는 자바스크립트가 ES3라고 생각해도 무관하다. 함수 단위의 스코프, 호이스팅, 모듈화 미지원 프로토타입 클로저 등등 자바스크립트의 기본적인 특징들이 정의되어 있다. ES5 (2009) ES4는 자바스크립트가 아닌 완전히 다른 언어인데다 보안 이슈에도 안전하지 않아서 인지 표준안에서 거절되고, 그 이후 점진적으로 개선을 하고자 ES5가 나왔다.기본적으로 IE9부터 본격적인 지원을 하지만 es5-shim을 사용하면 하위 버전에서도 특정 기능들을 지원해준다. 배열 표준 메소드배열과 관련해서 새로운 메소드들이 많이 생겼는데 대표적으로 forEach, map, reduce, some, every와 같은 순환 메소들이 생겼다.이 메소드들은 개발자가 반복 횟수나 조건을 잘못 입력하는 등의 실수를 줄여주는 효과가 있다. 객체 표준 메소드객체의 프로퍼티에 대한 설정을 할 수 있다. 해당 프로퍼티를 열거 불가(순환 로그창 등등), 읽기 전용, 설정 변경 불가, getter, setter 등을 설정 사항들을 직접 지정 가능하다.또한 Objectkeys 메소드를 사용하면 for in 메소드를 대체할 수 있게 된다. strict 모드문법을 좀 더 깐깐하게 체크하는 모드이다. 좀 더 코드를 안전하게(에러가 안나게, 미연에 방지) 등장했다. ES2015(ES6) 원래 명칭은 ES6이지만 사용자들이 끝자리인 6과 2016년을 연관짓거나 착각해서인지 정식 명칭이 ES2015로 바뀌었다.그렇기에 ES6나 ES2015는 같은 뜻이며 또는 ES6 Harmony라고도 불린다. 호이스팅이 사라진것 같은 효과 함수 단위 스코프에서 블록 단위 스코프로 변경 this를 종적으로 바인딩하지 않은 Arrow Function 모듈화 지원 비동기 콜백 패턴 가독성 개선, Promise Default, Reset 파라미터 해체할당, Spread 연산자 템플릿 리터럴 클래스이 외에도 특징은 많이 생겨났고 현재는 브라우저(IE)에서 지원해주지 않는 경우가 많아 Babal이라는 트랜스파일러를 사용하거나 바벨 웹 사이트 REPL에서 즉시 변환해서 사용할 수 한다. ES2015+ 현재 ES2016이 작년 6월 경에 발표되었다.ES2017은 조만간 발표될 예정이며 ES2015에서 너무 내용이 많이 바뀌어 런닝커브가 조금 높아졌다면 여기서부터는 크게 걱정할 필요가 없는게 그렇게 큰 내용이 변하지 않았다는 점이다.3에서 5까지 10년, 5에서 6까지 7년이라는 공백 때문에 엄청난 변화들이 있거나 했는데 이제는 매년 표준을 재정하면서 그런 혼란을 줄일 예정인 듯 하다.또한 이후에 나올 ES를 통칭해서 ES.Next라도고 표현 한다. 참조 https://perfectacle.github.io/2017/04/26/js-001-es/","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Javascript","slug":"Frontend/Javascript","permalink":"https://woonyzzang.github.com/categories/Frontend/Javascript/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://woonyzzang.github.com/tags/es6/"}]},{"title":"Javascript Scope Chain","slug":"javascript-scope-chain","date":"2017-05-12T09:59:49.000Z","updated":"2024-06-10T04:53:59.571Z","comments":true,"path":"2017/05/12/javascript-scope-chain/","permalink":"https://woonyzzang.github.com/2017/05/12/javascript-scope-chain/","excerpt":"","text":"JavaScript 스코프(Scope)란?Scope는 영역 범위라는 뜻으로 자바스크립트의 영역 범위는 어느 범위까지 참조하는지 즉, 변수와 매개변수(parameter)의 접근성과 생존기간을 뜻하며 유효범위는 크게 두 가지로 나뉘게 되는데 아래 스코프 체인에서 설명하는 활성화객체(Active Object)와 전역객체(Global Object) 이다.참고로 ES5까지는 함수 단위의 스코프를 가진다. 1234567891011121314151617181920// 전역 유효범위 스코프 (Global Scope)var a = 1;var b = 2;if (a &lt; b) &#123; var i = 3;&#125; else &#123; var i = 4;&#125;var c = function() &#123; // 함수 단위의 스코프가 시작 var a = 5; var d = 6; console.log(a); // 5, 현재 지역 유효범위 스코프(Local Scope)에 a 변수가 있기 때문에 현재 지역범위 스코프에 있는 a 변수 값을 출력&#125;;console.log(i); // 3, 함수 단위의 스코프이기 때문에 같은 전역 유효범위 스코프 공간에 있다고 간주해서 변수를 공유하기 때문에 사용 가능c();console.log(d); // Uncaught ReferenceError: d is not defined, 함수 단위의 스코프이기 때문에 함수에서 쓰인 변수는 함수에서만 사용 가능 가존 프로그래밍 언어들은 블록 단위의 스코프라고 해서 if, for 문등 별도의 스코프를 가졌던거에 비해 위에 코드처럼 자바스크립트에서는 함수 단위 스코프 개념이기 때문에 전역 유효범위 스코프로 인식한다. 자바스크립트 스코프 체인자바스크립트 성능을 다루는 부분에 항상 나오는 부분이 이 스코프 체인(Scope Chain) 이다.런타임 환경에서 가장 많이 발생되 브라우저의 작업 가운데 자바스크립트의 실행 성능을 저해하는 요인이 변수 객체 함수 등의 메모리상의 위치를 탐색하는 일이다. 스코프 체인 자바스크립트의 함수를 실행하면서 어떤 속성(변수 객체 등)에 접근해야 할 때 해당 속성을 효율적으로 탐색하도록 속성을 일정한 객체 단위로 분류하고 각 객체에 접근하기 위한 객체의 참조를 특정한 공간에 저장하게 되는데 이 공간이 바로 스코프 체인이다.스코프 체인의 구송요소에는 활성화객체(Active Object)와 전역객체(Global Object)가 있다. 활성화 객체 전역 객체 함수내부에서만 접근 가능한 지역변수나 this, aguments 객체 등의 속성 함수 외부에서도 접근 할 수 있는 window, document, 전역함수 전역변수등의 속성 실행 문맥(Execution Context)은 함수가 동작하는 환경을 나타내며, 브라우저 내부에서 사용되는 객체이다 샐행 문맥은 함수가 실행될 때 새로 생성되고 함수가 종료될 때 소멸되며 함수의 스코프 체인에 대한 참조를 가지고 있게 된다. 함수는 어떤 속성에 접근해야 할 때 실행 문맥을 통해 스코프 체인에 접근한다.실행 문맥은 자신과 연관된 함수의 스코프 체인을 참조하고 있으며, 함수에서 접근해야할 어떤 속성의 탐색경로는 ‘실행 문맥 &gt; 스코프 체인 &gt; 활성화 객체 &gt; 스코프 체인 &gt; 전역 객체’ 와 같이 구성된다. 지역 변수를 활용한 스코프 체인 색 성능 개선 속성의 탐색 경로를 어떻게 줄여야 자바스크립트가 좋은 성능을 낼 수 있는지 알아보겠. 1234567891011121314// 함수 내에서 전역 스코프 변수에 직접 접근하는 예제window.htmlstring = [];function makeList() &#123; htmlstring.push(&#x27;&lt;ul&gt;&#x27;); for (var i = 0, len = 100; i &lt; len; i++) &#123; htmlstring.push(&#x27;&lt;li&gt;value:&#x27; + i + &#x27;&lt;/li&gt;&#x27;); &#125; htmlstring.push(&#x27;&lt;/ul&gt;&#x27;);&#125;makeList(); makeList() 함수가 실행되면 함수 내부에서 htmlstring, i 속성에 접근하기 위해 스코프 체인을 탐색한다. i 변수는 실행 중인 함수의 지역변수이므로 처음 탐색하는 활성화 객체에서 찾을 수 있다.그러나 htmlstring 객체는 활성화 객체에 먼저 접근해서 탐색하지만 찾지 못하고 다시 전역 객체를 탐색해서 찾아야 한다. 다음과 같이 코드를 스코프 체인을 고려해서 리팩토링하면 성능을 향상 시킬 수 있다. 12345678910111213141516// 함수 지역변수로 참조해 전역 스코프 변수에 접근하는 예제window.htmlstring = [];function makeList() &#123; var htmlstr = htmlstring; htmlstring.push(&#x27;&lt;ul&gt;&#x27;); for (var i = 0, len = 100; i &lt; len; i++) &#123; htmlstring.push(&#x27;&lt;li&gt;value:&#x27; + i + &#x27;&lt;/li&gt;&#x27;); &#125; htmlstring.push(&#x27;&lt;/ul&gt;&#x27;);&#125;makeList(); 수정한 코드에서 추가한 var htmlstr = htmlstring; 부분이 성능 개선의 핵심이다. 전역 객체에 존재하는 htmlstring 속성을 makeList() 함수의 자역변수에 저장해서 활성화 객체에서 바로 찾을수 있게 한 것이다.물론 var htmlstr = htmlstring; 구문을 실행하는 동안 htmlstring 속성에 접근해야 하므로 최초 한 번은 활성화 객체와 전역 객체를 모두 탐색해야 하지만 그 이후에는 활성화 객체에 저장된 htmlstr 속성으로 전역변수인 htmlstring 객체에 접근할 수 있으니 활성화 객체를 거쳐 전역 객체까지 탐색할 필요가 없어진다. 코드 최적화 리팩토링 이전 코드에서는 htmlstring 객체를 찾으려면 ‘실행 문맥 &gt; 스코프 체인 &gt; 활성화 객체 &gt; 스코프 체인 &gt; 전역 객체’와 같이 동일한 탐색경로를 7번을 거치게 된다.하지만 리팩토링 한 코드에서는 var htmlstr = htmlstring; 구문을 실행할 경우 최초 한 번만 ‘실행 문맥 &gt; 스코프 체인 &gt; 활성화 객체 &gt; 스코프 체인 &gt; 전역 객체’와 같은 속성 탐색 경로를 거친다.그 이후 window 객체의 htmlstring 속성에 접근해야 하는 것은 지역변수 htmlstr 속성에 접근하는 것으로 대체되어 ‘실행 문맥 &gt; 스코프 체인 &gt; 활성화 객체’와 같이 단축된 탐색 경로를 거치므로 실행 속도가 더 빠르게 향상 된다. 참조 https://perfectacle.github.io/2017/04/27/js-003-scope/ http://www.nextree.co.kr/p7363/ NHN은 이렇게 한다! 자바스크립트 성능 이야기 도서","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Javascript","slug":"Frontend/Javascript","permalink":"https://woonyzzang.github.com/categories/Frontend/Javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://woonyzzang.github.com/tags/js/"}]},{"title":"it 용어 사전","slug":"log-dictionary-it","date":"2017-05-12T08:27:39.000Z","updated":"2024-06-14T10:41:36.580Z","comments":true,"path":"2017/05/12/log-dictionary-it/","permalink":"https://woonyzzang.github.com/2017/05/12/log-dictionary-it/","excerpt":"","text":"it 용어 정리it에서 회의나 개발을 진행하다 보면 다양한 용어를 접하게 되는데 흔하지 않게 사용되는 용어들을 정리해 본다. 이부분은 추후 계속 업데이트 될 예정이다. 레거시자바스크립트 플러그인등을 사용하다 보면 stable, legacy 두가지 버전으로 배포되는걸 볼 수 있다. Stable Version: 최종버전 중에서 테스트가 완료되고 버스가 수정된 안정화된 버전을 의미한다.Lagacy Version: 아직 사용이 가능한 이전 버전으로 최신 버전에서 새로 생긴 기능들은 제공되지 않지만 아직까지 최신 환경에서 사용하기에 문제가 없는 버전을 의미한다. 레거시 환경이란? 과거에도 개발되어 현재에도 사용중인 낡은 장비나 하드웨어 및 소프트웨어, 새로 제안되는 방식이나 기술을 부각시키는 의미를 뜻한다.브라우저로 비유하자면 최신 버전이 아닌 이전의 브라우저 버전 환경을 의미한다. 시그니처메소드 구분에 사용되는 메소드이름 파라미터 변수의 수 타입 순서를 묶어서 메소드 시그니처(signature, 서명)이라고 한다. 타임테이블일정표를 의미한다. 데드라인마감일정을 의미한다. ASAPAs Soon As Possible 약자로, ‘가능하면 빨리’라는 뜻을 의미한다.","categories":[{"name":"Log","slug":"Log","permalink":"https://woonyzzang.github.com/categories/Log/"}],"tags":[{"name":"log","slug":"log","permalink":"https://woonyzzang.github.com/tags/log/"}]},{"title":"SublimeText Package Control 및 Package","slug":"sublimetext-package-control","date":"2017-05-12T07:53:47.000Z","updated":"2024-06-07T09:27:28.375Z","comments":true,"path":"2017/05/12/sublimetext-package-control/","permalink":"https://woonyzzang.github.com/2017/05/12/sublimetext-package-control/","excerpt":"","text":"Sublime Text 패키지서브라임 텍스트의 패키지 설치는 매우 손쉽게 접근할 수 있도록 구성되어져 있는데, 여기서 패키지란 쉽게 말해 플러그인이라고 이해하면 된다.Package Control은 이러한 패키지들을 관리해주는 도구이며, 이를 이용해 손쉽게 패키들을 설치 및 제거, 업데이트를 할 수 있다. 즉, 플러그인을 설치하기 전에 반드시 패키지 컨트롤을 필수적으로 설치해야 한다. 패키지 컨트롤 설치 방법 서브라임텍스트를 실행하고 먼저 콘솔을 실행한다. 단축키: Ctrl + &#96; 12// SUBLIME TEXT2import urllib2,os,hashlib; h = &#x27;df21e130d211cfc94d9b0905775a7c0f&#x27; + &#x27;1e3d39e33b79698005270310898eea76&#x27;; pf = &#x27;Package Control.sublime-package&#x27;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( &#x27;http://packagecontrol.io/&#x27; + pf.replace(&#x27; &#x27;, &#x27;%20&#x27;)).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), &#x27;wb&#x27; ).write(by) if dh == h else None; print(&#x27;Error validating download (got %s instead of %s), please try manual install&#x27; % (dh, h) if dh != h else &#x27;Please restart Sublime Text to finish installation&#x27;) 12// SUBLIME TEXT3import urllib.request,os,hashlib; h = &#x27;df21e130d211cfc94d9b0905775a7c0f&#x27; + &#x27;1e3d39e33b79698005270310898eea76&#x27;; pf = &#x27;Package Control.sublime-package&#x27;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &#x27;http://packagecontrol.io/&#x27; + pf.replace(&#x27; &#x27;, &#x27;%20&#x27;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&#x27;Error validating download (got %s instead of %s), please try manual install&#x27; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &#x27;wb&#x27; ).write(by) 위에 서브라임 텍스트 버전에 맞는 코드를 복사해서 콘솔 붙여넣고 엔터를 누르면 패키지 컨트롤이 설치된다. Sublime Text 3 패키지설치를 원하는 패키지들을 찾아봐야 하는데 https://packagecontrol.io/browse에서 설치하거나 Sublime Text 패키지로 검색해서 원하는 패키지 찾아서 설치하면 된다. 패키지 설치 서브라임 텍스트를 실행한 후, 단축키 Ctrl + Shift + P로 Command Palette를 불러온다.install을 입력하면 자동완성되는 Package Control: Install Package를 선택하고 엔터를 누른다.설치를 원하는 플러그인의 이름으로 검색하여 선택한 후, 엔터를 눌러 설치한다. 패키지 설치 리스트 서브라임 텍스트를 실행한 후, 단축키 Ctrl + Shift + P로 Command Palette를 불러온다.list 입력하고 자동완성되는 Package Control: List Package를 선택하고 엔터를 누른다.설치된 플러그인들이 나열된다. 패키지 삭제법서브라임 텍스트를 실행한 후, 단축키 Ctrl + Shift + P로 Command Palette를 불러온다.remove를 입력하고 자동완성되는 Package Control: Remove Package를 선택하고 엔터를 누른다.설치된 플러그인들이 리스팅되면 삭제할 것을 선택하고 엔터를 누른다. 참조 https://packagecontrol.io/installation http://sanghaklee.tistory.com/6 http://webdir.tistory.com/396","categories":[{"name":"Editor","slug":"Editor","permalink":"https://woonyzzang.github.com/categories/Editor/"},{"name":"SublimeText","slug":"Editor/SublimeText","permalink":"https://woonyzzang.github.com/categories/Editor/SublimeText/"}],"tags":[{"name":"sublimeText","slug":"sublimeText","permalink":"https://woonyzzang.github.com/tags/sublimeText/"}]},{"title":"Javascript Video Custom Controls","slug":"javascript-video-custom-controls","date":"2017-04-28T07:46:42.000Z","updated":"2024-06-10T04:53:59.573Z","comments":true,"path":"2017/04/28/javascript-video-custom-controls/","permalink":"https://woonyzzang.github.com/2017/04/28/javascript-video-custom-controls/","excerpt":"","text":"JavaScript를 활용한 HTML5 Video 네이티브 커스텀 컨트롤 만들기커스텀 컨트롤을 만들기 위해서는 우선 브라우저에서 자체 제공하는 네이티브 컨트롤을 감춰야 한다.Video 엘리먼트의 속성중 controls에 false 값을 주면 브라우저가 알아서 네이티브 컨트롤을 숨길수 있다.(controls 속성은 default 값이 false이기 때문에 아예 속성을 지정 안해도 무관하다.)네이티브 컨트롤을 감춘 후 커스텀 컨트롤을 추가해서 제어하면 된다. HTML 코드 1234567891011121314151617181920&lt;div id=&quot;videoContainer&quot; class=&quot;video_container&quot;&gt; &lt;video id=&quot;video&quot;&gt; &lt;source src=&quot;http://content.bitsontherun.com/videos/q1fx20VZ-27m5HpIu.webm&quot; type=&quot;video/webm&quot;&gt; &lt;source src=&quot;http://content.bitsontherun.com/videos/q1fx20VZ-52qL9xLP.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;/video&gt; &lt;div id=&quot;videoControls&quot; class=&quot;video_controls&quot;&gt; &lt;div class=&quot;group&quot;&gt; &lt;button type=&quot;button&quot; id=&quot;btnRestart&quot;&gt;Re&lt;/button&gt; &lt;button type=&quot;button&quot; id=&quot;btnRew&quot;&gt;&amp;lt;&amp;lt;&lt;/button&gt; &lt;button type=&quot;button&quot; id=&quot;btnPlay&quot; class=&quot;play&quot;&gt;Play&lt;/button&gt; &lt;button type=&quot;button&quot; id=&quot;btnFastFwd&quot;&gt;&amp;gt;&amp;gt;&lt;/button&gt; &lt;input type=&quot;range&quot; value=&quot;0&quot; id=&quot;seekBar&quot; class=&quot;seek_bar&quot;&gt; &lt;button type=&quot;button&quot; id=&quot;btnMute&quot;&gt;Mute&lt;/button&gt; &lt;input type=&quot;range&quot; min=&quot;0&quot; max=&quot;1&quot; step=&quot;0.1&quot; value=&quot;1&quot; id=&quot;volumeBar&quot; class=&quot;volume_bar&quot;&gt; &lt;button type=&quot;button&quot; id=&quot;btnVolUp&quot;&gt;Vol Up&lt;/button&gt; &lt;button type=&quot;button&quot; id=&quot;btnVolDown&quot;&gt;Vol Down&lt;/button&gt; &lt;button type=&quot;button&quot; id=&quot;btnFullScreen&quot;&gt;Full Screen&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; CSS 코드 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768* &#123; margin: 0; padding: 0;&#125;.video_container &#123; overflow: hidden; position: relative; background-color: #000; width: 640px; height: 365px;&#125;.video_container video &#123; width: 100%; height: 100%;&#125;.video_container video::-webkit-media-controls &#123; display:none !important;&#125;.video_container video::-webkit-media-controls-enclosure &#123; display:none !important;&#125;.video_container .video_controls &#123; position: absolute; right: 0; bottom: 0; left: 0; /*z-index: 2147483647;*/ padding: 5px; opacity: 1; -webkit-transition: opacity .3s; -moz-transition: opacity .3s; -o-transition: opacity .3s; -ms-transition: opacity .3s; transition: opacity .3s; background-image: linear-gradient(bottom, rgb(3,113,168) 13%, rgb(0,136,204) 100%); background-image: -o-linear-gradient(bottom, rgb(3,113,168) 13%, rgb(0,136,204) 100%); background-image: -moz-linear-gradient(bottom, rgb(3,113,168) 13%, rgb(0,136,204) 100%); background-image: -webkit-linear-gradient(bottom, rgb(3,113,168) 13%, rgb(0,136,204) 100%); background-image: -ms-linear-gradient(bottom, rgb(3,113,168) 13%, rgb(0,136,204) 100%); background-image: -webkit-gradient(linear, left bottom, left top, color-stop(0.13, rgb(3,113,168)), color-stop(1, rgb(0,136,204))); text-align: center;&#125;.video_container .video_controls&gt;.group &#123; display: inline-block;&#125;.video_container .video_controls button[type=button] &#123; padding: 4px; background: rgba(0,0,0,.5); border: 0; border-radius: 3px; color: #eee; vertical-align: top; cursor: pointer;&#125;.video_container .video_controls .seek_bar &#123; width: 200px;&#125;.video_container .video_controls .volume_bar &#123; width: 40px;&#125; JavaScript 코드 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140var $video = document.querySelector(&quot;#video&quot;);/** * videoPlay * @description 비디오 영상 플레이/정지 */function videoPlay() &#123; if ($video.paused) &#123; $video.currentTime = parseInt($video.duration * (this.value / 100), 10); $video.play(); &#125; else &#123; $video.pause(); &#125;&#125;/** * skip * @description 비디오 영상 앞/뒤 스킵 * @param &#123;Number&#125; value - 비디오 재생 타임 시간 */function skip(value) &#123; if ($video.paused) &#123; return; &#125; $video.currentTime += value;&#125;/** * setVolume * @description 볼륨 조절 * @param &#123;Number&#125; value - 볼륨 조절 값(min: 0 ~ max: 1) */function setVolume(value) &#123; var vol = $video.volume; vol += value; if (vol &gt;= 0 &amp;&amp; vol &lt;= 1) &#123; $video.volume = vol; &#125; else &#123; $video.volume = (vol &lt; 0)? 0 : 1; &#125;&#125;// 진행바 업데이트 이동 이벤트$video.addEventListener(&#x27;timeupdate&#x27;, function() &#123; if ($video.paused) &#123; return; &#125; document.querySelector(&#x27;#seekBar&#x27;).value = (100 / $video.duration) * $video.currentTime;&#125;);// 재시작 버튼 클릭 이벤트 핸들러document.querySelector(&#x27;#btnRestart&#x27;).addEventListener(&#x27;click&#x27;, function() &#123; $video.currentTime = 0;&#125;);// 플레이 버튼 클릭 이벤트 핸들러document.querySelector(&#x27;#btnPlay&#x27;).addEventListener(&#x27;click&#x27;, videoPlay);// 재시작 버튼 클릭 이벤트 핸들러1document.querySelector(&#x27;#btnRew&#x27;).addEventListener(&#x27;click&#x27;, function() &#123; skip(-10);&#125;);// 재시작 버튼 클릭 이벤트 핸들러2document.querySelector(&#x27;#btnFastFwd&#x27;).addEventListener(&#x27;click&#x27;, function() &#123; skip(10);&#125;);// 진행바 마우스다운 이벤트 핸들러document.querySelector(&#x27;#seekBar&#x27;).addEventListener(&#x27;mousedown&#x27;, function(e) &#123; $video.pause();&#125;);// 진행바 마우스업 이벤트 핸들러document.querySelector(&#x27;#seekBar&#x27;).addEventListener(&#x27;mouseup&#x27;, videoPlay);// muted 속성 사운드트랙 음소거 제어document.querySelector(&#x27;#btnMute&#x27;).addEventListener(&#x27;click&#x27;, function (e) &#123; if ($video.muted) &#123; $video.muted = false; &#125; else &#123; $video.muted = true; &#125;&#125;, false);// 볼륨 range 컨트롤document.querySelector(&#x27;#volumeBar&#x27;).addEventListener(&#x27;change&#x27;, function () &#123; $video.volume = this.value;&#125;, false);// 볼륨 버튼 컨트롤document.querySelector(&#x27;#btnVolUp&#x27;).addEventListener(&quot;click&quot;, function () &#123; setVolume(.1); // up by 10%&#125;, false);document.querySelector(&#x27;#btnVolDown&#x27;).addEventListener(&quot;click&quot;, function () &#123; setVolume(-.1); // down by 10%&#125;, false);// FullScreen 클릭 이벤트 핸들러document.querySelector(&#x27;#btnFullScreen&#x27;).addEventListener(&#x27;click&#x27;, function() &#123; var $videoContainer = document.querySelector(&#x27;#videoContainer&#x27;); if ($videoContainer.requestFullscreen) &#123; $videoContainer.requestFullscreen(); &#125; else if ($videoContainer.mozRequestFullScreen) &#123; $videoContainer.mozRequestFullScreen(); &#125; else if ($videoContainer.webkitRequestFullscreen) &#123; $videoContainer.webkitRequestFullscreen(); &#125; else if($videoContainer.msRequestFullscreen)&#123; $videoContainer.msRequestFullscreen(); &#125; $videoContainer.style.width = &#x27;100%&#x27;; $videoContainer.style.height = &#x27;100%&#x27;;&#125;);// FullScreen 상태를 해제 시 원래 사이즈로 복원document.addEventListener(&#x27;webkitfullscreenchange&#x27;, function() &#123; // Webkit var $videoContainer = document.querySelector(&#x27;#videoContainer&#x27;); if (!document.webkitIsFullScreen) &#123; $videoContainer.style.width = &#x27;640px&#x27;; $videoContainer.style.height = &#x27;365px&#x27;; &#125;&#125;);document.addEventListener(&#x27;mozfullscreenchange&#x27;, function() &#123; // Firefox if (!document.mozIsFullScreen) &#123; videoContainer.style.width = &#x27;640px&#x27;; videoContainer.style.height = &#x27;365px&#x27;; &#125;&#125;);document.addEventListener(&#x27;MSFullscreenChange&#x27;, function() &#123; // Explorer if (!document.msFullscreenElement) &#123; videoContainer.style.width = &#x27;640px&#x27;; videoContainer.style.height = &#x27;365px&#x27;; &#125;&#125;); 참조 http://huns.me/development/1415 https://msdn.microsoft.com/ko-kr/library/hh924823(v=vs.85).aspx","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Javascript","slug":"Frontend/Javascript","permalink":"https://woonyzzang.github.com/categories/Frontend/Javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://woonyzzang.github.com/tags/js/"}]},{"title":"Javascript Bookmark","slug":"javascript-bookmark","date":"2017-04-20T07:44:04.000Z","updated":"2024-06-10T04:53:59.555Z","comments":true,"path":"2017/04/20/javascript-bookmark/","permalink":"https://woonyzzang.github.com/2017/04/20/javascript-bookmark/","excerpt":"","text":"JavaScript 즐겨찾기(Bookmark) 기능 구현하기북마크(즐겨찾기로 알려진)는 웹페이지를 브라우저에 저장해두고 바로가기를 하는 기능이다.필요에 따라 수동으로 사용자가 언제든지 페이지를 즐겨찾기에 추가할 수 있지만, 자바스크립트로 제어하는 방법을 정리한다. 브라우저 지원사항 IE: 모든 브라우저 지원 Chrome: 단축키 알림을 띄움 Firefox 지원 Opera: 단축키 알림을 띄움 Safari: 단축키 알림을 띄움 jQuery 코드 샘플 123456789101112131415161718192021222324252627282930&lt;a href=&quot;#&quot; id=&quot;favorite&quot; title=&quot;즐겨찾기 등록&quot;&gt;즐겨찾기&lt;/a&gt;&lt;script&gt;$(&#x27;#favorite&#x27;).on(&#x27;click&#x27;, function(e) &#123; var bookmarkURL = window.location.href, bookmarkTitle = document.title, triggerDefault = false; if (window.sidebar &amp;&amp; window.sidebar.addPanel) &#123; // Firefox version &amp;lt; 23 window.sidebar.addPanel(bookmarkTitle, bookmarkURL, &#x27;&#x27;); &#125; else if ((window.sidebar &amp;&amp; (navigator.userAgent.toLowerCase().indexOf(&#x27;firefox&#x27;) &lt; -1)) || (window.opera &amp;&amp; window.print)) &#123; // Firefox version &amp;gt;= 23 and Opera Hotlist var $this = $(this); $this.attr(&#x27;href&#x27;, bookmarkURL); $this.attr(&#x27;title&#x27;, bookmarkTitle); $this.attr(&#x27;rel&#x27;, &#x27;sidebar&#x27;); $this.off(e); triggerDefault = true; &#125; else if (window.external &amp;&amp; (&#x27;AddFavorite&#x27; in window.external)) &#123; // IE Favorite window.external.AddFavorite(bookmarkURL, bookmarkTitle); &#125; else &#123; // WebKit - Safari/Chrome alert((navigator.userAgent.toLowerCase().indexOf(&#x27;mac&#x27;) != -1 ? &#x27;Cmd&#x27; : &#x27;Ctrl&#x27;) + &#x27;+D 를 이용해 이 페이지를 즐겨찾기에 추가할 수 있습니다.&#x27;); &#125; return triggerDefault;&#125;);&lt;/script&gt; 참조 http://webdir.tistory.com/454","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Javascript","slug":"Frontend/Javascript","permalink":"https://woonyzzang.github.com/categories/Frontend/Javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://woonyzzang.github.com/tags/js/"}]},{"title":"Visualstudio Application","slug":"visualstudio-application","date":"2017-04-19T14:53:40.000Z","updated":"2024-06-07T09:27:28.381Z","comments":true,"path":"2017/04/19/visualstudio-application/","permalink":"https://woonyzzang.github.com/2017/04/19/visualstudio-application/","excerpt":"","text":"Visual Studio 2017 응용 프로그램 만들기비주얼 스튜디오를 이용하면 손쉽고 간단하게 .msi 나 .exe 인 윈도우 응용 프로그램을 개발할 수 있다.Visual Studio 2017 Pro 버전으로 설치해서 진행하였으며 진행했던 과정을 정리한다. 비주얼 스튜디오에서 응용 프로그램 설치 배포 방법은 크게 2가지로 나눠진다. 인스톨실드(Installshield)를 사용하는 방법 인스톨러 프로젝트 (Install Project)를 사용하는 방법 두 방법은 각각 아래와 같은 장.단점이 존재한다. 인스톨쉴드는 Step By Step으로 패포에 필요한 작업을 상세하게 성정할 수 있도록 도와준다.상당히 전문적으로 도와주기 때문에 개발자들은 단계별로 필요사항만 설정해주면 간단하게 배포 파일을 생성할 수 있다.그러나 인스톨쉴드의 경우는 무료가 아니라 유료이다. 유료이기 때문에 개인적으로나 업무적으로 간단하게 배포파일을 생성해서 사용하기에 부담이 될 수 밖에 없다. 인스톨러 프로젝트 Step By Step형식의 설치 생성과정이나 개발자들이 놓치기 쉬운 프로그램의 설정은 지원하지 않는다.하지만 인스톹러 프로젝트는 유료가 아니라 무료이다. 무료이기 때문에 이용하는방법을 조금만 익히면 크게 어렵지는 않다. Visual Studio IDE 다운로드 아래 다운로드 경로에서 비주얼 스튜디오 에디터를 다운로드 받는다. 다운로드:https://www.visualstudio.com/ko/downloads/?rr=https%3A%2F%2Fwww.google.co.kr%2F 설치 후 개별 구성 요소 &gt; 코드 도구 &gt; ClickOne 게시 옵션을 활성화 시킨다.아래 인스톨러쉴드나 인스톨러 프로젝트 둘중에 하나를 선택해 설치한다. Visual Studio Installshield LE(Limited Edition) 확장 툴 설치(유료) Visual Studio 2017에서는 기본적으로 InstallShield Limited Edition이 더 이상 제공되지 않는 듯 하다.인스톨러쉴드 확장 툴을 다운로드 받고 설치한다.(설치 진행시에는 비주얼 스튜디오를 종료해야 한다.) 다운로드:http://learn.flexerasoftware.com/content/IS-EVAL-InstallShield-Limited-Edition-Visual-Studio Visual Studio Installer 확장 툴 설치(무료) 인스톨러 프로젝트 확장 툴을 다운로드 받고 설치한다.(설치 진행시에는 비주얼 스튜디오를 종료해야 한다.) 다운로드:https://marketplace.visualstudio.com/items?itemName=VisualStudioProductTeam.MicrosoftVisualStudio2017InstallerProjects 설치가 완료 되면 다음과 같이 진행한다. 파일 &gt; 새로만들기 &gt; 프로젝트 을 선택한다. 기타 프로젝트 형식 &gt; Visual Studio Installer &gt; Setup Project를 선택한다. .url 파일과, .ico 파일은 해당 디렉토리를 선택한 후 우측 영역에서 마우스 우측을 눌러 컨텍스트 메뉴에서 Add &gt; File 에서 해당 파일을 선택해서 넣어주면 된다. Application Folder: .ico User’s Application Data Folder: 없음 User’s DeskTop: .url User’s Programs Menu: 없음 참고로 Application Folder 디렉토리는 마우스 우측을 눌러 컨텍스트 메뉴에서 Add Special Folder &gt; 사용자 응용프로그램 데이터 폴더 메뉴를 클릭하면 생성 된다. 빌드 버튼을 누르면 디폴트 경로인 debug 디렉토리에 .msi, .exe 설치 파일이 생성된다. .exe 파일 단독 설치시 이슈 .msi 설치파일은 전역으로 사용 가능하지만 .exe 설치파일은 .msi 파일이 같은 경로에 있어야 실행되는 문제가 있었다.이 문제를 해결하기위해 여러가지 다른 대응방법을 몇가지 찾아 테스트 해봤지만 효율적으로 자체 내부 설정이나 컨버팅 하는 방법은 찾지 못했다.그래서 간단하게 처리할수 있는 방법으로 생각한게 msi2exe converter 툴 이다. msi2exe converter 다운로드 다운로드:http://download.cnet.com/ImElfin-MSI2EXE-Converter/3000-2094_4-76020455.html 변환툴을 다운로드 받아 .msi 파일을 .exe 파일로 변환하면 전역으로 사용할 수 있는 .exe 파일로 변환된다. 참조 http://www.doccabi.pe.kr/entry/%EB%B0%94%EB%A1%9C%EA%B0%80%EA%B8%B0-%EC%95%84%EC%9D%B4%EC%BD%98-%EC%84%A4%EC%B9%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%83%9D%EC%84%B1 http://infototal.tistory.com/entry/%EC%9D%B8%ED%84%B0%EB%84%B7-%EB%B0%94%EB%A1%9C%EA%B0%80%EA%B8%B0%EC%9D%B8-URL-%ED%8C%8C%EC%9D%BC%EC%9D%98-%ED%98%95%EC%8B%9D http://rocabilly.tistory.com/186 http://blog.naver.com/PostView.nhn?blogId=rickman2&amp;logNo=220652711833","categories":[{"name":"Editor","slug":"Editor","permalink":"https://woonyzzang.github.com/categories/Editor/"},{"name":"Visualstudio","slug":"Editor/Visualstudio","permalink":"https://woonyzzang.github.com/categories/Editor/Visualstudio/"}],"tags":[{"name":"visualstudio","slug":"visualstudio","permalink":"https://woonyzzang.github.com/tags/visualstudio/"}]},{"title":"Windows Digital Signature","slug":"windows-digital-signature","date":"2017-04-19T14:50:10.000Z","updated":"2024-06-07T09:27:28.385Z","comments":true,"path":"2017/04/19/windows-digital-signature/","permalink":"https://woonyzzang.github.com/2017/04/19/windows-digital-signature/","excerpt":"","text":"사설 인증서로 실행 파일 전자서명(디지털서명, digital signature, 코드 사이닝, 코드 사인, code sign) 하기응용 프로그램을 만들어 서버에 업로드 후 배포를 하게 되면 다운로드를 받거나 다운로드 받은 응용 프로그램을 다른 컴퓨터에서 실행할려고 하면 출처가 불명확한 게시자없음으로 인해 악성 프로그램으로 인식하게 된다.그래서 이를 해결할려면 디지털 서명을 응용프로그램 안에 넣어야 한다. 사설 인증서를 생성하고 이를 PC내의 신뢰된 루트 인증 기관 리스트에 강제 추가한뒤, 이를 가지고 디지털 서명하는 절차를 정리한다. Microsoft Windows SDK 사용하는 방법 Microsoft SignTool 사용하는 방법 확인해 보니 보통 openssl을 이용할 거나, MS Windows SDK, MS SignTool 등등 있었다. 여기서는 MS에서 제공한 Microsoft Windows SDK 툴을 기반으로 진행한다. Microsoft Windows SDK 설치다운로드:https://www.microsoft.com/en-us/download/details.aspx?id=8279 설치가 완료되면 설치파일 경로에서 C:\\Program Files\\Microsoft Platform SDK ... \\Bin 경로에서 명령프롬프트를 관리자 권한으로 실행한다. 루트 인증서 진행 과정 XXXXXXXXX에 인증서 이름을 넣고 명령어를 실행한다. 앞선 “신뢰할 수 있는 루트 인증 기관” UI의 “발급 대상”에 해당된다고 보면 된다. 1234$ makecert -n &quot;CN=XXXXXXXXX&quot; -r -sv ca.pvk ca.cer// ex)$ makecert -n &quot;CN=woonyzzang Co.&quot; -r -sv ca.pvk ca.cer 그럼 아래와 같은 창이 뜨는데,이는 해당 루트 인증서로 서명된 또다른 인증서를 만들때 필요한 암호를 입력하는 것입니다. 만일, 관여하지 않겠다면 “없음”해도 무방 하다.여기서는 암호키를 입력하고 진행한다. (주의: 개인 키 암호를 임의로 입력 시 암호 기억)그러면 해당 디렉토리에 .cer과 .pvk파일이 생성된다..cer 파일은 배포 가능한 인증서 파일이며, .pvk 파일은 개인키 파일이므로, 신중히 보관하시기 바란다. 만일 spc 파일이 필요한 경우라면, 1$ cert2spc.exe ca.cer ca.spc 와 같이 구할 수 있습니다. 이제 아래와 같이 실행하여 ca.cer를 “신뢰할 수있는 루트 인증 기관”으로 등록할 수 있습니다. 1$ certmgr.exe -add ca.cer -s -r localMachine root 위와 같이 입력하면 ca.cer을 인증기관으로 등록절차가 완료된다. 이제 Internet Explorer &gt; 도구 &gt; 인터넷 옵션 &gt; 내용 &gt; 인증서에 들어가 보면, 아래와 같이 “신뢰할 수 있는 루트 인증 기관”에 woonyzzang Co.가 포함된것을 확인할 수 있다. 사설 인증서를 “신뢰”할 수 있도록 등록 된걸 확인 했다면, 다시 명령프롬프트로 돌아가서 아래 명령어를 입력한다. 1$ signtool signwizard 그럼 다음과 같이 창이 생성된다.다음 버튼을 선택한다. 디지털 서명 마법사에서 찾아보기를 클릭 후 디지털 파일 서명할 해당 파일을 선택 후 다음 버튼을 선택한다. 사용자 지정을 선택하고 다음을 선택한다. 오른쪽에 “파일에서 선택”을 선택한다. 오른쪽에 X.509인증서로 바꾼 후에 X.509 인증서(*.cer)을 선택한다. 이제 다음을 선택한다. 디스크의 개인 키 파일에서 ca.pvk 파일 경로를 찾아 선택 후 다음버튼을 선택한다. 처음에 입력한 암호를 입력한다. sha1을 선택하고 다음버튼을 선택한다. 필요한 경우 설명을 입력할 수 있다. 여기서는 별다른 설정없이 다음버튼을 선택한다. 필요한 경우 설명을 입력 할 수 있다. 여기서는 역시 별다른 설명없이 다음버튼을 선택한다. 타임스탬프를 추가할 일이 없으면 다음버튼을 선택한다. 디지털 서명이 완료되었다. 마침을 눌러 암호를 한번 더 입력하고 나면 완료된다. 이제 디지털 서명이 등록되었습니다. 인터넷을 통해 배포할 때 악성코드로 인식되지 않게 된다. 디지털 서명이 잘 등록되었는지 확인 해 볼려면 디지털 서명 받은 실행파일에서 마우스 우측 컨텍스트 메뉴를 열어 속성 &gt; 디지털서명 &gt; 자세히보기 클릭 후 확인해 보면 인증서가 제대로 등록된것을 확인 할 수 있다.만일, 신뢰된 루트 인증서에 추가하지 않았다면, 디지털 서명은 되어 변조 여부까지는 판단 가능하지만, 유효(즉, 안전한 출처)하지 않다고 오류가 발생할 것이다. 이슈 디지털 서명을 해도 테스트 해보니 여전히 익스플로러나 크롬브라우저에서 역시나 악성코드로 인식되는 것이 확인 되었다.신뢰된 인증기관에서 발급된 것이 아니라 그런듯 해서 자료를 더 찾아보니 아래와 같은 명성치라는 이슈를 알게 되었다. 명성치 MS의 SmartScreen filter는 인증서들에 대한 자체적인 white list DB를 관리하며 해당 인증서가 안전한지 아닌지 판단합니다. 새로 등록된 인증서로 만들어진 파일이 일정 횟수 이상, 일정 기간 이상 동안, 일정 사용자들에게 다운로드 되고, 신고 건수가 없어야 안전한 파일로 white list에 등록한다(SmartScreen filter는 원래 IE에 존재하던 기능이었다가 Windows 8부터는 OS 자체 기능으로도 추가되었다). Google의 Chrome도 이와 비슷한 로직을 가지고 있다.즉, 일정 수준을 명성을 쌓기 전까지는 위험한 프로그램 취급을 하여 사용자들에게 경고 메시지를 보여 준다. 하지만 여기서 답답한 부분은 필요한 ‘다운로드 수’, ‘다운로드 인원’, ‘처리되는 기간’ 등 중요한 정보들이 공개 되어있지 않다는 것이다. Microsoft SignTool 설치다운로드: https://msdn.microsoft.com/en-us/library/windows/desktop/aa387764(v=vs.85).aspx 12345$ Signtool.exe sign /a /f &quot;&#123;인증서 경로&#125;&quot; /p &quot;&#123;인증서 비밀번호&#125;&quot; /t &quot;&#123;인증서에 따른 Timestamp 서버 주소 예) http://timestamp.verisign.com/scripts/timestamp.dll&#125;&quot; 참조 http://greenfishblog.tistory.com/199 http://remocon33.tistory.com/385 http://blog.dramancompany.com/2015/12/%EC%B2%98%EC%9D%8C-windows-%EC%84%A4%EC%B9%98-%ED%8C%8C%EC%9D%BC%EC%9D%84-%EB%B0%B0%ED%8F%AC%ED%95%98%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%93%A4%EC%9D%84-%EC%9C%84%ED%95%98%EC%97%AC/","categories":[{"name":"OS","slug":"OS","permalink":"https://woonyzzang.github.com/categories/OS/"},{"name":"Windows","slug":"OS/Windows","permalink":"https://woonyzzang.github.com/categories/OS/Windows/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://woonyzzang.github.com/tags/windows/"}]},{"title":"Windows Icon ShortCut","slug":"windows-icon-shortcut","date":"2017-04-19T14:49:03.000Z","updated":"2024-06-07T09:27:28.386Z","comments":true,"path":"2017/04/19/windows-icon-shortcut/","permalink":"https://woonyzzang.github.com/2017/04/19/windows-icon-shortcut/","excerpt":"","text":"Windows 환경에서 바탕화면 아이콘 설치 프로그램 생성윈도우 환경에서 바로가기 아이콘 생성하는 과정을 정리한다.바탕화면에 바로가기 아이콘 기능을 사용하려면 Application Shortcut 은 확장자가 .link &#x2F; 인터넷 바로가기는 .url 파일로 구성 된다. 인터넷 바로가기 아이콘 샘플 코드 12345// test.url[InternetShortcut]URL=&#123;&#123;http://홈페이지 주소&#125;&#125;IconFile=&#123;&#123;아이콘 파일 경로&#125;&#125; .txt 파일 생성후 위에 코드를 넣고 확장자를 .url로 변경하면 인터넷 바로가기 아이콘이 완료된다. 11번가의 바로가기 아이콘 코드 샘플 123456789// Upgrade Your Life - 11번가.url[InternetShortcut]URL=http://www.11st.co.kr/connect/Gateway.tmall?method=Xsite&amp;tid=1000013091&amp;lpUrl=http%3A%2F%2Fwww.11st.co.krIconIndex=0IconFile=C:\\ProgramData\\11stNewIcon.icoModified=0IDList=HotKey=0 Visual Studio IDE 다운로드아래 다운로드 경로에서 비주얼 스튜디오 에디터를 다운로드 받는다. 다운로드: https://www.visualstudio.com/ko/downloads/?rr=https%3A%2F%2Fwww.google.co.kr%2F 설치 후 개별 구성 요소 &gt; 코드 도구 &gt; ClickOne 게시 옵션을 활성화 시킨다. Visual Studio Installer 확장 툴 설치인스톨러 확장 툴을 다운로드 받고 설치한다.(설치 진행시에는 비주얼 스튜디오를 종료해야 한다.) 다운로드: https://marketplace.visualstudio.com/items?itemName=VisualStudioProductTeam.MicrosoftVisualStudio2017InstallerProjects 설치가 완료 되면 다음과 같이 진행한다. 파일 &gt; 새로만들기 &gt; 프로젝트 을 선택한다. 기타 프로젝트 형식 &gt; Visual Studio Installer &gt; Setup Project를 선택한다. .url 파일과, .ico 파일은 해당 디렉토리를 선택한 후 우측 영역에서 마우스 우측을 눌러 컨텍스트 메뉴에서 Add &gt; File 에서 해당 파일을 선택해서 넣어주면 된다. Application Folder: .ico User’s Application Data Folder: 없음 User’s DeskTop: .url User’s Programs Menu: 없음 참고로 Application Folder 디렉토리는 마우스 우측을 눌러 컨텍스트 메뉴에서 Add Special Folder &gt; 사용자 응용프로그램 데이터 폴더 메뉴를 클릭하면 생성 된다. 빌드 버튼을 누르면 디폴트 경로인 debug 디렉토리에 .msi, .exe 설치 파일이 생성된다. .exe 파일 단독 설치시 이슈 .msi 설치파일은 전역으로 사용가능하지만 .exe 설치파일은 .msi 파일이 같은 경로에 있어야 실행되는 문제가 있었다.이 문제를 해결해 볼려고 여러가지로 테스트해서 다른 방안을 찾았긴 했지만 효율적으로 자체 내부 설정이나 컨버팅 하는 방법을 찾지 못했다.그래서 간단하게 처리할수 있는 방법으로 생각한게 msi2exe converter 툴이다. msi2exe converter 다운로드 다운로드: http://download.cnet.com/ImElfin-MSI2EXE-Converter/3000-2094_4-76020455.html 변환툴을 활용해서 .msi 파일을 .exe 파일로 변환하면 된다. 참조 http://www.doccabi.pe.kr/entry/%EB%B0%94%EB%A1%9C%EA%B0%80%EA%B8%B0-%EC%95%84%EC%9D%B4%EC%BD%98-%EC%84%A4%EC%B9%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%83%9D%EC%84%B1 http://infototal.tistory.com/entry/%EC%9D%B8%ED%84%B0%EB%84%B7-%EB%B0%94%EB%A1%9C%EA%B0%80%EA%B8%B0%EC%9D%B8-URL-%ED%8C%8C%EC%9D%BC%EC%9D%98-%ED%98%95%EC%8B%9D http://rocabilly.tistory.com/186 http://blog.naver.com/PostView.nhn?blogId=rickman2&amp;logNo=220652711833","categories":[{"name":"OS","slug":"OS","permalink":"https://woonyzzang.github.com/categories/OS/"},{"name":"Windows","slug":"OS/Windows","permalink":"https://woonyzzang.github.com/categories/OS/Windows/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://woonyzzang.github.com/tags/windows/"}]},{"title":"EcmaScript2015 Syntax","slug":"javascript-es6-syntax","date":"2017-04-18T14:44:36.000Z","updated":"2024-06-10T04:53:59.558Z","comments":true,"path":"2017/04/18/javascript-es6-syntax/","permalink":"https://woonyzzang.github.com/2017/04/18/javascript-es6-syntax/","excerpt":"","text":"ECMAScript2015(ES6) 기초 문법ECMAScript 2015에는 많은 기능들이 추가 되었는데 그 중에 몇가지 기본적인 문법들을 정리해 본다. let&#x2F;const에 의한 블록 스코프 Map&#x2F;Set&#x2F;WeakMap&#x2F;WeakSet에 의한 컬렉션 형을 정의하는 클래스 제너레이터&#x2F;for..of Promises Template String Literals 화살표 함수 모듈 let 키워드 가장 먼저 변수 선언에 대하여 알아보자. 기존 Javascript 에서는 var 로 거의 통일되다 시피 변수를 선언하였다.다만 var 의 문제점은 scope 에 있다.var 의 scope 는 function 안에서 모두 접근 하게 되는데, 이는 타 언어 출신의 개발자를 헷갈리게 만들고 자칫 잘못하면 엄청난 버그를 만들어내는 방식이다. 123456789101112131415161718var a = 1; // global variable function Test1() &#123; console.log(a); var b = 2; if (true) &#123; var c = 3; console.log(b); &#125; console.log(c);&#125; Test1();// 1// 2// 3 위와 같이 Test1() 함수에서 전역변수인 a를 호출하고 변수 b를 지정하였다.if 문안에서 변수 c를 지정하고 지역변수인 b를 호출하였다.그리고 if문 밖에서 변수 c를 호출하였다.이는 에러를 야기 시키지 않는가? 타 언어에서는 c가 if문 안에 있으니 undefined 라고 나올 수 있을꺼다 라고 하지만 자바스크립트에서는 그렇지 않다.자바스크립트에서 변수의 범위는 function 즉 , 최초의 부모함수 (여기서는 Test1 함수) 가 되기 때문에 해당 코드의 실행 결과로 1 , 2 ,3 이 나타난다. ES6 에서는이를 보완하기 위해 let 이라는 block scope 의 변수를 선언하는 형식을 만들었다. 1234567891011121314151617let a = 1;function Test1() &#123; console.log(a); let b = 2; if(true) &#123; let c = 3; console.log(b); &#125; console.log(c);&#125; Test1();// 1// 2// undefined var 를 let 으로 변경하였다. a 는 여전히 전역변수가 되어있고 b 는 Test1 함수내에 어디서든 호출이 가능하며,문제는 c 이다. 해당 함수를 실행하면 c는 나타나지 않는다.let 으로 변경한 지금 c 변수는 if 문 안에서만 통용되도록 변경되었다. 타 언어의 변수 scope 와 같아진것 이다.여기서 또 한가지 같은 범위 안이라면 var 는 이미 선언한 변수를 같은 이름으로 덮어 씌우는게 가능하다.하지만 let 은 그렇지 않다. 123456789var a = 1;var a = 2; console.log(a); // 2 let b = 1;let b = 2; console.log(b); // Type Error 위 코드 처럼 let 은 같은 범위내에서 같은 이름으로 덮어 씌우려 할 경우 Type Error 를 발생시킨다. Const 키워드 Const 키워드는 let 과 같이 block scope 를 가지며, let 과 다른점은 상수로 선언된다는 점이다.기존의 var 로 선언했을 시에는 프로그램 어디서나 해당 변수에 접근하여 값을 고칠 수 있다.하지만 const 로 선언한다면 상수로 선언되기에 값을 변경시에는 에러가 발생하게 된다. 12345678910111213var r = 4;var pi = 3.14;console.log(r * r * pi); // 50.24 pi = 2.14console.log(r * r * pi); // 34.24 const pi2 = 3.14;console.log(r * r * pi2); // 50.24 pi2 = 2.14; console.log(r * r * pi2); // Error 위 코드를 보면 var 로 선언한 pi 변수는 얼마든지 변경 할 수 있기에 단지 상수라고 생각하고 적어놨을 뿐 전혀 상수의 기능을 못 하고 있다.하지만 const 로 선언한 변수는 값의 변경을 시도 했을 때 읽기 전용 예외 가 발생하며 변경이 되지 않는다. 12345678910111213141516171819202122var a = &#123; name: &#x27;Tracer&#x27;&#125;;console.log(a.name); // Tracer var a = &#123; age: &#x27;12&#x27;&#125;;console.log(a.age); // 12const b = &#123; name: &#x27;Over&#x27;&#125;;console.log(b.name); // Over b.name = &#x27;Watch&#x27;;console.log(b.name); // Watch const b= &#123; name : &#x27;OverWatch&#x27; // Error&#125;;console.log(b.name); const 범위는 let 과 같으며 만약 객체를 const 로 선언했을 경우 객체안의 내용은 변경이 가능하지만 객체 자체를 재정의 하는 것은 불가능하다. …배열 연산자(Spread Operator) 기존 자바스크립트에서 배열 값을 인자로 넘길때는 apply 메소드를 사용하여 넘겼다.하지만 … 연산자를 사용하여 더욱 간단하게 인자값을 넘길 수 있다. 12345678function Test1(a,b) &#123; return a + b;&#125;; var data = [1,2]; console.log(Test1.apply(null,data)); // 3console.log(Test1(...data)); //3 … 연산자는 배열에 있는 값을 하나하나 꺼내서 개별적인 함수 인자로 만들어서 호출 한다. … 연산자를 응용하면 다음과 같이도 사용할 수 있다. 123456789101112131415let data1 = [1, 2, 3];let data2 = [4, 5, 6];let data3 = [...data1, ...data2, 7]; console.log(data3); // 1,2,3,4,5,6,7 data1.push(...data2); console.log(data1); // 1,2,3,4,5,6 function add (a, b, c, d, e, f) &#123; return a + b + c + d + e + f;&#125; console.log(add(...data1,...data2)); // 21 첫번째로 data3 배열은 data1 과 data2 의 배열을 포함시키는데 여기서 … 연산자를 사용하였다.두번째로 배열에 배열을 push 할때 기존의 Array.prototype.push.apply(arr1,arr2) 가 아닌 좀 더 깔끔하고 간결하게 push 사용이 가능하다.마지막으로 함수의 인자로 값을 넘길때 여러개의 배열을 … 연산자를 사용하여 넘길 수 있다. 배열 ES6 에서 간편해진 배열관련 문법들을 살펴보자.위 … 연산자를 활용하는 방법과 그 외 기존에 쓰던 방법을 더욱 간단하게 표현할 수 있도록 ES6는 많은 변화가 있다.먼저 배열에 값을 할당 할 때의 예제를 살펴보자. 1234567891011121314151617181920// ES5let array = [1,2,3];let a = array[0];let b = array[1];let c = array[2]; console.log(a,b,c); // 1 2 3 // ES6let array2 = [1,2,3];let d, e, f;[d,e,f] = array2; console.log(d,e,f); // 1 2 3 // ES6let array3 = [1,2,3];let [g,h,i] = array;console.log(g,h,i); // 1 2 3 배열 값을 할당하는 방법이 아주아주 간단해 진 걸 볼 수 있을 것이다. 여기서 배열 값의 건너뜀 과 응용하여 위에서 배운 … 연산자를 사용해보자. 12345678910111213141516let array = [1,2,3];let[a, ,b] = array;console.log(a,b); // 1,3 let array2 = [1,2,3];let [c, ...d] = array2;console.log(c); // 1console.log(d); // 2,3 let array3 = [1,2,3,4];let [e, , ...f] = array3;console.log(e); // 1console.log(f); // 3,4 위 코드를 보면 배열에 값을 지정할 때 중간값을 건너뛰는 것이 가능하다. 그리고 … 연산자를 이용하여 배열의 남은 값들을 다 포함시킬 수도 있고 , 역시 값을 건너뛰면서도 … 연산자가 사용가능 한 것을 볼 수 있다. 12345678910let array = [1,2];let [a, b, c=3] = array;console.log(a,b,c); //1,2,3function test1(a = 1, b = 2, c = 3) &#123; return a + b + c;&#125; console.log(test1()); // 6 첫번째 배열에서는 c에 기본값을 주고 출력하는 것을 볼 수 있다.그리고 함수의 인자값에도 기본값을 주고 출력이 가능한 것을 확인 할 수 있다. 객체 123456789101112131415161718192021222324252627282930//ES5 var Person = &#123; name: &#x27;Korea&#x27;, age: &#x27;5000&#x27;&#125;; var name = Person.name;var age = Person.age; console.log(name,age); // Korea , 5000//ES6//변수명이 객체 값과 같아야 한다.let Person2 = &#123; name2: &#x27;Korea&#x27;, age2: &#x27;5000&#x27;&#125;; let &#123;name2 , age2&#125; = Person2;console.log(name2,age2); // Korea , 5000//ES6//변수명을 다르게 주고 싶은 경우let Person3 = &#123; name3: &#x27;Korea&#x27;, age3: &#x27;5000&#x27;&#125;;let &#123;name3: x , age3: y&#125; = Person3;console.log(x,y); // Korea , 5000 ES6 에서는 객체 값을 변수에 할당할 때 변수를 객체 값의 이름과 같이 만들어서 할당하는 방법이 있다.그리고 마지막 부분은 변수의 이름을 객체 값과 같은 것이 아닌 다른 이름을 쓰고자 할때의 예제이다. Arrow function ES6 부터 Arrow function 이 추가 되었다.(파라미터)&#x3D;&gt; {함수 본체}; 1234567891011121314151617181920//ES5var Test1 = function(a,b) &#123; return a + b;&#125;;console.log(Test1(1,2)); // 3//ES6let Test2 = (a,b)=&gt; &#123; let result = a + b; return result;&#125;;console.log(Test2(1,2)); // 3//ES6let Test3 = (a, b)=&gt; (a + b);console.log(Test3(1,2)); // 3 코드를 보면 알 수 있듯이 함수를 간결하게 표현할 수 있도록 바뀌었다.함수의 return 문이 하나인 경우에 3번째 예제처럼 한줄로 만들 수도 있다. Arrow function 의 가장 중요한 특징은 this 값의 scope 변경이다. 예제를 살펴보자. 12345678910111213141516171819202122232425262728293031var a = 1;console.log(this === window); // trueconsole.log(this.a); // 1 function test1() &#123; console.log(this === window); // true&#125; var object1 = &#123; test: function() &#123; console.log(this === object1); // true (function() &#123; console.log(this === object1); // false console.log(this.a); // 1 &#125;()); &#125; , test2: function() &#123; console.log(this === object1); // true var that = this; (function() &#123; console.log(that === object1); // true &#125;)(); &#125;&#125;; test1();object1.test();object1.test2(); 위 코드는 es5 에서 this 의 scope 를 나타낸다. es5 에서는 this 의 scope 가 기본적으로 전역객체 (브라우저라면 window)를 가르키고 있으며 함수를 만들어도 this 값은 여전히 window 객체를 가리키고 있다.하지만 object 를 만들게 되면 this 는 자신을 호출한 object 를 가리키게 되며 object1 의 test 를 보면 알 수 있다.이런 부분은 callback 함수를 만들 었을 때 문제가 생긴다.test 의 내부 함수를 보면 해당 함수의 this 는 object1 을 가리키지 않고 여전히 window 객체를 가리키고 있다.왜 그런고 하니 내부함수는 객체의 멤버 메서드가 아닌 단지 호출된 함수 일 뿐이다.그럼 function 이라는 놈을 가지고 있는 부모 객체는 누구인가? 바로 전지전능한 window 객체가 된다.그렇기 때문에 내부 함수에서는 this 가 global 객체 를 가리키게 된다. 이를 해결하기 위해 object1 의 test2 함수처럼 함수 선언시에 this 를 임의의 변수에 넣어서 쓰는 방법을 사용한다.( 보통 that 또는 self , _this 등의 이름을 쓴다. ) 그리고 내부 함수에서는 이를 호출하여 사용하게 되는데 , arrow function 에서는 이런 부분이 해결된다. 위 코드의 object1 을 arrow function 을 이용하여 만들어 보자. 123456789101112131415161718192021let a = 1;let object1 = &#123; test: function() &#123; console.log(this === object1); // true (() =&gt; &#123; console.log(this === object1); // true console.log(this.a); // undefined &#125;)(); &#125; , test2: function() &#123; console.log(this === object1); // true (() =&gt; &#123; console.log(this === object1); // true &#125;)(); &#125;&#125;;object1.test();object1.test2(); 코드의 결과를 보면 내부 함수의 this 가 가리키는 곳이 window 가 아닌 object1 으로 바뀌었다.이는 이전의 this 범위와 다르게 자신을 둘러싸는 문맥의 this 값을 가진다.참고로 Arrow function 은 new 연산자를 사용할 수 없다. 객체 리터럴 ES6 에서 객체 리터럴로 프로퍼티를 생성하는 새로운 구문이 있다. 123456789101112let first = &#x27;one&#x27;;let second = &#x27;two&#x27;; let object = &#123;first, second&#125;;console.log(object.first); // oneconsole.log(object.second); // two let third = &#x27;three&#x27;;let object2 = &#123;object , third&#125;;console.log(object2.object.first); // oneconsole.log(object2.object.second); // twoconsole.log(object2.third); // three 2진수 , 8진수 표현 방식 ES6 에서의 2진수와 8진수 표현 방식을 보자. 예전에는 자바스크립트 만으로는 2진수를 나타낼 방법은 없었다.하지만 ES6 에서는 숫자앞에 0b 를 붙이면 자바스크립트 엔진이 2진수로 처리하게 된다.더불어 8진수를 표현할 때 숫자 앞에 0을 붙여서 표기를 하였다. 하지만 이는 초심자에게 헷갈릴 수 있다고 판단, 0 이 아닌 0o 를 붙이는 것 으로 변경되었다. 1234567891011121314151617181920//ES6 2진수 표현let a = 0b00001111;let b = 15;console.log(a === b); //trueconsole.log(a); //15//ES5 8진수 표현var aa = 017;var bb = 15;console.log(aa === bb); //trueconsole.log(aa); //15//ES6 8진수 표현let aaa = 0o17;let bbb = 15;console.log(aaa === bbb); //trueconsole.log(bbb); //15 참조 http://alexband.tistory.com/37","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Javascript","slug":"Frontend/Javascript","permalink":"https://woonyzzang.github.com/categories/Frontend/Javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://woonyzzang.github.com/tags/js/"},{"name":"es6","slug":"es6","permalink":"https://woonyzzang.github.com/tags/es6/"}]},{"title":"Node.js NPM CLI","slug":"node-npm-cli","date":"2017-04-13T14:39:15.000Z","updated":"2024-06-07T09:27:28.346Z","comments":true,"path":"2017/04/13/node-npm-cli/","permalink":"https://woonyzzang.github.com/2017/04/13/node-npm-cli/","excerpt":"","text":"NPM(Node Package Manager) CLI 명령어npm(Node Package Manager)은 두가지의 주요 기능을 지니고 있다. NPMSearch 에서 탐색 가능한 Node.js 패키지&#x2F;모듈 저장소 Node.js 패키지 설치 및 버전 &#x2F; 호환성 관리를 할 수 있는 커맨드라인 유틸리티 npm 명령어는 명령 프롬프트에 입력하는 커맨드라인 명령어로, 다양한 명령어가 많지만, 그중에서도 자주 쓰이는 것들에 대해 추스려 정리한다. npm 기본 명령어 123$ npm -v 혹은 npm --version # npm 버전확인(npm이 제대로 설치되있는지 확인시 사용가능)$ npm i npm -g # npm 구버전 최신버전으로 업데이트$ npm help 혹은 npm -h # npm 명령어에 대한 설명 npm 설치 관련 명령어 12345678$ npm init # package.json 파일 생성(새로운 프로젝트나 패키지를 만들 때 사용)$ npm i 혹은 install -g &#123;&#123;package module&#125;&#125; # 전역 패키지 설치$ npm i 혹은 install &#123;&#123;package module&#125;&#125; # 프로젝트내에 패키지 설치$ npm i 혹은 install &#123;&#123;package module&#125;&#125; --save 혹은 -S # package.json 파일에 dependencies로 패키지 설치(필수 패키지일 경우)$ npm i 혹은 install &#123;&#123;package module&#125;&#125; --save-dev 혹은 -D # package.json 파일에 devDependencies로 패키지 설치(개발용 패키지일 경우)$ npm un 혹은 uninstall &#123;&#123;package module&#125;&#125; # 패키지 삭제 $ npm update &#123;&#123;package module&#125;&#125; # 설치한 패키지 업데이트$ npm dedupe # 중복된 패키지들 정리(가끔 사용하면 용량을 줄일수 있다) npm 조회 관련 명령어 1234567$ npm root # node_modules의 위치$ npm outdated # 오래된 패키지가 있는지 알려줌(오래되었고 package.json에 적어둔 버전 범위와 일치하면 빨간색으로, 오래되었지만 버전 범위와 일치하지 않으면 노란색으로 표시)$ npm list 혹은 npm ls # 설치한 패키지 목록 조회$ npm ls -g --depth=0 # 설치한 전역 패키지 상위 뎁스 목록 조회$ npm search &#123;&#123;package module&#125;&#125; # 패키지 검색(처음 이용 할 때 메모리를 굉장히 많이 잡아 먹는다. 클라우드 IDE를 사용하거나 서버에 램이 1G 정도라면 매우 오래걸리거나 에러가 난다. 그럴경우 https://npmsearch.com/ 에서 검색을 하면 된다.)$ npm owner # 패키지의 작성자 확인$ npm bugs # 버그가 발생했을 때 어떻게 패키지의 작성자 에게 연락을 취할지 알려준다.(주로 Github의 issues 탭을 연다.) npm 실행 관련 명령어 12345$ npm start # package.json의 scripts에 있는 start 명령어를 실행(만약 start 명령어를 따로 설정하지 않았다면 node server.js가 실행된다)$ npm stop # npm start 했던 것을 멈춤$ npm restart # npm stop 후에 다시 npm start$ npm test는 # package.json의 scripts에 있는 test 명령어를 실행합니다.$ npm run # 그 이외의 scripts를 실행(예를 들어 scripts에 build 명령어가 있다하면, npm run build 명령어를 실행하면 된다) npm 설정 관련 명령어 123$ npm cache # npm 내의 cache를 보여준다.(만약 npm에 문제가 생기거나 하면 제일 먼저 하는 게 npm cache clean으로 cache를 삭제할 수 있다)$ npm rebuild # npm을 다시 설치(에러가 발생했을 시 주로 npm cache clean을 한 후 이 명령어를 쳐서 재설치할 수 있다)$ npm config # npm의 설정을 조작(npm config list 하면 현재 설정들을 볼 수 있고, npm set [이름] [값], npm get [이름]으로 속성을 설정하거나 조회할 수 있다) npm 로그인 관련 명령어 123$ npm adduser 혹은 npm login # npm에 회원가입할 시 사용.(로그인도 가능하다.)$ npm logout # logout할 때 사용.$ npm whoami # 로그인한 상태라면 자신의 아이디를 알려준다. npm 출시 관련 명령어 1234567$ npm registry # 출시된 패키지들에서 중복된 이름이 있는지 확인$ npm publish # 패키지를 직접 출시하거나 버전 업그레이드를 할 때 사용(.gitignore 또는 .npmignore 파일에 적혀있지 않은 파일들은 npm 저장소에 업로드되어 출시된다. 단, 이 명령어를 사용하려면 npm에 로그인한 상태여야 한다. 그리고 패키지의 이름은 선점하는 사람이 계속 쓰기 때문에 이름을 선점하는 것도 중요하다.)$ npm deprecate # 이미 출시한 패키지를 사용하지 않도록 권고(자신이 어떤 버전을 출시했는데 치명적인 버그가 있다면 이 명령어를 사용해서 다른 사람들에게 사용하지 말도록 알려줄 수 때 사용.)$ npm unpublish # 출시한 패키지를 다시 삭제(deprecate를 쓰는 게 나을 수 있는게 이미 자신의 패키지를 다운로드한 사람들에게 피해를 입힐 수 있다)$ npm star # 자신이 좋아하는 패키지를 표시하는 기능(star이 많을 수록 인기 패키지이기도 하다.)# npm starts # 특정 사람이 star한 패키지 목록 확인$ npm version # 버전 업데이트를 할 때 사용 참조 https://www.zerocho.com/category/NodeJS/post/58285e4840a6d700184ebd87","categories":[{"name":"Backend","slug":"Backend","permalink":"https://woonyzzang.github.com/categories/Backend/"},{"name":"Node","slug":"Backend/Node","permalink":"https://woonyzzang.github.com/categories/Backend/Node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://woonyzzang.github.com/tags/node/"}]},{"title":"Mac Bootcamp 설치하기","slug":"mac-bootcamp","date":"2017-04-12T13:33:41.000Z","updated":"2024-06-07T09:27:28.342Z","comments":true,"path":"2017/04/12/mac-bootcamp/","permalink":"https://woonyzzang.github.com/2017/04/12/mac-bootcamp/","excerpt":"","text":"시에라(Sierra) 부트캠프 윈도우 10 설치부트캠프란 맥에 윈도우를 설치해서 멀티부팅을 사용할 수 있게 제공 해주는 도구 이다.Mac OS 시에라(Sierra) 버전에서 부트캠프 윈도우10을 설치한 내용을 정리한 사항이다.설치 전 부트캠프 자료를 찾아보니 엘 캐피탄 이상 버전부터는 USB 없이 부트캠프 설치가 가능하다고 한다. 윈도우 iso 이미지 선택 및 윈도우 파티션 용량 설정iso 이미지는 보통 알아서 자동으로 선택이 되지만 필요에 따라 ‘선택’ 버튼을 눌러 파인더에서 파일을 지정할 수도 있다.변경된 방식에서는 USB를 이용하지 않기 때문에 바로 파티션 용량을 선택을 하게 되어 있다.파티션 용량은 윈도우 사용 목적에 따라 다르겠지만, 은행, 오피스 사용 등 기본적인 용도라면 60GB 정도면 적당하다. 만약 부트캠프를 진행할 경우 윈도우 설치시 이미지가 맥에 가상디스크로 마운트 되어 있다면 오류가 발생할 수 있다.오류가 발생하면 윈도우 이미지파일이 마운트가 되어 있는지 확인 후 마운트 되어 있다면 언마운트를 한 후 진행해야 다음 단계로 넘어갈 수 있다. 윈도우 OS 설치윈도우 설치 과정 중 설치 유형 &gt; 사용자 지정(고급) 선택시 기존 방식과 다른 부분은 파티션 선택 단계이다.확인 해 보면 변경된 방식에선 기존 방식에선 없던 파티션(OSXRESERVED)이 하나 더 존재한다.이 파티션은 윈도우 설치 이미지 및 드라이버 등을 담은 ‘지원소프트웨어’가 포함된 파티션이다.(절대 이 파티션을 삭제 하면 안된다)‘BOOTCAMP’ 파티션을 선택하고 ‘포맷’을 클릭하여 포맷한 다음 다음 단계로 넘어가면 된다. [경우에 따라 위에 진행 단계 없이 진행되는 경우도 있다.] 지원소프트웨어 설치윈도우 설치가 완료되면 재부팅을 한 후 계정 및 사용자 설정을 한 후 바탕화면이 나오게 되는데 기본 드라이버가 제대로 안잡혀 있다.부트캠프로 윈도우 10을 설치한 후에 드라이버를 설치하기 위해서는 다음의 방법대로 해주면 된다.윈도우 10으로 부팅한 후, 탐색기를 열어보면 c:\\ 드라이브와 d:\\ 드라이브가 있는데 d:\\드라이브인 OSXRESERVED에 들어가서 BOOTCAMP 디렉토리에서 Setup.exe 을 실행하면 드라이버가 설치된다. 설치 완료 후 맥으로 재부팅하면 OSXRESERVED 드라이브는 사라진다. 부팅 순서 변경하기부트캠프로 설치가 정상적으로 완료되면 맥은 기본으로 부팅될 디스크를 부트캠프가 설치된 파티션으로 자동으로 설정 해버린다. 따라서 사용자가 따로 부팅디스크 설정을 하지 않으면 기본으로 윈도우로 부팅이 되어 버리게 된다.부팅 순서를 변경할려면 아래와 같이 4가지 방법이 있다. 맥 시동 시 option 을 눌러 시작디스크 설정 창을 띄운 후 OSX 가 설치된 디스크를 선택(한번은 맥으로 부팅되지만 재 부팅시 다시 윈도우로 부팅) 윈도우로 부팅 후 하단 부트캠프 아이콘에서 OSX로 재부팅을 선택(한번은 맥으로 부팅되지만 재 부팅시 다시 윈도우로 부팅) 윈도우로 부팅 후 부트캠프 제어판 &gt; 부팅될 디스크를 OSX 디스크로 선택(윈도우 설정: 영구적으로 맥으로 계속 부팅) OSX로 부팅 후 시스템 환경설정 &gt; 시동디스크 &gt; OSX 디스크를 선택(맥 설정: 영구적으로 맥으로 계속 부팅) 참조 http://blog.naver.com/PostView.nhn?blogId=hankboy&amp;logNo=220646443078&amp;categoryNo=0&amp;parentCategoryNo=0&amp;viewDate=&amp;currentPage=1&amp;postListTopCurrentPage=1&amp;from=postView http://m.blog.naver.com/musediet/220588871493 http://blog.naver.com/hankboy/70185547840","categories":[{"name":"OS","slug":"OS","permalink":"https://woonyzzang.github.com/categories/OS/"},{"name":"Mac","slug":"OS/Mac","permalink":"https://woonyzzang.github.com/categories/OS/Mac/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://woonyzzang.github.com/tags/mac/"}]},{"title":"ionic-v1 disabled tel anchor 이슈","slug":"ionic-v1-disabled-tel-anchor","date":"2017-04-12T13:31:46.000Z","updated":"2024-06-07T09:27:28.309Z","comments":true,"path":"2017/04/12/ionic-v1-disabled-tel-anchor/","permalink":"https://woonyzzang.github.com/2017/04/12/ionic-v1-disabled-tel-anchor/","excerpt":"","text":"ionic v1 Disable Telephone Anchor(자동생성 tel 링크 태그 비활성화 하기)iOS 계열에서 나타나는 이슈로 iOS UI WebView 에서 특정 형식의 데이터(숫자)를 감지하여 전화 연결 태그(tel)를 자동으로 추가시켜 렌더링이 된다. 마크업 코드 12&lt;span&gt;테스트&lt;/span&gt;&lt;span&gt;9578867&lt;/span&gt; 렌더링 코드 12&lt;span&gt;테스트&lt;/span&gt;&lt;span&gt;&lt;a href=&quot;tel:9578867&quot; x-apple-data-detectors=&quot;true&quot; x-apple-data-detectors-type=&quot;telephone&quot; x-apple-data-detectors-result=&quot;0&quot;&gt;9578867&lt;/a&gt;&lt;/span&gt; 의도치 않게 자동 생성되는 전화 연결 링크 태그를 비활성화 할려면 index.html에 아래 코드를 &lt;head&gt; 태그 안에 삽입하면 해결된다. 1&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt; a 태그일 경우에 직접 비활성화 할 경우에는 x-apple-data-detectors 속성을 사용하면 해결된다. 1&lt;a href=&quot;#&quot; x-apple-data-detectors=&quot;false&quot;&gt;666-777-777&lt;/a&gt; 참조 https://forum.ionicframework.com/t/angular-binding-scope-string-with-forward-slash-and-numbers-rerendering-incorrectly/16800","categories":[{"name":"App","slug":"App","permalink":"https://woonyzzang.github.com/categories/App/"},{"name":"Ionic","slug":"App/Ionic","permalink":"https://woonyzzang.github.com/categories/App/Ionic/"}],"tags":[{"name":"ionic v1","slug":"ionic-v1","permalink":"https://woonyzzang.github.com/tags/ionic-v1/"}]},{"title":"Webstorm CSS Analysis Path","slug":"webstorm-css-analysis-path","date":"2017-04-01T13:47:27.000Z","updated":"2024-06-05T06:56:19.450Z","comments":true,"path":"2017/04/01/webstorm-css-analysis-path/","permalink":"https://woonyzzang.github.com/2017/04/01/webstorm-css-analysis-path/","excerpt":"","text":"Webstorm CSS Analysis background 이미지 경로 에러 해결하기webstorm 에서 CSS 코드 작성시 이미지 경로를 절대경로로 작업하다보면 CSS의 Analysis 밸리데이션 기능이 루트 디렉토리를 제대로 찾지 못해 아래와 같이 에러 표시를 나타내게 될 때가 있다. 실제 개발적용시에는 문제가 없지만 왠지 에러 표시가 계속 신경쓰이거나 해결하고 하고 싶으면 경로가 어디에서 시작하는지 webstorm에게 알려줘야 한다. 참조 http://stackoverflow.com/questions/29805943/set-background-css-image-in-phpstorm-cannot-resolve-file","categories":[{"name":"Editor","slug":"Editor","permalink":"https://woonyzzang.github.com/categories/Editor/"},{"name":"Webstorm","slug":"Editor/Webstorm","permalink":"https://woonyzzang.github.com/categories/Editor/Webstorm/"}],"tags":[{"name":"webstorm","slug":"webstorm","permalink":"https://woonyzzang.github.com/tags/webstorm/"}]},{"title":"Windows Cygwin","slug":"windows-cygwin","date":"2017-03-30T14:10:42.000Z","updated":"2020-09-05T13:07:56.163Z","comments":true,"path":"2017/03/30/windows-cygwin/","permalink":"https://woonyzzang.github.com/2017/03/30/windows-cygwin/","excerpt":"","text":"Windows 환경에서 cygwin으로 Linux CLI 명령어 사용하기cygwin은 Windows 환경에서 콘솔창으로 Linux 명령과 bash sell 환경을 제공하여 사용 할 수 있게 해주는 프로그램이다. Unix, Linux, mac OSX 의 환경의 콘솔 명령어는 Unix를 기반으로 두고 있기 때문에 동일한 CLI를 제공한다.하지만 Windows는 Unix를 기반으로 두고 있지 않고 MS 자체 console CLI 환경을 제공하다보니 Unix 계열의 CLI 명령어와 다르다.Unix, Linux, Ubuntu, Mac 환경의 CLI를 접하기전 학습의 목적으로 cygwin을 설치하여 WIndows 환경에서 미리 CLI를 사용해볼 수 있고,나아가서 원격머신 흔히 웹 서버로 사용할 머신이 windows 계열일때의 불편을 해소하고자 할 때 활용 할 수 있다. cygwin 설치아래 다운로드 경로에서 Windows OS 환경(x32 or x64)에 맞는 버전을 다운로드 받는다. 다운로드:https://cygwin.com/install.html 설치 시 미러링 사이트에서 받을지 묻는 화면에선 ftp://ftp.kaist.ac.kr 를 선택해주면 된다.(다운 속도가 빠르다.) apt-cyg 패키지 관리자 설치cygwin 설치 후 apt-cyg를 설치하면 손쉽게 패키지 관리를 할수 있다 마치 node.js의 npm과 같다고 생각하면 된다. 참조:https://github.com/transcode-open/apt-cyg cygwin 콘솔창에서 아래 명령어를 입력한다. 12$ lynx -source rawgit.com/transcode-open/apt-cyg/master/apt-cyg &gt; apt-cyg$ install apt-cyg /bin lynx: command not found 에러시 해결12$ lynx -source rawgit.com/transcode-open/apt-cyg/master/apt-cyg &gt; apt-cyg-bash: lynx: command not found 만약 apt-get 설치시 아래와 같은 에러가 발생한다면 cygwin 설치시 lynx 패키지를 설치를 하지 않았기 때문에 not found 에러가 나는 것이다.다시 cygwin를 인스톨을 진행하고 Select Packages 화면에서 lynx 패키지를 찾아 kepp을 해제후 설치를 다시 진행하면 된다. apt-cyg 명령어12345678910$ apt-cyg install &#123;&#123;패키지&#125;&#125; # 패키지 설치$ apt-cyg remove &#123;&#123;패키지&#125;&#125; # 패키지 삭제$ apt-cyg update # 설치된 패키지 전체 최신 버전 업데이트$ apt-cyg update &#123;&#123;패키지&#125;&#125; # 설치한 패키지의 최신버전 업데이트$ apt-cyg list # 설치된 패키지 목록$ apt-cyg search &#123;&#123;패키지&#125;&#125; # 패키지 검색ex)$ apt-cyg install nano # nano 패키지 설치$ nano # nano 패키지 실행 한글 설정cygwin을 설치하고 바로 쓰면 한글 파일명이나 디렉토리명이 물음표(?)로 표시되고, 한글 입력도 잘 되지 않는다.그래서 설치 후 한글 설정 작업이 필요하다. c:\\cygwin\\Cygwin.bat 파일을 열어 굵은 글씨로 된 문장을 추가 한다. 123...set CYGWIN=ttybash --login -i cygwin콘솔에서 vi로 ~/.bashrc 열어 아래 내용을 맨 아래에 넣는다. 1alias ls=&#x27;ls -ahF --color=tty --show-control-char&#x27; cygwin 콘솔에서 vi로 ~/.inputrc 를 열어 아래 내용을 맨 아래에 추가한다. 123set meta-flag onset convert-meta offset output-meta on 참조 https://www.cygwin.com/ https://opentutorials.org/course/128/10123 http://blog.xcoda.net/22","categories":[{"name":"OS","slug":"OS","permalink":"https://woonyzzang.github.com/categories/OS/"},{"name":"Windows","slug":"OS/Windows","permalink":"https://woonyzzang.github.com/categories/OS/Windows/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://woonyzzang.github.com/tags/windows/"}]},{"title":"Mac Homebrew","slug":"mac-homebrew","date":"2017-03-30T14:07:15.000Z","updated":"2020-09-05T13:07:55.874Z","comments":true,"path":"2017/03/30/mac-homebrew/","permalink":"https://woonyzzang.github.com/2017/03/30/mac-homebrew/","excerpt":"","text":"Homebrew(홈브류)로 OS X 패키지 관리하기OS X 은 기본적으로 wget 명령을 내장하고 있지 않아 기본으로 제공하지 않는 패키들이 필요할 경우 수동으로 하나씩 다운받아 설치해야 한다.하지만 macOS 환경에서 이런것들을 편리하게 관리할수 있는 패키지 관리자가 있는데 그중 하나가 Homebrew란 패키지 관리자이다. Homebrew 설치Terminal.app을 실행시킨 후 에서 아래 CLI 명령어를 실행한다. 1$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 다만, 정상 작동을 위해서는 Xcode가 설치되어 있거나 Xcode 용 Command Line Tools 가 설치되어 있어야 한다. Homebrew 설치후에는, 터미널에서 brew -v 명령 (또는 brew –version) 으로 설치 버전을 확인할 수 있다.Homebrew 를 설치했으면 원하는 패키지를 brew 명령을 통해 설치할 수 있다. Homebrew 명령어123456789101112131415$ brew -v # Homebrew 버전확인$ brew update # Homebrew 업데이트$ brew install &#123;&#123;패키지명&#125;&#125; # 패키지 설치$ brew search &#123;&#123;패키지명&#125;&#125; # 패키지 검색$ brew remove &#123;&#123;패키지명&#125;&#125; # 패키지 삭제$ brew info &#123;&#123;패키지명&#125;&#125; # 패키지 정보$ brew upgrade &#123;&#123;패키지명&#125;&#125; # 설치한 패키지의 최신버전 설치$ brew list 또는 brew ls # 설치한 패키지 목록$ brew doctor # 시스템에 문제가 있는지 확인$ brew outdated # 내가 설치한 패키지 목록의 이후 버전이 나왔는지 확인$ brew cleanup # 패키지의 모든 과거버전을 제거함ex)$ brew install htop-osx # htop-osx 패키지 설치$ htop-osx # htop-osx 패키지 실행 Homebrew를 설치해서 사용하면 OS X 에서 기본 제공하지 않는 wget 같은 명령외에도 맥용 앱이라던가, 다양한 프레임워크 등등 정말 수많은 패키지들을 관리할 수가 있어 MacOS 에서의 개발 환경이 편리해진다. 참조 https://brew.sh/index_ko.html https://opentutorials.org/course/128/11129","categories":[{"name":"OS","slug":"OS","permalink":"https://woonyzzang.github.com/categories/OS/"},{"name":"Mac","slug":"OS/Mac","permalink":"https://woonyzzang.github.com/categories/OS/Mac/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://woonyzzang.github.com/tags/mac/"}]},{"title":"HTTPS OpenSSL 인증서 테스트 구현","slug":"https-openssl","date":"2017-03-23T11:53:22.000Z","updated":"2024-06-07T09:27:28.305Z","comments":true,"path":"2017/03/23/https-openssl/","permalink":"https://woonyzzang.github.com/2017/03/23/https-openssl/","excerpt":"","text":"HTTPS 서버 구축시 인증서 테스트 구현HTTS는 HTTP 보안 프로토콜이다. http로 전송되는 데이터를 암호화해서 보안을 위해서 최근에는 로그인이나 API 등 보안에 민감한 요청은 https를 사용한다. https에서 s는 secure socket을 사용을 의미한다. https는 인증서를 등록해서 사용하는데 최신 브라우저에서는 https로 접근하면 보안 프로토콜을 사용한다는 표시를 한다거나 인증서 확인을하는 작업등을 한다.이런 이유 때문에 클라이언트 프로그램이 https로 요청하면 인증처리하는 과정을 거쳐야하기 때문에 일반 http 요청과 다른 과정이 필요하다. 개발할 때 https를 테스트하기 위해서 https에 사용되는 인증서를 구입해서 개발할 수는 없다. https에 사용하기 위해서 인증서를 만들더라도 https는 하나의 도메인만 적용되고 그 가격도 너무 고가이기 때문에 개발용 서버에 https 인증서를 구입하는 것은 효율적이지 못하기 때문이다. 그럼 어떻게 개발용으로 https 서버를 구현할 수 있을까? 다행히 OpenSSL을 사용하면 자체 인증서를 만들 수 있다. 하지만 공인으로 등록된 인증서가 아니기 때문에 OpenSSL로 만든 인증서는 실제 서비스를 하는데는 무리가 있다. 하지만 개발용으로는 충분히 사용 가능하다. 아래에 OpenSSL 바이너리형은 윈도우 전용이며, OS 환경에 맞는 버전을 다운로드 받으면 된다. OpenSSL 바이너리형: http://code.google.com/p/openssl-for-windows/downloads/listOpenSSL 설치형: https://www.openssl.org/ OpenSSL 사용법 12// 다운받은 OpenSSL 압축을 해제 하고 bin 디렉토리에서 명령어를 입력한다. $ openssl-0.9.8k_X64&gt;bin&gt; &#123;&#123;명령어 실행&#125;&#125; 개인키 발급 우리가 첫번째 해야할 일은 개인키를 발급하는 것이다. OpenSSL에서 genrsa는 키를 RSA 알고리즘으로 만들겠다는 말이고 1024는 RSA 알고리즘을 1024로 만들겠다는 말이다. 1$ openssl genrsa 1024 &gt; key.pem 이렇게 만들어진 파일을 열어보면 RSA로 PRIVATE KEY로 만들어진 것을 확인할 수 있다. Cert 인증서 파일 생성하기 다음은 개인키를 가지고 디지털 인증서를 만들자. 1$ openssl req -x509 -new -key key.pem &gt; cert.pem 인증서를 만들기 위해서는 몇가지 기입해야할 정보가 있다. 공인 인증기관에서 만드는 곳에서도 이와 동일한 항목들을 받아서 만들어지는데 OpenSSL로 인증서를 만드는 기관은 바로 자신이므로 항목에 입력을하면 디지털 인증서가 만들어진다. 물론 공인된 인증서는 아니다. 참조 http://blog.saltfactory.net/implements-nodejs-based-https-server/","categories":[{"name":"Tools","slug":"Tools","permalink":"https://woonyzzang.github.com/categories/Tools/"},{"name":"OpenSSl","slug":"Tools/OpenSSl","permalink":"https://woonyzzang.github.com/categories/Tools/OpenSSl/"}],"tags":[{"name":"server","slug":"server","permalink":"https://woonyzzang.github.com/tags/server/"},{"name":"openssl","slug":"openssl","permalink":"https://woonyzzang.github.com/tags/openssl/"}]},{"title":"Javascript Module Pattern","slug":"javascript-module-pattern","date":"2017-03-21T14:43:47.000Z","updated":"2024-06-10T04:53:59.570Z","comments":true,"path":"2017/03/21/javascript-module-pattern/","permalink":"https://woonyzzang.github.com/2017/03/21/javascript-module-pattern/","excerpt":"","text":"JavaScript 모듈 패턴을 이용한 window 객체의 프로퍼티로 추가각각의 자바스크립트 파일을 모듈화 하여, 즉시 실행 함수로 실행하고, 실행하여 생성된 생성자 함수를 전역 객체인 window 객체의 프로퍼티로 추가하여 접근하는 방법이다.export를 통해 프로퍼티를 추가할수 있다. 12345678(function(exports) &#123; exports.module = function() &#123; console.log(&#x27;hello&#x27;); &#125;;&#125;)(window);// outputmodule(); // hellow 참조 http://asfirstalways.tistory.com/236","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Javascript","slug":"Frontend/Javascript","permalink":"https://woonyzzang.github.com/categories/Frontend/Javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://woonyzzang.github.com/tags/js/"}]},{"title":"Javascript include","slug":"javascript-include","date":"2017-03-21T14:29:25.000Z","updated":"2024-06-10T04:53:59.565Z","comments":true,"path":"2017/03/21/javascript-include/","permalink":"https://woonyzzang.github.com/2017/03/21/javascript-include/","excerpt":"","text":"JavaScript 외부 소스 코드 삽입eval() eval() 는 전역 객체의 함수 프로퍼티 이다.eval() 함수를 실행하면 자바스크립트 소스 코드를 동적으로 로드하여 실행할 수 있다.하지만 eval 함수로는 보안상 위험이 존재하기 때문에 안티패턴에 속한다.그리고 eval 함수 이외에도 동적으로 자바스크립트 소스 코드를 실행 할 수 있는 방법이 많이 존재하기 때문에 권장되지 않는 방법이다.eval 함수의 파라미터로 넘어온 String 인자는 Javascript Parser에 의해 파싱되고 실행된다. jax Loading 12345678910111213function require(url) &#123; $.ajax(&#123; url: url, dataType: &#x27;script&#x27;, async: false, success: function() &#123; //code... &#125;, error: function() &#123; throw new Error(&#x27;Coild not load script&#x27; + url); &#125; &#125;);&#125; jQuery Loading jQuery를 사용하면 한줄로 외부 자바스크립트 소스를 가져올 수 있다. 123$.getscript(&#x27;myscript.js&#x27;, function() &#123; console.log(&#x27;myscript.js loading!!&#x27;);&#125;); JavaScript JavaScript 만으로는 createElement, appendChild 등 메소드를 이용하여 동적으로 html 태그를 추가하여 외부소스코드를 삽입할 수 있다. 12345678910function includeJs(filePath) &#123; var js = document.createElement(&#x27;script&#x27;); js.type = &#x27;text/javascript&#x27;; js.src = filePath; document.body.appendChild(js);&#125;includeJs(&#x27;/path/myscript.js&#x27;); Require JS Require JS 모듈을 사용하면 보다 간편하게 인클루드 기능을 사용 할수 있다. require.js: http://requirejs.org/ ECMA Script 6 ECMA Script 6 에서는 import 라는 문법을 제공한다. 1234567import name from &#x27;module-name&#x27;;import &#123; member &#125; from &#x27;module-name&#x27;;import &#123; member as alias&#125; from &#x27;module-name&#x27;;import &#123; member1, member2 &#125; from &#x27;module-name&#x27;;import &#123; member1, member2 as alias2, [...] &#125; from &#x27;module-name&#x27;;import name, &#123; member1, [ , [...]] &#125; from &#x27;module-name&#x27;;import &#x27;module-name&#x27; as name; 참조 http://asfirstalways.tistory.com/236","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Javascript","slug":"Frontend/Javascript","permalink":"https://woonyzzang.github.com/categories/Frontend/Javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://woonyzzang.github.com/tags/js/"}]},{"title":"Windows Folder Delete","slug":"windows-folder-del","date":"2017-03-21T13:32:04.000Z","updated":"2020-09-05T13:07:56.170Z","comments":true,"path":"2017/03/21/windows-folder-del/","permalink":"https://woonyzzang.github.com/2017/03/21/windows-folder-del/","excerpt":"","text":"파일 항목을 삭제할 수 없습니다. [원본 파일이나 디스크에서 읽을 수 없습니다] 삭제 오류 시 삭제 방법윈도우 에서 폴더 삭제 시 파일명이 길거나 파일 항목을 삭제할수 없습니다란 삭제 오류 경고창이 나면서 삭제가 안되는 경우가 있다.이런 경우에 cmd창에 아래 명령어를 입력한다. 1$ rmdir /s &#123;폴더명&#125; 이후 계속하시겠습니까?란 문구가 나오면 y를 선택한다.그러면 삭제오류 때문에 삭제가 안되된 폴더가 삭제 된다. 첨조 http://m.blog.naver.com/jh4l2656/70134923730","categories":[{"name":"OS","slug":"OS","permalink":"https://woonyzzang.github.com/categories/OS/"},{"name":"Windows","slug":"OS/Windows","permalink":"https://woonyzzang.github.com/categories/OS/Windows/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://woonyzzang.github.com/tags/windows/"}]},{"title":"Javascript Form Parameter","slug":"javascript-form-parameter","date":"2017-03-21T13:11:59.000Z","updated":"2024-06-10T04:53:59.560Z","comments":true,"path":"2017/03/21/javascript-form-parameter/","permalink":"https://woonyzzang.github.com/2017/03/21/javascript-form-parameter/","excerpt":"","text":"JavaScript form parameter 데이터값 전송시 처리 방법form은 서버에 url 전송시 action에 파라미터값까지 처리하면 브라우저에서 제대로 작동하지 않는다.사용자가 입력하거나 선택하는 정보는 아니지만 폼 전송이 같이 전송해줘야 하는 정보를 담기 위해서 히든 필드(Hidden Field)를 사용해야 한다.hidden 필드는 화면에 출력되는 부분이 아니기 때문에 브라우저에 아무런 영향을 미치지 않지만 값을 가지고 있다. 다음 예제 코드들을 한번 살펴보자. form 잘못된 예 123&lt;form method=&quot;get&quot; action=&quot;/lib/ajax.class.member.php?action=find-user&amp;search_nick=테스트&quot; id=&quot;searchConnectorForm&quot;&gt; ...&lt;/form&gt; 위와 같이 하면 브라우저에 출력되는 form 태그는 &lt;form method&#x3D;”get” action&#x3D;”&#x2F;lib&#x2F;ajax.class.member.php”&gt; 이렇게 파라미터값이 빠진 채로 출력되게 된다. form 올바른 예 12345&lt;form method=&quot;get&quot; action=&quot;/lib/ajax.class.member.php&quot; id=&quot;searchConnectorForm&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;find-user&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;search_nick&quot; value=&quot;테스트&quot;&gt; ...&lt;/form&gt; 처리방법은 파라미터값을 전달하려면 &lt;input type&#x3D;”hidden”&gt; 태그를 추가해서 넣으면 된다. 전체 예제 코드는 다음과 같다. 123456789101112131415&lt;form method=&quot;get&quot; action=&quot;/lib/ajax.class.member.php?&quot; id=&quot;searchConnectorForm&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;find-user&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;search_nick&quot;&gt; &lt;fieldset&gt; &lt;legend class=&quot;blind&quot;&gt;회원겁색영역&lt;/legend&gt; &lt;div class=&quot;inpt_group&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;검색할 회원의 닉네임을 입력해 주세요.&gt; &lt;button type=&quot;submit&quot;&gt;검색&lt;/button&gt; &lt;/div&gt; &lt;/fieldset&gt;&lt;/form&gt;&lt;div id=&quot;chat_list&quot;&gt; &lt;!-- 채팅 내용이 이곳에 동적으로 할당됨 --&gt;&lt;/div&gt; ajax 연동 샘플(jauery 기준) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * showSearchFriendList * @description 회원검색 리스트를 보여준다. * @param &#123;String&#125; METHOD - Form Method Type * @param &#123;String&#125; HTTP_API - Form Action url */var showSearchFriendList = function(METHOD, HTTP_API) &#123; $[METHOD](HTTP_API, function(data) &#123; var online_css = &#x27;&#x27;; var $noDataHTML = $(&#x27;&lt;p class=&quot;nodata&quot;&gt;&lt;strong&gt;등록된 회원이 없습니다.&lt;/strong&gt;&lt;/p&gt;&#x27;); var $userListHTML = $(&#x27;&lt;ul class=&quot;search-list&quot; /&gt;&#x27;); var $frag = $(document.createDocumentFragment()); if ( data.user === null ) &#123; $(&quot;#chat_list&quot;).html($noDataHTML); return false; &#125; $.each(data.user, function(i, v) &#123; if ( v.is_online ) &#123; online_css = &#x27;on&#x27;; &#125; $frag.append( &#x27;&lt;li class=&quot;member_list_li chat_nick user-layer-pop-left&quot; user-attr-id=&quot;&#x27; + v.mb_id + &#x27;&quot; user-attr-layer-type=&quot;live&quot;&gt;&#x27; + &#x27;&lt;span class=&quot;online &#x27; + online_css + &#x27;&quot;&gt;&lt;/span&gt;&#x27; + &#x27;&lt;img src=&quot;/img/lv/16/&#x27; + v.mb_level+&#x27;.png&quot;&gt;&#x27; + &#x27;&lt;b&gt;&#x27;+v.mb_nick+&#x27;&lt;/b&gt;&#x27; + &#x27;&lt;/li&gt;&#x27; ); &#125;); $userListHTML.append($frag[0]); $(&quot;#chat_list&quot;).html($userListHTML); &#125;, &#x27;json&#x27;);&#125;;//회원검색창 검색 폼 전송 이벤트 핸들러$(&#x27;#searchConnectorForm&#x27;).on(&#x27;submit&#x27;, function(e) &#123; e.preventDefault(); var $this = $(this); var inputSrchVal = $.trim($this.find(&#x27;:text&#x27;).val()); var METHOD = $this.attr(&#x27;method&#x27;), HTTP_API = $this.attr(&#x27;action&#x27;), params = &#x27;&#x27;; if ( inputSrchVal.length &lt; 2 ) &#123; return false; &#125; $this.children(&#x27;:hidden[name=search_nick]&#x27;).val(inputSrchVal); params = $this.serialize(); showSearchFriendList(METHOD, HTTP_API + params);&#125;);","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Javascript","slug":"Frontend/Javascript","permalink":"https://woonyzzang.github.com/categories/Frontend/Javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://woonyzzang.github.com/tags/js/"}]},{"title":"ionic-v2 Directory Structure","slug":"ionic-v2-dir","date":"2017-03-21T13:10:54.000Z","updated":"2020-09-05T13:07:55.852Z","comments":true,"path":"2017/03/21/ionic-v2-dir/","permalink":"https://woonyzzang.github.com/2017/03/21/ionic-v2-dir/","excerpt":"","text":"ionic v2 디렉토리 구조ionic –v2 의 폴더구조 및 환경설정 파일은 다음과 같다. 123456789101112|-[myApp]|--[app]|--[hooks]|--[node_modules]|--[platforms]|--[plugins]|--[typings]|--[www]|--config.xml|--package.json|--tsconfig.json|--typings.json app : 개발자가 작성하는 모든 애플리케이션 코드가 위치한다. hooks(codova) : cordova 빌드과정의 일부로써 동작될 수 있는 스크립트를 포함하고 있다. 앱을 패키지 할 때 필요하다면 언제든 커스터마이징 할 수 있다. node_modules: npm을 통해 설치된 모듈들이 있다. platforms(codorva) : ionic platform 으로 ios, android를 설치하면 하위 폴더로 생기고, Xcode 또는 Android Studio에서 import 할 수 있다. plugins(codorva) : ionic platform 선택시 Codova의 플러그인이 설치되는 폴더이다. resources : 앱을 위한 icon과 splash image를 해상도가 틀린 모바일 기기별로 놓는 곳이다. typings : TypeScript로 쓰여지지 않는 js 라이브러리의 타입 정의를 한 type defintion 파일이 있다. www(coderva) : index.html를 포함한다. 이곳은 빌드될 때 사용되는 것으로 애플리케이션 코드가 위치하는 곳이 아님을 주의하자. “ionic build” 를 하면 “cordova build” 가 수행되어 www 해당 디렉토리에 app의 코드가 위치하고 다시 platforms&#x2F;ios 또는 platforms&#x2F;android의 www 폴더에 copy 된다. 따라서 최종 사용되는 파일은 platforms&#x2F;ios(또는 platforms&#x2F;android) &#x2F;www&#x2F;*에 위치한다. config.xml(cordova) : 앱 패키지를 만들 때 사용하기 위해 Cordova의 환경설정이 존재한다. ionic.config.js : not used로 앞으로 없어질 것이다. ionic.config.json 파일은 버전 정보만 전달 package.json : npm 으로 설치되는 모든 모듈에 대한 설정 tsconfig.json &#x2F; typings.json : TypeScript 환경설정 &#x2F; type defintion file 환경설정 크게 “환경파일”, “Cordova”, “애플리케이션” 부분으로 나뉠 수 있다. 최초 템플릿이 생성된 이후 개발자는 “애플리케이션” 폴더인 “app” 를 사용하면 된다. blank 타입으로 만들었을 때 platforms 폴더에는 ios 플랫폼이 기본 설치 된다.","categories":[{"name":"App","slug":"App","permalink":"https://woonyzzang.github.com/categories/App/"},{"name":"Ionic","slug":"App/Ionic","permalink":"https://woonyzzang.github.com/categories/App/Ionic/"}],"tags":[{"name":"ionic v2","slug":"ionic-v2","permalink":"https://woonyzzang.github.com/tags/ionic-v2/"}]},{"title":"css3 Text Overflow","slug":"css3-text-overflow","date":"2017-03-21T13:09:17.000Z","updated":"2024-06-07T09:27:28.281Z","comments":true,"path":"2017/03/21/css3-text-overflow/","permalink":"https://woonyzzang.github.com/2017/03/21/css3-text-overflow/","excerpt":"","text":"CSS 한줄 말줄임 처리하기말 줄임 처리 방식은 크게 두 가지로 나뉠 수 있다.첫째는 프론트엔드(스크립트)단이나 서버사이드(백엔드)단에서 글자수를 기준으로 자르는 방법이고, 둘째는 CSS를 이용해 정해진 너비 값을 기준으로 자르는 방법이다.CSS를 이용한 방법은 구현 방법이 간단하고 성능에 영향을 주지 않아 글자수를 기준으로 자르는 방법보다 더 선호되고 있는 편이다.구현 원리는 텍스트 문장이 고정된 width 폭 넓이보다 넓어지면 … 말줄임 표시가 되도록 처리가 되도록 하는 것이다. CSS로 말줄임 효과 처리 하는 방법은 다음과 같다. 12345overflow:hidden;text-overflow:ellipsis;width:100px; /* max-width 속성 사용 가능 */white-space:nowrap;word-wrap:normal; text-overflow 이 속성은 글자가 지정한 너비를 넘어갈경우 어떤식으로 처리할것인지를 선택하는 속성 이다. clip: 기본값. ellipsis: 말줄임표로 처리. 상위요소의 너비가 auto로 되어있는경우는 적용할 수 없음. inherit: 상위요소의 속성과 동일하게 사용. white-space 요소안에서 공백은 어떤식으로 처리할것인지를 선택하는 속성이다. 공백은 줄바꿈(line-break), 들여쓰기(tab), 공백(space) 이다. normal: 기본값이며, 공백을 여러개 넣어도 공백을 1개로 처리한다. nowrap: 공백을 여러개 넣어도 1개로 처리한다. 텍스트가 길어져도 강제적으로 줄바꿈을 하지않고 1줄로 표시한다. pre: 공백이나 줄바꿈이 된 코드 그대로 표시한다. 코드에 줄바꿈이 없으면 줄바꿈을 실행하지 않는다. pre-wrap: 공백을 코드에 있는 그대로 표시한다. 코드에 줄바꿈이 없어도 자동으로 줄바꿈을 실행한다. pre-line: 공백을 여러개 넣어도 1개로 처리한다. 코드에 줄바꿈이 없어도 자동으로 줄바꿈을 실행한다. 코드에 줄바꿈이 있을때도 그대로 실행한다. word-wrap 긴 텍스트를 강제로 끊어서 줄바꿈을 해주는 속성이다. (overflow 와 비슷) normal: 기본값이며, 글자가 길어도 끊어지지 않고 한줄에 계속 표시한다. break-word: 강제로 끊어서 줄바꿈 한다. CSS 여러줄 멀티라인 말줄임 처리하기(두줄 이상일 경우)웹킷엔진을 사용하는 브라우저에서 -webkit-line-clamp 속성을 사용하면 두줄이상 여러줄 말줄임 처리가 가능하다. 12345678.ellipsis &#123; display: -webkit-box; overflow: hidden; text-overflow: ellipsis; -webkit-line-clamp: 3; /* 라인수 */ -webkit-box-orient: vertical; word-wrap:break-word; &#125; -webkit-line-clamp 속성의 경우, 웹킷 엔진을 사용하지 않는 브라우져의 경우 문제가 될수 있으므로,line-height 속성과 height 속성을 이요하여 높이를 계산하여 넣어준다. (height &#x3D; line-height * 줄수) 12345678910.ellipsis &#123; display: -webkit-box; overflow: hidden; text-overflow: ellipsis; -webkit-line-clamp: 3; /* 라인수 */ -webkit-box-orient: vertical; word-wrap:break-word; line-height: 1.2em; height: 3.6em; /* line-height 가 1.2em 이고 3라인을 자르기 때문에 height는 1.2em * 3 = 3.6em */&#125; 참조 http://blog.tjsrms.me/css-%EB%A7%90%EC%A4%84%EC%9E%84-%EC%B2%98%EB%A6%AC%ED%95%98%EA%B8%B0/ http://nuli.navercorp.com/sharing/blog/post/37677/","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"CSS","slug":"Frontend/CSS","permalink":"https://woonyzzang.github.com/categories/Frontend/CSS/"}],"tags":[{"name":"css","slug":"css","permalink":"https://woonyzzang.github.com/tags/css/"},{"name":"css3","slug":"css3","permalink":"https://woonyzzang.github.com/tags/css3/"}]},{"title":"CSS3 Calc","slug":"css3-calc","date":"2017-03-21T13:06:28.000Z","updated":"2024-06-07T09:27:28.275Z","comments":true,"path":"2017/03/21/css3-calc/","permalink":"https://woonyzzang.github.com/2017/03/21/css3-calc/","excerpt":"","text":"CSS 자동 계산 calc() 속성calc() 함수는 이름에서 보듯이 계산을 해주는 속성인데 기존에 자바스크립트로 하던 계산을 상당 부분 덜어줄수 있다.width, height, font-size, margin, padding 값의 길이를 계산할때나 각도, 수치, 변형(transition), 사운드 재생 횟수, 애니메이션 처리시 사용 한다.이를 표현하기 위해서는 더하기, 빼기, 곱하기, 나누기등 사칙연산자를 이용하여 표현할 수 있다. 예를 들어, 모든 문단을 “100% 너비에서 20픽셀(px)만큼 뺀 너비”로 설정하고 싶다면 다음과 같이 작성한다. 123456p &#123; width : 95%; /* 구식 브라우저를 위한 대비책(fallback) */ width : -webkit-calc(100% - 20px); /* for Chrome, Safari */ width : -moz-calc(100% - 20px); /* for Firefox */ width : calc(100% - 20px); /* for IE */&#125; calc() 내부에 입력할 수 있는 표현식은 +, -, *, &#x2F; 등의 사칙 연산이 가능하다.주의할 부분은 사칙 연산시 + 또는 – 는 반드시 기호 양쪽으로 공백을 삽입해야 한다는 것입니다.예를 들어, calc(100%&#x2F;6) 또는 calc(100%&#x2F;6 - 30px)는 유효한 표현식이지만 calc(100%&#x2F;6-30px)는 유효하지 않는다.또한, 계산은 같은 분류(길이면 길이, 각도면 각도)에 있는 값끼리 해야한다. 속성에 따라 계산 결과가 보정되는 경우가 있다. 예를 들어, 다음 예제에 있는 두 속성의 값은 같은 값이다. 12345678p &#123; width: calc(5px - 10px); &#125;//ouputp &#123; width: 0px; &#125; 표현식에 따르면 5px - 10px &#x3D; -5px 이지만, 너비의 경우 0보다 작은 값을 허용하지 않기 때문에 계산 결과는 0px와 같다. 현재 지원 브라우저 http://caniuse.com/#search=calc/ 참조 https://taegon.kim/archives/3768/ https://css-tricks.com/a-couple-of-use-cases-for-calc/ https://www.w3schools.com/cssref/func_calc.asp","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"CSS","slug":"Frontend/CSS","permalink":"https://woonyzzang.github.com/categories/Frontend/CSS/"}],"tags":[{"name":"css","slug":"css","permalink":"https://woonyzzang.github.com/tags/css/"},{"name":"css3","slug":"css3","permalink":"https://woonyzzang.github.com/tags/css3/"}]},{"title":"Javascript Storage API","slug":"javascript-storage-api","date":"2017-03-09T18:18:29.000Z","updated":"2024-06-10T04:53:59.573Z","comments":true,"path":"2017/03/10/javascript-storage-api/","permalink":"https://woonyzzang.github.com/2017/03/10/javascript-storage-api/","excerpt":"","text":"JavaScript localStorage와 sessionStorage APIHTML5에서는 좀 더 쉽고 간단한 저장소 제공을 위해 javascript의 새로운 localStorage와 sessionStorage API를 제공한다.이 둘의 가장 큰 차이점이라면 저장소로서의 기능은 대부분 동일하며 단지 sessionStorage의 경우 세션(브라우저 종료)이 종료되면 저장된 데이터도 함께 사라진 다는 점이 다른 점이다. 스토리지 API 특정값의 데이터를 저장하기 위한 방법으로 메소드를 사용하거나 리터럴하게 사용하는 두 가지 방법이 가능하다.localStorage와 sessionStorage API는 동일하니 여기선 localStorage 코드를 샘플로 예를 들어 보겠다. localStorage.setItem(key, value) &#x2F;&#x2F;데이터 저장 localStorage.getItem(key) &#x2F;&#x2F; 데이터 가져오기 localStorage.remove(key) &#x2F;&#x2F; 데이터 삭제 스토리지 데이터 저장 12localStorage.test = &#x27;123&#x27;;localStorage.setItem(&#x27;test&#x27;, &#x27;123&#x27;); 스토리지 데이터 가져오기 12localStorage.test;localStorage.getItem(&#x27;test&#x27;); 스토리지 데이터 삭제 12localStorage.removeItem(&#x27;test&#x27;); // localStorage 객체에서 원하는 값을 지우는 방법localStorage.clear(); // 한번에 저장된 모든 값을 삭제하는 방법 참조 http://webisfree.com/blog/?titlequery=%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-localstorage--sessionstorage-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%97%90-%EC%A0%95%EB%B3%B4-%EC%A0%80%EC%9E%A5","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Javascript","slug":"Frontend/Javascript","permalink":"https://woonyzzang.github.com/categories/Frontend/Javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://woonyzzang.github.com/tags/js/"}]},{"title":"ionic-v1 ScrollDelefate API","slug":"ionic-v1-scrollDelefate-api","date":"2017-03-09T18:16:47.000Z","updated":"2024-06-07T09:27:28.311Z","comments":true,"path":"2017/03/10/ionic-v1-scrollDelefate-api/","permalink":"https://woonyzzang.github.com/2017/03/10/ionic-v1-scrollDelefate-api/","excerpt":"","text":"ionic v1 $ionicScrollDelegate 스크롤 뷰 위치 제어ionic v1에서 스크롤 위치 이동 제어가 필요한 경우 $ionicScrollDelegate 를 컨트롤러에 의존주입시켜 사용하면 된다. scrollTo(left, top, [shouldAnimate]) &#x2F;&#x2F; 세번째 인자값은 true일시 스크롤이 애니메이션(모션) 되어 이동한다. $ionicScrollDelegate API 12345&lt;body ng-controller=&quot;MainCtrl&quot;&gt; &lt;ion-content&gt; // 컨텐츠 내용 &lt;/ion-content&gt;&lt;/body&gt; 1234.controller(&#x27;MainCtrl&#x27;, function($scope, $ionicScrollDelegate) &#123; console.log( $ionicScrollDelegate.getScrollPosition().top ); // 현재 스크롤 위치값 반환 $ionicScrollDelegate.scrollTo(0, 100); // 스크롤 위치 y값 100px 만큼 이동&#125;); 참조 https://ionicframework.com/docs/api/service/$ionicScrollDelegate/","categories":[{"name":"App","slug":"App","permalink":"https://woonyzzang.github.com/categories/App/"},{"name":"Ionic","slug":"App/Ionic","permalink":"https://woonyzzang.github.com/categories/App/Ionic/"}],"tags":[{"name":"ionic v1","slug":"ionic-v1","permalink":"https://woonyzzang.github.com/tags/ionic-v1/"}]},{"title":"ionic-v1 Platform API","slug":"ionic-v1-platform-api","date":"2017-03-09T18:15:26.000Z","updated":"2024-06-07T09:27:28.309Z","comments":true,"path":"2017/03/10/ionic-v1-platform-api/","permalink":"https://woonyzzang.github.com/2017/03/10/ionic-v1-platform-api/","excerpt":"","text":"ionic v1 ionic.Platform APIionic v1에서 네이티브 모바일 디바이스 분기 처리 같은 기능을 위해 아래와 같은 ionic.Platform API 기능을 제공한다. ionic.Platform API 1234567891011121314151617181920angular.module(&#x27;PlatformApp&#x27;, [&#x27;ionic&#x27;]) .controller(&#x27;PlatformCtrl&#x27;, function($scope) &#123; ionic.Platform.ready(function()&#123; // will execute when device is ready, or immediately if the device is already ready. &#125;); var deviceInformation = ionic.Platform.device(); // 디바이스 정보 확인 var isWebView = ionic.Platform.isWebView(); // 네이티브 앱 디바이스 확인 var isIPad = ionic.Platform.isIPad(); // 아이패드 디바이스 확인 var isIOS = ionic.Platform.isIOS(); // 아이폰 디바이스 확인 var isAndroid = ionic.Platform.isAndroid(); // 안드로이드 디바이스 확인 var isWindowsPhone = ionic.Platform.isWindowsPhone(); // 윈도우폰 디바이스 확인 var currentPlatform = ionic.Platform.platform(); // 디바이스 플랫폼 확인 var currentPlatformVersion = ionic.Platform.version(); // 현재 디바이스 플랫폼 버전 확인 ionic.Platform.exitApp(); // stops the app &#125;); 참조 https://ionicframework.com/docs/api/utility/ionic.Platform/","categories":[{"name":"App","slug":"App","permalink":"https://woonyzzang.github.com/categories/App/"},{"name":"Ionic","slug":"App/Ionic","permalink":"https://woonyzzang.github.com/categories/App/Ionic/"}],"tags":[{"name":"ionic v1","slug":"ionic-v1","permalink":"https://woonyzzang.github.com/tags/ionic-v1/"}]},{"title":"Angular.js v1.0 Storage","slug":"angularjs-v1-storage","date":"2017-03-09T18:13:14.000Z","updated":"2024-06-07T09:27:28.250Z","comments":true,"path":"2017/03/10/angularjs-v1-storage/","permalink":"https://woonyzzang.github.com/2017/03/10/angularjs-v1-storage/","excerpt":"","text":"Angular.js v1 HTML5 Storage 사용하기Angular.js에서 HTML5의 localStorage, sessionStorage의 기능을 사용할때 Factory에 등록하고 사용하면 유용하다.아래 예제 코드에서 JSON.parse()를 사용한 이유는 storage 키값에 저장된 값은 문자열인 string으로 저장 되기에 원시데이터로 다시 변환하기 위함이다. 세션 스토리지 Factory 등록 123456789101112131415161718192021222324-factories.jsangular.module(&#x27;starter.factories&#x27;, [])// sessionStorage 사용을 위한 셋팅.factory(&#x27;$sessionStorage&#x27;, [&#x27;$window&#x27;, function($window) &#123; return &#123; get: function(key) &#123; return JSON.parse( $window.sessionStorage.getItem(key) ); &#125;, set: function(key, value) &#123; $window.sessionStorage.setItem(key, value); &#125;, getObject: function(key) &#123; return JSON.parse( $window.sessionStorage.getItem(key) || &#x27;&#123;&#125;&#x27;); &#125;, setObject: function(key, value) &#123; $window.sessionStorage.setItem(key, JSON.stringify(value)); &#125;, remove: function(key) &#123; $window.sessionStorage.removeItem(key); &#125; &#125;;&#125;]) 컨트롤러에서 세션 스토리지 사용하기 1234.controller(&#x27;MainCtrl&#x27;, function($scope, $rootScope, $sessionStorage) &#123; $sessionStorage.set(&#x27;test&#x27;, &#x27;one&#x27;); // 세션스토리지 test 키값에 &quot;one&quot; 값 저장 $sessionStorage.get(&#x27;test&#x27;) // 세션스토리지 test 키값 가져오기&#125;); 로컬 스토리지 Factory 등록 123456789101112131415161718192021222324-factories.jsangular.module(&#x27;starter.factories&#x27;, [])// localStorage 사용을 위한 셋팅.factory(&#x27;$localStorage&#x27;, [&#x27;$window&#x27;, function($window) &#123; return &#123; get: function(key, defaultValue) &#123; return $window.localStorage[key] || defaultValue; &#125;, set: function(key, value) &#123; $window.localStorage[key] = value; &#125;, getObject: function(key) &#123; return JSON.parse( $window.localStorage[key] || &#x27;&#123;&#125;&#x27;); &#125;, setObject: function(key, value) &#123; $window.localStorage[key] = JSON.stringify(value); &#125;, remove: function(key) &#123; $window.localStorage.removeItem(key); &#125; &#125;;&#125;]) 컨트롤러에서 로컬 스토리지 사용하기 1234.controller(&#x27;MainCtrl&#x27;, function($scope, $rootScope, $localStorage) &#123; $localStorage.set(&#x27;test&#x27;, 100); // 로컬 스토리지 test 키값에 &quot;one&quot; 값 저장 $localStorage.get(&#x27;test&#x27;) // 로컬 스토리지 test 키값 가져오기&#125;); 참조 http://rhammer.tistory.com/40","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"SPA","slug":"Frontend/SPA","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/"},{"name":"Angular.js","slug":"Frontend/SPA/Angular-js","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/Angular-js/"}],"tags":[{"name":"angular v1","slug":"angular-v1","permalink":"https://woonyzzang.github.com/tags/angular-v1/"}]},{"title":"Webstorm SVN Checkout Error","slug":"webstorm-svn-checkout-error","date":"2017-03-09T18:10:25.000Z","updated":"2020-09-05T13:07:56.160Z","comments":true,"path":"2017/03/10/webstorm-svn-checkout-error/","permalink":"https://woonyzzang.github.com/2017/03/10/webstorm-svn-checkout-error/","excerpt":"","text":"Webstrom SVN checkout 에러 해결VCS &gt; Enable Version Control Integration &gt; SVN 활성화 후 체크아웃을 받을 시아래와 같은 에러 메세지가 발생해서 레파지토리의 소스코드가 체크아웃이 안되는 이슈가 발생한다면 Cannot load supported formats: Cannot run program &quot;svn&quot;: CreateProcess error=2, The system cannot find the file specified1 Settings -&gt; Version Controll -&gt; Subversion 메뉴에서 Use command line client 체크박스를 해제함으로써 해결할 수 있다. 참조 http://chomman.github.io/blog/tool/subversion/intellij-subversion-checkout-error/","categories":[{"name":"Editor","slug":"Editor","permalink":"https://woonyzzang.github.com/categories/Editor/"},{"name":"Webstorm","slug":"Editor/Webstorm","permalink":"https://woonyzzang.github.com/categories/Editor/Webstorm/"}],"tags":[{"name":"webstorm","slug":"webstorm","permalink":"https://woonyzzang.github.com/tags/webstorm/"}]},{"title":"Webstorm Git","slug":"webstorm-git","date":"2017-03-09T18:09:06.000Z","updated":"2024-06-07T09:27:28.384Z","comments":true,"path":"2017/03/10/webstorm-git/","permalink":"https://woonyzzang.github.com/2017/03/10/webstorm-git/","excerpt":"","text":"Webstorm Git.exe 파일을 찾을 수 없습니다. 해결하기webstorm을 실행하고 git을 사용하려 하면 다음과 같은 에러가 난다. Cannot run program &quot;git.exe&quot;: CreateProcess error=2, The system cannot find the file specified 내장 플러그인 git이 설치 안되있거나 위치를 찾을 수 없는 경우가 종종 있다. 이미 설치되어 있는데 위치를 못찾을 경우 c:\\Users(한글윈도는 사용자)\\이름\\AppData\\Local\\GitHub\\PortableGit~\\cmd\\git.exe주로 여기가 디폴트 인스톨 위치이나 이유를 알수 없이 여러 경로에 설치 된다. Local 이하로 \\Programs\\Git~~~\\Bin\\git.exe 있는 경우도 있고c:\\Program Files(x86)\\git\\bin\\git.exe 에 있기도 하다. 미설치일 경우 Git.exe 다운로드 OS 환경에 맞는 git 설치 후 git.exe 파일경로를 맵핑하고 Test 버튼을 누른다.기본적으로 설치 경로는 C:\\Program Files\\Git\\bin\\git.exe 이다. 위와 같이 “successfully” 메세지가 나오면 정상적으로 git 환경설정이 완료 된것이다. 참조 http://chomman.github.io/blog/tool/subversion/intellij-subversion-checkout-error/","categories":[{"name":"Editor","slug":"Editor","permalink":"https://woonyzzang.github.com/categories/Editor/"},{"name":"Webstorm","slug":"Editor/Webstorm","permalink":"https://woonyzzang.github.com/categories/Editor/Webstorm/"}],"tags":[{"name":"webstorm","slug":"webstorm","permalink":"https://woonyzzang.github.com/tags/webstorm/"}]},{"title":"D3.js Text","slug":"d3js-text","date":"2017-03-09T18:07:43.000Z","updated":"2024-06-07T09:27:28.293Z","comments":true,"path":"2017/03/10/d3js-text/","permalink":"https://woonyzzang.github.com/2017/03/10/d3js-text/","excerpt":"","text":"D3.js text APItext() 메소드는 셀러토된 요소에 텍스트를 출력 한다. 예제1 1234567d3.select(&#x27;body&#x27;).append(&#x27;p&#x27;) .text(&#x27;Hello World!&#x27;); //output&lt;body&gt;&lt;p&gt;Hello World!&lt;/p&gt; =&gt; p 태그가 추가 되고 Hello World! 문자열을 출력 &lt;/body&gt; 예제2 123456789101112&lt;p&gt;Google&lt;/p&gt;&lt;script&gt;d3.select(&#x27;body&#x27;).append(&#x27;p&#x27;) .text(&#x27;Hello World!&#x27;);&lt;/script&gt;//ouput&lt;body&gt;&lt;p&gt;Google&lt;/p&gt;&lt;p&gt;Hello World!&lt;/p&gt; =&gt; 기존 p태그와 상관없이 새롭게 p 태그가 추가 되고 Hello World! 문자열을 출력&lt;/body&gt; 예제3 1234567891011&lt;p&gt;Google&lt;/p&gt;&lt;script&gt;d3.select(&#x27;body&#x27;).selectAll(&#x27;p&#x27;) .text(&#x27;Hello World!&#x27;);&lt;/script&gt;//ouput&lt;body&gt;&lt;p&gt;Hello World!&lt;/p&gt; =&gt; 기본 &lt;p&gt;Google&lt;/p&gt; 태그와 치환되어 변경 된다.&lt;/body&gt; 참조 http://blog.naver.com/PostView.nhn?blogId=zero_kjy&amp;logNo=220783698391&amp;parentCategoryNo=&amp;categoryNo=18&amp;viewDate=&amp;isShowPopularPosts=false&amp;from=postList","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Library","slug":"Frontend/Library","permalink":"https://woonyzzang.github.com/categories/Frontend/Library/"},{"name":"D3.js","slug":"Frontend/Library/D3-js","permalink":"https://woonyzzang.github.com/categories/Frontend/Library/D3-js/"}],"tags":[{"name":"d3","slug":"d3","permalink":"https://woonyzzang.github.com/tags/d3/"}]},{"title":"D3.js SVG","slug":"d3js-svg","date":"2017-03-09T18:06:40.000Z","updated":"2024-06-07T09:27:28.293Z","comments":true,"path":"2017/03/10/d3js-svg/","permalink":"https://woonyzzang.github.com/2017/03/10/d3js-svg/","excerpt":"","text":"D3.js SVGSVG는 도형을 그리기 위한 HTML의 태그로 rect, circle, line, path, ellipse, polyline 등을 사용하여 그린다. HTML의 SVG 코드 12345678910111213141516&lt;svg wdth=&quot;500&quot; height=&quot;500&quot; style=&quot;background-color:#f00&quot;&gt; &lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;480&quot; height=&quot;30&quot; fill=&quot;green&quot; stroke=&quot;blue&quot; stroke-width=&quot;5&quot;&gt;&lt;/rect&gt; &lt;circle cx=&quot;100&quot; cy=&quot;100&quot; r=&quot;50&quot; fill=&quot;red&quot; stroke=&quot;blue&quot; stroke-width=&quot;5&quot;&gt;&lt;/circle&gt; &lt;ellipse cx=&quot;300&quot; cy=&quot;100&quot; rx=&quot;70&quot; ry=&quot;30&quot; fill=&quot;red&quot; stroke=&quot;blue&quot; stroke-width=&quot;5&quot;&gt;&lt;/ellipse&gt; &lt;line x1=&quot;10&quot; y1=&quot;200&quot; x2=&quot;480&quot; y2=&quot;200&quot; stroke=&quot;red&quot; stroke-width=&quot;5&quot;&gt;&lt;/line&gt; &lt;path d=&quot;M10,210 L110,220 210,210 310,220 410,210&quot; fill=&quot;none&quot; stroke=&quot;blue&quot; stroke-width=&quot;5&quot;&gt;&lt;/path&gt; &lt;polyline points=&quot;200,300 230,250 260,300&quot; fill= &quot;red&quot; stroke=&quot;blue&quot; stroke-width=&quot;5&quot;&gt;&lt;/polyline&gt; &lt;text x=&quot;150&quot; y=&quot;35&quot; fill=&quot;black&quot; font-size=&quot;30px&quot;&gt;Hello World&lt;/text&gt; &lt;text x=&quot;75&quot; y=&quot;120&quot; fill=&quot;white&quot; font-size=&quot;50px&quot;&gt;39&lt;/text&gt; &lt;g stroke=&quot;green&quot; fill=&quot;white&quot; stroke-width=&quot;5&quot;&gt; &lt;circle cx=&quot;25&quot; cy=&quot;25&quot; r=&quot;15&quot;&gt;&lt;/circle&gt; &lt;circle cx=&quot;40&quot; cy=&quot;25&quot; r=&quot;15&quot;&gt;&lt;/circle&gt; &lt;circle cx=&quot;55&quot; cy=&quot;25&quot; r=&quot;15&quot;&gt;&lt;/circle&gt; &lt;circle cx=&quot;70&quot; cy=&quot;25&quot; r=&quot;15&quot;&gt;&lt;/circle&gt; &lt;/g&gt;&lt;/svg&gt; d3.js SVG 코드 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// svg(켄버스) : 넓이(500), 높이(500), 배경색(yellow)var svg = d3.select(&#x27;body&#x27;).append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, 500) // 넓이 .attr(&#x27;height&#x27;, 500) // 높이 .style(&#x27;background-color&#x27;, &#x27;#ff0&#x27;);// rect(사각형) : 시작위치(10,10), 넓이(480), 내부색(green), 테두리색(blue), 테두리크기(5)var rect = svg.append(&#x27;rect&#x27;) .attr(&#x27;x&#x27;, 10) // 처음 그림 x축 위치 .attr(&#x27;y&#x27;, 10) // 처음 그림 y축 위치 .attr(&#x27;width&#x27;, 480) // 넓이 .attr(&#x27;height&#x27;, 30) // 높이 .attr(&#x27;fill&#x27;, &#x27;green&#x27;) // 내부색 .attr(&#x27;stroke&#x27;, &#x27;blue&#x27;) // 테두리색 .attr(&#x27;stroke-width&#x27;, 5); // 테두리크기// circle(원) : 위치(100,100), 반지름(50), 내부색(red), 테두리색(blue), 테두리크기(5)var circle = svg.append(&#x27;circle&#x27;) .attr(&#x27;cx&#x27;, 100) // 시작 x축 꼭지점 .attr(&#x27;cy&#x27;, 100) // 시작 y축 꼭지점 .attr(&#x27;r&#x27;, 50) // 반지름 .attr(&#x27;fill&#x27;, &#x27;red&#x27;) .attr(&#x27;stroke&#x27;, &#x27;blue&#x27;) .attr(&#x27;stroke-width&#x27;, 5);// ellipse(타원) : 위치(300,100), 폭반지름(70), 높이반지름(30), 내부색(red), 테두리색(blue), 테두리크기(5)var ellipse = svg.append(&#x27;ellipse&#x27;) .attr(&#x27;cx&#x27;, 300) // 시작 x축 꼭지점 .attr(&#x27;cy&#x27;, 100) // 시작 y축 꼭지점 .attr(&#x27;rx&#x27;, 70) // x축으로 넓이 반지름 .attr(&#x27;ry&#x27;, 30) // y축으로 넓이 반지름 .attr(&#x27;fill&#x27;, &#x27;red&#x27;) .attr(&#x27;stroke&#x27;, &#x27;blue&#x27;) .attr(&#x27;stroke-width&#x27;, 5);// line(선) : 시작점(10,200), 끝점(480,200), 테두리색(red), 테두리크기(5)var line = svg.append(&#x27;line&#x27;) .attr(&#x27;x1&#x27;, 10) .attr(&#x27;y1&#x27;, 200) .attr(&#x27;x2&#x27;, 480) .attr(&#x27;y2&#x27;, 200) .attr(&#x27;stroke&#x27;, &#x27;blue&#x27;) .attr(&#x27;stroke-width&#x27;, 5);// path(특수라인) :var path = svg.append(&#x27;path&#x27;) // M: 시작 위치로 이동 (M 10,210 =&gt; (10,210)꼭지점이 시작위치가 됨 // L: 이동할 라인 좌표 (L 110,220 =&gt; (110,220)꼭지점으로 라인을 그음) // C: 곡선 S : 부드러운곡선 Q : 차 베지에곡선 T : 부드러운 차 베지에 곡선 A : 호 Z = 끝경로(시작점과 이음) .attr(&#x27;d&#x27;, &#x27;M10,210 L110,220 210,210 310,220 410,210&#x27;) .attr(&#x27;fill&#x27;, &#x27;none&#x27;) .attr(&#x27;stroke&#x27;, &#x27;blue&#x27;) .attr(&#x27;stroke-width&#x27;, 5); 위에서 사용된 d3.js의 메소드를 살펴보면 .select(‘태그’) &#x3D;&gt; 특정태그를 선택한다. 그림을 그릴 위치를 선택한는것 .append(‘태그’) &#x3D;&gt; 태그 추가 .attr(‘name’, ‘value’) &#x3D;&gt; 태그의 속성 name에 해당 value를 넣음 style(‘name’, ‘value’) &#x3D;&gt; 해당 태그의 style를 지정한다. 별로로 태그의 기본속성없는 외부 스타일을 추가할때 사용 style의 경우는 css로 따로 관리가 가능하다. 참조 http://blog.naver.com/PostView.nhn?blogId=zero_kjy&amp;logNo=220778573029&amp;parentCategoryNo=&amp;categoryNo=18&amp;viewDate=&amp;isShowPopularPosts=false&amp;from=postList","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Library","slug":"Frontend/Library","permalink":"https://woonyzzang.github.com/categories/Frontend/Library/"},{"name":"D3.js","slug":"Frontend/Library/D3-js","permalink":"https://woonyzzang.github.com/categories/Frontend/Library/D3-js/"}],"tags":[{"name":"d3","slug":"d3","permalink":"https://woonyzzang.github.com/tags/d3/"}]},{"title":"D3.js Select","slug":"d3js-select","date":"2017-03-09T18:05:03.000Z","updated":"2024-06-07T09:27:28.292Z","comments":true,"path":"2017/03/10/d3js-select/","permalink":"https://woonyzzang.github.com/2017/03/10/d3js-select/","excerpt":"","text":"D3.js select APId3.js 에서는 일반적으로 메서드 체이닝 기법을 사용한다. jQuery의 select API 문법과 흡사하지만 d3에서는 selection 객체에 대해서 data()를 통해 특정 데이터를 바인드하고, enter()와 exit()를 통해 데이터에 대응하는 객체를 다룰 수 있는 기능들을 제공한다 select API select() - 현재 문서에서 시각화할 특정요소 태그 하나를 선택 selectAll() - 현재 문서에서 특정 태그 전체를 선택 attr() - 선택된 태그의 속성값 지정 data() - 참조 연결한 데이터 가져옴(선택된 태그에 데이터 매칭) enter() - 데이터 갯수만큼 태그가 부족할 시에 플레이스홀더를 반환 append() - 새로운 태그를 추가 exit() - 종료(더 이상 필요없는 태그는 반환) remove() - 현재 문서에서 선택된 태그를 제거 데이터 바인드하고 요소 추가하기 1234567891011var data = [1, 2, 3, 4, 5];var $p = d3.select(&#x27;body&#x27;) // 부모 태그 셀렉터 .selectAll(&#x27;p&#x27;) // 부모 태그 하위 요소인 p 태그 전체 선택 .data(data); // 선택된 p 태그들에 대해 data 변수로 선언한 데이터 바인딩 연결(5개의 데이터를 body안에 있는 p태그를 포함해서 사용한다는 의미) $p.enter() // 바인드된 데이터들 중에 아직 실제 문서 요소를 가지지 못 하는 것들을 찾아내서 가상의 객체로 만들어 반환(body 안에 이미 p태그가 3개가 있다면 나머지 2개의 데이터를 사용할 가상영역이 생성되야 하는데 그 역활을 수행) .append(&#x27;p&#x27;); // 실제 가상 영역에 p태그를 삽입(body 안에 만들어진 p태그가 5개가 안되면 여기서 추가로 가상영역의 갯수만큼 p태그를 생성한다.) $p.exit() // 종료 .remove(); // 데이터 갯수 이상 매칭된 요소 삭제(body안의 p 태그가 데이터 보다 많을시 반환되지 않고 제거) 예제 1234567891011121314151617181920212223&lt;p&gt;a&lt;/p&gt;&lt;p&gt;b&lt;/p&gt;&lt;p&gt;a&lt;/p&gt;&lt;script&gt;var data = [1, 2];var $p = d3.select(&#x27;body&#x27;).selectAll(&#x27;p&#x27;) .data(data) .text(function(d) &#123; return d; &#125;); $p.enter().append(&#x27;p&#x27;) .text(function(d) &#123; // 이미 존재하는 요소에 대해서 enter() 메서드를 사용하면 이를 조작할 수 없다는 의미가 된다. 이 때는 selectAll() 이후, 혹은 data() 메서드로 데이터 바인드 이후 text() 메서드로 반환되는 결과를 바로 조작하면 된다. return d; &#125;); $p.exit().remove();&lt;/script&gt;//ouput12 body 안에 p 태그가 이미 3개 존재한다. 하지만 데이터 갯수는 2개이다. 실질적으로 연결되는 값은 [1,2]인 두개뿐이다. 세본째 p태그는 사용되지 않고 그대로 유지된다. 여기서 remove() 로 사용되지 않는 p태그가 제거 된다. 참조 http://blog.naver.com/PostView.nhn?blogId=zero_kjy&amp;logNo=220779398557&amp;categoryNo=18&amp;parentCategoryNo=0&amp;viewDate=&amp;currentPage=4&amp;postListTopCurrentPage=1&amp;from=postList&amp;userTopListOpen=true&amp;userTopListCount=5&amp;userTopListManageOpen=false&amp;userTopListCurrentPage=4","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Library","slug":"Frontend/Library","permalink":"https://woonyzzang.github.com/categories/Frontend/Library/"},{"name":"D3.js","slug":"Frontend/Library/D3-js","permalink":"https://woonyzzang.github.com/categories/Frontend/Library/D3-js/"}],"tags":[{"name":"d3","slug":"d3","permalink":"https://woonyzzang.github.com/tags/d3/"}]},{"title":"D3.js ScaleTime","slug":"d3js-scaleTime","date":"2017-03-09T18:01:49.000Z","updated":"2024-06-07T09:27:28.291Z","comments":true,"path":"2017/03/10/d3js-scaleTime/","permalink":"https://woonyzzang.github.com/2017/03/10/d3js-scaleTime/","excerpt":"","text":"D3.js scaleTime기초적인 축에 더해 이번엔 날짜를 값으로 하는 가로축을 생성해보자.이 경우 domain의 범위는 Date객체가 된다. 12345678910111213141516171819202122232425262728293031&lt;svg id=&quot;graph&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt; &lt;g id=&quot;yaxis&quot;&gt;&lt;/g&gt; // g태그는 하위 엘리먼트 그룹핑 한다. &lt;g id=&quot;xaxis&quot;&gt;&lt;/g&gt;&lt;/svg&gt;&lt;script&gt;var resizer = function resizer() &#123; var h = document.getElementById(&#x27;graph&#x27;).clientHeight; var yscale = d3.scaleLinear() .domain([0, 4955]) // 실제값의 범위 .range([h - 20, 0 + 20]); // 변환할 값의 범위(역으로 처리했음!), 위아래 패딩 20을 줬다! d3.select(&#x27;#yaxis&#x27;) .attr(&#x27;transform&#x27;, &#x27;translate(50, 0)&#x27;) // 살짝 오른쪽으로 밀고 .call(d3.axisLeft(yscale)); // 축함수를 넘기면 알아서 그려줌. var w = document.getElementById(&#x27;graph&#x27;).clientWidth; var xscale = d3.scaleTime() .domain([new Date(2017, 2, 26), new Date(2017, 2, 28)]) //범위를 날짜로 .range([50, w - 50]); //위의 y축이 가로50을 차지했으니 그만큼 밀자 var xaxis = d3.axisTop(xscale) .tickFormat(d3.timeFormat(&#x27;%m/%d&#x27;)) //표시할 형태를 포메팅한다. .ticks(d3.timeDay); //틱단위를 1일로 d3.select(&#x27;#xaxis&#x27;) .attr(&#x27;transform&#x27;, &#x27;translate(0,20)&#x27;)//세로20만큼 내려서 전개 .call(d3.axisTop(xscale));&#125;;window.addEventListener(&#x27;resize&#x27;, resizer);resizer(); 그럼 전체적으로 아래와 같은 화면을 보게 된다. 새삼스러운 얘기지만 화면에서의 위치를 잘 잡기 위해서 range에 padding을 넣는다던가 translate를 잘 사용해야 하는 부분은 귀찮기도 하고 반복적이기도 해서 d3가 내장할 레벨은 아니지만 실무적으로는 이를 래핑한 함수를 사용하는 경우가 대부분 이다. scale은 단지 axis에만 사용되는게 아니라 모든 데이터에 다 적용됩니다(당연하게도) 흐름을 보면 차트용 데이터가 주어지면 화면의 크기, 표현하려는 형태 등을 고려하여 scale을 설정하고 scale을 바탕으로 한 axis를 만들어내며 각 데이터를 scale로 변환해가면서 차트를 그려나간다 라는 식이다. 참조 http://www.bsidesoft.com/?p=2382#d3%25ec%258b%259c%25eb%25a6%25ac%25ec%25a6%2588","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Library","slug":"Frontend/Library","permalink":"https://woonyzzang.github.com/categories/Frontend/Library/"},{"name":"D3.js","slug":"Frontend/Library/D3-js","permalink":"https://woonyzzang.github.com/categories/Frontend/Library/D3-js/"}],"tags":[{"name":"d3","slug":"d3","permalink":"https://woonyzzang.github.com/tags/d3/"}]},{"title":"D3.js Scale 집중탐구","slug":"d3js-scale2","date":"2017-03-09T17:59:03.000Z","updated":"2024-06-07T09:27:28.290Z","comments":true,"path":"2017/03/10/d3js-scale2/","permalink":"https://woonyzzang.github.com/2017/03/10/d3js-scale2/","excerpt":"","text":"D3.js Scale 집중탐구 - 1기본적으로 scale을 그리는 이미지의 크기와 컬러를 자동으로 조정하느 기능을 담당한다. 읽어온 데이터값을 건들지 않고 그 데이터값에 맞는 크기와 컬러 범위를 시각화 할때 자동으로 맞춰준다. d3.scaleLinear() d3.scalePow() d3.scaleLog() 12345678910111213141516171819var data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];var linear = d3.scaleLinear().domain([1, 10]).range([0 ,100]); // x: y = mx + bvar pow = d3.scalePow().domain([1, 10]).range([0 ,100]); // x: y = mx^k + bvar log = d3.scaleLog().domain([1, 10]).range([0 ,100]); // x: y = m log(x) + bconsole.log(&#x27;d3.scaleLinear()&#x27;);data.forEach(function(d) &#123; console.log( linear(d) );&#125;);console.log(&#x27;d3.scalePower()&#x27;);data.forEach(function(d) &#123; console.log( pow(d) );&#125;);console.log(&#x27;d3.scaleLog()&#x27;);data.forEach(function(d) &#123; console.log( log(d) );&#125;); 결과를 확인해 보면 scaleLinear() 와 scalePow() 메소드의 결과값은 같은 값이 출력 되지만 scaleLog() 메소드는 다른값이 출력이 된다. d3.scaleLinear() : 두 지점 사이의 값 x에 대해 y는 mx + b 값이 리턴된다.공식 &#x3D;&gt; x: y &#x3D; mx + b 1var linear = d3.scaleLinear().domain([1, 10]).range([0 ,100]); 도메인 [110]에 대한 반환값으로 [0100]사이의 값이 선택이 된다. 1234console.log( linear(2) );console.log( linear.invert(20) ); //역값console.log( linear(-1) );console.log( linear(11) ); linear(2) &#x3D;&gt; 11.11111111111111linear.invert(20) &#x3D;&gt; 2.8 &#x2F;&#x2F; range y값 20이 대응하는 도메인 x값을 출력(반환값에서 도메인값을 역으로 찾는 메소드) invert() : range 값의 대한 역 도메인 값을 반환 linear(-1) &#x3D;&gt; -22.22222222222222linear(11) &#x3D;&gt; 111.11111111111111&#x3D;&gt; 도메인 범위를 벗어나도 현재 스케일 함수에 맞게 자동으로 -1과 11이 갖는 반환값을 계산해내서 출력 linear.clamp(true); &#x2F;&#x2F; range 범위를 고정시킨다.console.log( linear(-1) );console.log( linear(11) ); linear(-1) &#x3D;&gt; 0linear(11) &#x3D;&gt; 100&#x3D;&gt; clamp 함수가 true로 선언하게 되면 도메인값이 벗어나더라도 자동으로 계산하느넥 아니라 range값을 벗어나지 못하게 된다. 아무리 작은 값이라도 0으로 아무리 큰 값이라도 100으로 묶여 버린다. clamp() : range 값의 범위를 고정 123456var linear = d3.scaleLinear().domain([1, 10]).rangeRound([0, 100]) // 정수값으로 출력range()일 경우 linear(2) -&gt; 11.11111111111111 값이 출력 되는 반면rangeRound()일 경우에는 linear(2) =&gt; 11 출력 rangeRound() : 반환값을 정수형으로 출력 참조 http://blog.naver.com/PostView.nhn?blogId=zero_kjy&amp;logNo=220790671094&amp;parentCategoryNo=&amp;categoryNo=18&amp;viewDate=&amp;isShowPopularPosts=false&amp;from=postList","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Library","slug":"Frontend/Library","permalink":"https://woonyzzang.github.com/categories/Frontend/Library/"},{"name":"D3.js","slug":"Frontend/Library/D3-js","permalink":"https://woonyzzang.github.com/categories/Frontend/Library/D3-js/"}],"tags":[{"name":"d3","slug":"d3","permalink":"https://woonyzzang.github.com/tags/d3/"}]},{"title":"D3.js Scale","slug":"d3js-scale","date":"2017-03-09T17:54:00.000Z","updated":"2024-06-07T09:27:28.288Z","comments":true,"path":"2017/03/10/d3js-scale/","permalink":"https://woonyzzang.github.com/2017/03/10/d3js-scale/","excerpt":"","text":"D3.js Scaled3.js 의 scale은 어떤 범위를 숫자를 다른 범위로 숫자로 변경해서 그릴려고 하는 영역 공간에 그 크기를 자동으로 조절하여 시각화 하는데 사용하는 함수가 바로 scale 메소드 이다. scale API d3.scaleTime() d3.scaleLinear() d3.scalePow() d3.scaleLog() d3.scaleIdentity() 예를 들어 가장 흔하게 사용하는 변경은 백분률이다. 0에서 4955의 범위가 있을 때 2345가 어디쯤인지 감을 잡기 위해 다음 같은 방식으로 백분률을 고친다. 2345 / 4955 * 100 = 47.32 이를 통해 전체를 100으로 본다면 47정도의 위치에 있는 숫자인지 감을 잡을 수 있다. 이를 구현한게 d3.js에서 scale 메소드 이다. 12var scale = d3.scaleLinear().domain([0, 4955]).range([0, 100]);console.log(scale(2345)); //47.32 scaleTime과 scaleLinear를 다르다. 일단 위의 함수로 생성된 scale함수는 추가적인 속성을 설정할 수 있는데 그 중 가장 중요한게 domain과 range 이다.둘 다 배열 1개를 인자로 받고 배열 안에 2개의 원소로 시작과 끝의 범위를 기술한다. domain이 실제 값의 범위라면 range가 백분률처럼 변환하고 싶은 값의 범위이다. range에서 시작과 끝을 반대로 기술하여 역으로 값이 나오게할 수도 있다는 점이다. 이 방법은 실제로 많이 사용되는데 그래프가 아래서 위로 솓아오르는게 자연스러운 반면 svg의 좌표계는 젤 위가 0이고 아래로 갈수록 증가하는 형태라 값을 거꾸로 기술하는 편이 더 시각적으로 좋기 때문이다. 예제 1234567-data.cvsx,y,r50,50,1100,150,3150,50,5200,150,7250,50,9 123456789101112131415161718192021222324252627282930313233343536373839function render(data) &#123; var circle = svg.selectAll(&#x27;circle&#x27;) .data(data) .enter() .append(&#x27;circle&#x27;) .attr(&#x27;cx&#x27;, function(d) &#123; return d.x; &#125;) .attr(&#x27;cy&#x27;, function(d) &#123; return d.y; &#125;) .attr(&#x27;r&#x27;, function(d) &#123; return rScale(d.r); &#125;) .attr(&#x27;fill&#x27;, function(d) &#123; return colorScale(d.r); &#125;);&#125;function type(d) &#123; d.x = +d.x; // parseFloat(d.x) d.y = +d.y; // parseFloat(d.y) d.r = +d.r; // parseFloat(d.r) return d;&#125;var rScale = d3.scaleLinear().domain([0, 10]).range([0, 50]);var colorScale = d3.scaleLinear().domain([0, 10]).range([&#x27;red&#x27;, &#x27;blue&#x27;]);var svg = d3.select(&#x27;body&#x27;).append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, 500) .attr(&#x27;height&#x27;, 500) .style(&#x27;background-color&#x27;, &#x27;yellow&#x27;);d3.csv(&#x27;data.csv&#x27;, type, function(error, data) &#123; if ( error ) throw error; render(data);&#125;); scale 메소드가 없다면 12345678910111213141516function render(data) &#123; var circle = svg.selectAll(&#x27;circle&#x27;) .data(data) .enter() .append(&#x27;circle&#x27;) .attr(&#x27;cx&#x27;, function(d) &#123; return d.x; &#125;) .attr(&#x27;cy&#x27;, function(d) &#123; return d.y; &#125;) .attr(&#x27;r&#x27;, function(d) &#123; return d.r; &#125;) .attr(&#x27;fill&#x27;, &#x27;red&#x27;);&#125; 데이터의 값의 따라 크기를 무조건 정하면 첫번째의 경우는 아주 작은점으로 나타나고 좀 더 scale을 키워서 나타내기를 원할 것이다.반대로 데이터값이 클경우 원의 크기가 svg 영역을 넘을 수도 있다는 것이다. 이때 scale 메소드를 이용하면 svg 영역 비율에 맞게 자동으로 scale 비율이 맞춰진다. 123d3.scaleLinear() .domain([최소값, 최대값]) .range([최소값, 최대값]); 기본 구조는 이렇게 생겼으며 domain(참조범위)이고 range(반환범위) 이다.메서드의 동작은 시각화 할때 데이터밧은 domain()이고 그 값에 대해 반환되는 값이 range() 이다. 12345var scale = d3.scaleLinear().domain([0, 10]).range([0, 100]);scale(2) =&gt; 20 반환scale(5) =&gt; 50 반환scale(10) =&gt; 100 반환 위 예제 코드 구문에서 12var rScale = d3.scaleLinear().domain([0, 10]).range([0, 50]);var colorScale = d3.scaleLinear().domain([0, 10]).range([&#x27;red&#x27;, &#x27;blue&#x27;]); rScale의 참조할 범위가 [010]이 되는데 여기서 반환범위가 [050]이 된다.colorScale의 참조할 범위가 [0~10]이 되는데 반환범위가 [‘red’, ‘blue’]가 된다.여기서 컬러의 반환범위가 숫자가 아니라 문자열이다. 이는 곧 컬러범위를 뜻하며 (R,G,B)가 있으면 (255,0,0) ~ (0,0,,255)까지의 범위가 된다. 123456var circle = svg.selectAll(&#x27;circle&#x27;) ... .attr(&#x27;r&#x27;, function(d) &#123; return rScale(d.r); &#125;) ... 데이터 d.r 의 값을 대입하면 rScale(1) &#x3D;&gt; 5 반환 rScale(3) &#x3D;&gt; 15 반환 rScale(5) &#x3D;&gt; 25 반환 rScale(7) &#x3D;&gt; 35 반환 rScale(9) &#x3D;&gt; 45 반환 12345var circle = svg.selectAll(&#x27;circle&#x27;) ... .attr(&#x27;fill&#x27;, function(d) &#123; return colorScale(d.r); &#125;); 데이터 d.r 의 값을 대입하면 colorScale(1) &#x3D;&gt; rgb(230,0,26) 반환 colorScale(3) &#x3D;&gt; rgb(179,0,77) 반환 colorScale(5) &#x3D;&gt; rgb(128,0,128) 반환 colorScale(7) &#x3D;&gt; rgb(77,0,179) 반환 colorScale(9) &#x3D;&gt; rgb(26,0,230) 반환 이렇게 반혼된 값들은 실제 읽어온 데이터의 값을 유지하면서 시각화 할대의 자동으로 크기나 색이 조절되게 만들 수 있다.d3.scaleLinear() 메소드는 사실 두 값의 범위값으로 해서 반환범위값이 나오는 단순한 방식이다. 참고로 domain()의 들어가는 인자값들을 읽어온 데이터값을 기준으로 재정의 될 수 있고 range()의 반환값들도 좀 더 다양한 형태로 변경할 수 있다. 참조 http://blog.naver.com/PostView.nhn?blogId=zero_kjy&amp;logNo=220788807530&amp;categoryNo=18&amp;parentCategoryNo=0&amp;viewDate=&amp;currentPage=1&amp;postListTopCurrentPage=1&amp;from=postList&amp;userTopListOpen=true&amp;userTopListCount=5&amp;userTopListManageOpen=false&amp;userTopListCurrentPage=1 http://www.bsidesoft.com/?p=2382#d3%25ec%258b%259c%25eb%25a6%25ac%25ec%25a6%2588","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Library","slug":"Frontend/Library","permalink":"https://woonyzzang.github.com/categories/Frontend/Library/"},{"name":"D3.js","slug":"Frontend/Library/D3-js","permalink":"https://woonyzzang.github.com/categories/Frontend/Library/D3-js/"}],"tags":[{"name":"d3","slug":"d3","permalink":"https://woonyzzang.github.com/tags/d3/"}]},{"title":"D3.js Functions","slug":"d3js-function","date":"2017-03-09T17:53:55.000Z","updated":"2024-06-07T09:27:28.286Z","comments":true,"path":"2017/03/10/d3js-function/","permalink":"https://woonyzzang.github.com/2017/03/10/d3js-function/","excerpt":"","text":"D3.js 배열의 유용한 함수d3,js의 배열의 유용한 함수들 이다. 12345678910111213var data = [1, 2, 3, 4, 5];d3.min(data); // 최소값d3.max(data); // 최대값d3.extent(data); // [최소, 최대]d3.extent(data); // 합d3.mean(data); // 산술 평균치d3.median(data); // 배열 위치의 중앙값d3.quantile(data, 0); // 배열 첫번째 값d3.quantile(data, 1); // 배열 마지막 값d3.quantile(data, 0.15); // 분위수(표본전체 도수를 등분하여 등분 값)d3.variance(data); // 분산d3.deviation(data); // 표준편차&lt;/script&gt; 여기서 중요한 함수는 min(), max((), extent()함수를 많이 사용되는 함수이다. 스케일 범위를 결정할때에 읽어온 데이터 값의 최소값이나 최대값을 쉽게 함수로 가져올 수 있다. 1234var data = [1,2,5,6,7];var min = d3.min(data); //최소var max = d3.max(data); //최대var extent = d3.extent(data); //[최소,최대] 여기서 min, max, sum은 문자 그래도 쉽고 extent은 배열로 extent[0]&#x3D;최소값 extent[1]&#x3D;최대값을 갖는다는 것을 기억하기 바란다. 예를 들어 var Scale &#x3D; d3.scaleLinear().domain([0,10]).range([0,100]);&#x3D;&gt; var Scale &#x3D; d3.scaleLinear().domain([d3.min(data), d3.max(data)]).range([0, 100]);&#x3D;&gt; var Scale &#x3D; d3.scaleLinear().domain(d3.extent(data)).range([0, 100]); 효율적으로 데이터의 도메인 값을 잡아 줄 수 있다. var mean &#x3D; d3.mean(data); &#x2F;&#x2F;산술평균치var median &#x3D; d3.median(data); &#x2F;&#x2F;배열위치의 중앙값 mean과 median은 중앙값을 출력하는 함수인데 차이는 어떤 중앙값을 출력하느냐 차이 이다.mean은 산술평균치로서 데이터의총합&#x2F;데이터의 갯수 &#x3D;&gt; (1+2+5+6+7) &#x2F; 5 &#x3D; 4.2 median은 데이터의 갯수의 중앙 위치의 값을 출력 한다. 여기서 [1,2,5,6,7]로 5개의 중앙위치가 3번째로 5가 출력됨만약 [1,2,5,6,7,9]이면 6개로 세번째와 4번째 값의 사이값이 되겠죠, 5~6의 중앙값은 5.5 출력됨. var quantile1 &#x3D; d3.quantile(data, 0); &#x2F;&#x2F; 배열 첫번째 값var quantile2 &#x3D; d3.quantile(data, 1); &#x2F;&#x2F; 배열 마지막 값var quantile3 &#x3D; d3.quantile(data, 0.15); &#x2F;&#x2F; 분위수(표본전체 도수를 등분하여 등분 값) d3.quantile은 0~1까지 범위로 데이터 갯수로 각각 등분 한다. 5개니깐 각각 0.25간격이 됨.[1,2,5,6,7]0일때 10.25일때 20.5일때 50.75일때 61일때 7 그래서, 세번째 data,0.15일때 1.6이 출력되는데 1과2사이는 0과 0.25로 등분된 범위에 맞는 등분값이 출력되어서 1.6이 0.15의 등분값 이다. var variance &#x3D; d3.variance (data); &#x2F;&#x2F;분산var deviation &#x3D; d3.deviation(data); &#x2F;&#x2F;표준편차 나머지는 분산값과 표준편차값을 출력합니다. 설명은 생략한다. scale함수를 좀 더 깊게 다루기 위해서는 우선 알아야 할것들은 min, max, extent 이며, 이 세함수만 우선 알아두면 나중에 scale함수를 사용할때 편리하다. 참조 http://blog.naver.com/PostView.nhn?blogId=zero_kjy&amp;logNo=220790011756&amp;parentCategoryNo=&amp;categoryNo=18&amp;viewDate=&amp;isShowPopularPosts=false&amp;from=postList","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Library","slug":"Frontend/Library","permalink":"https://woonyzzang.github.com/categories/Frontend/Library/"},{"name":"D3.js","slug":"Frontend/Library/D3-js","permalink":"https://woonyzzang.github.com/categories/Frontend/Library/D3-js/"}],"tags":[{"name":"d3","slug":"d3","permalink":"https://woonyzzang.github.com/tags/d3/"}]},{"title":"D3.js Axis API","slug":"d3js-axis","date":"2017-03-09T17:50:04.000Z","updated":"2024-06-07T09:27:28.284Z","comments":true,"path":"2017/03/10/d3js-axis/","permalink":"https://woonyzzang.github.com/2017/03/10/d3js-axis/","excerpt":"","text":"D3.js axis API차트에서 축은 너무나 자주 사용되므로 축을 생성하는 기능을 d3.js안에 내장 되어있다. 축에서는 눈금을 표현해야하고 적당한 값을 넣어줘야하는 등 복잡한 일이 많다만, 이러한 복잡성을 d3.js가 간단히 처리해준다.2차원의 차트에서 축이 올 수 있는 자리는 상하좌우이므로 다음과 같은 함수가 제공된다. axis API d3.axisTop(scale) d3.axisBottom(scale) d3.axisLeft(scale) d3.axisRight(scale) 또한 축을 생성할 때 위에서 설명했던 scale을 넘겨주면 range의 범위를 적절히 판단하여 축을 생성하게 된다. 12345678910111213141516171819&lt;svg id=&quot;graph&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt; &lt;g id=&quot;yaxis&quot;&gt;&lt;/g&gt; // g태그는 하위 엘리먼트 그룹핑 한다. &lt;g id=&quot;xaxis&quot;&gt;&lt;/g&gt;&lt;/svg&gt;&lt;script&gt;var resizer = function resizer() &#123; var h = document.getElementById(&#x27;graph&#x27;).clientHeight; var yscale = d3.scaleLinear() .domain([0, 4955]) // 실제값의 범위 .range([h - 20, 0 + 20]); // 변환할 값의 범위(역으로 처리했음!), 위아래 패딩 20을 줬다! d3.select(&#x27;#yaxis&#x27;) .attr(&#x27;transform&#x27;, &#x27;translate(50, 0)&#x27;) // 살짝 오른쪽으로 밀고 .call(d3.axisLeft(yscale)); // 축함수를 넘기면 알아서 그려줌.&#125;;window.addEventListener(&#x27;resize&#x27;, resizer);resizer(); 확인 해 보면 세로축이 그려진걸 볼 수 있다. 이 그림의 빨간선과 코드를 비교해보죠. 우선 가로로 50만큼 이동시킨 것은 위의 코드 중에 translate(50, 0) 이 부분 없으면 왼쪽에 가려져 버린다. 거의 숙어처럼 축은 translate와 같이 사용될 운명이다. 위 아래 20씩 패딩이 성립한 이유는 .range([h – 20, 0 + 20]); 이렇게 위아래 20을 뒀기 때문이다. 반대로 말하자면 축함수는 range의 값을 픽셀크기로 인식하여 그린다는 것을 알 수 있다. 참조 http://www.bsidesoft.com/?p=2382#d3%25ec%258b%259c%25eb%25a6%25ac%25ec%25a6%2588","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Library","slug":"Frontend/Library","permalink":"https://woonyzzang.github.com/categories/Frontend/Library/"},{"name":"D3.js","slug":"Frontend/Library/D3-js","permalink":"https://woonyzzang.github.com/categories/Frontend/Library/D3-js/"}],"tags":[{"name":"d3","slug":"d3","permalink":"https://woonyzzang.github.com/tags/d3/"}]},{"title":"D3.js","slug":"d3js","date":"2017-03-09T17:45:12.000Z","updated":"2024-06-07T09:27:28.294Z","comments":true,"path":"2017/03/10/d3js/","permalink":"https://woonyzzang.github.com/2017/03/10/d3js/","excerpt":"","text":"D3.js 란D3.js (Data-Driven Documents)는 데이터 기반으로 문서를 처리하는 자바스크립트 라이브러리 이다. HTML5, CSS, SVG(Scalable Vector Graphic) 문서 객체를 데이터 기반으로 접근하여 인터렉티브한 정보시각화(그래프 차트)를 구현할 수 있다. 현재 d3.js는 2016년 6월 새롭게 런칭된 v4.x버전으로 기존 v3.x 버전과 문법이 변경 되어 이미 출간된 대부분의 책들의 API나 인터넷에 기술된 자료들이 맞지 않았다.그렇기에 주의할 부분은 아마 기존에 나온 튜토리얼이나 예제들 이기에 v3.x 버전으로 변경해서 에러 없이 확인이 가능할 것이다. setup 12345&lt;script src=&quot;https://d3js.org/d3.v4.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;d3.select(&#x27;body&#x27;) .text(&#x27;Hello World!&#x27;);&lt;/script&gt; 참조 https://d3js.org/ https://github.com/zziuni/d3/wiki http://blog.naver.com/PostView.nhn?blogId=zero_kjy&amp;logNo=220766869657&amp;categoryNo=18&amp;parentCategoryNo=0&amp;viewDate=&amp;currentPage=6&amp;postListTopCurrentPage=&amp;from=postList&amp;userTopListOpen=true&amp;userTopListCount=5&amp;userTopListManageOpen=false&amp;userTopListCurrentPage=6","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Library","slug":"Frontend/Library","permalink":"https://woonyzzang.github.com/categories/Frontend/Library/"},{"name":"D3.js","slug":"Frontend/Library/D3-js","permalink":"https://woonyzzang.github.com/categories/Frontend/Library/D3-js/"}],"tags":[{"name":"d3","slug":"d3","permalink":"https://woonyzzang.github.com/tags/d3/"}]},{"title":"Javascript Scroll Top Bottom Move","slug":"javascript-scroll-top-bottom","date":"2017-02-26T07:51:11.000Z","updated":"2024-06-10T04:53:59.572Z","comments":true,"path":"2017/02/26/javascript-scroll-top-bottom/","permalink":"https://woonyzzang.github.com/2017/02/26/javascript-scroll-top-bottom/","excerpt":"","text":"JavaScript 스크롤 가장 위, 아래로 이동하기웹사이트 개발시 푸터 하단에 Top버튼 클릭시 상단으로 이동하는 이벤트 핸들러에 적용된다. body 스크롤 위로 이동 12345//Javascriptdocument.body.scrollTop = 0;//jQuery$(&#x27;html, body&#x27;).scrollTop(0); div (overflow:scroll) 스크롤 가장 위로 이동 12345678//Javascriptdocument.getElementById(&#x27;mydiv&#x27;).scrollTop = 0;//jQuery$(&quot;#mydiv&quot;).scrollTop(0);//jQuery 스크롤 모션$(&quot;#mydiv&quot;).stop().animate(&#123;scrollTop: 0&#125;, 200); ajax로 얻어온 데이터를 div 태그에 뿌려주다보면 넘쳐서 스크롤바가 생기는 경우가 많다.가장 대표적인 예가 채팅 프로그램을 만들 때 가장 아래로 스크롤을 유지해야하는데, div에 내용이 추가되고 나서 아래의 자바스크립트를 사용하면 된다. body 스크롤 가장 아래로 이동 12345//Javascriptdocument.body.scrollTop = document.body.scrollHeight;//jQuery$(&#x27;html, body&#x27;&#x27;).scrollTop($(document).height()); div (overflow:scroll) 스크롤 가장 아래로 이동 12345678//Javascriptdocument.getElementById(&#x27;mydiv&#x27;).scrollTop = document.getElementById(&#x27;mydiv&#x27;).scrollHeight;//jQuery$(&quot;#mydiv&quot;).scrollTop($(&quot;#mydiv&quot;)[0].scrollHeight);//jQuery 스크롤 모션$(&quot;#mydiv&quot;).stop().animate(&#123;scrollTop: $(&quot;#mydiv&quot;)[0].scrollHeight&#125;, 200); 참조 http://unikys.tistory.com/285","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Javascript","slug":"Frontend/Javascript","permalink":"https://woonyzzang.github.com/categories/Frontend/Javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://woonyzzang.github.com/tags/js/"}]},{"title":"Angular.js v1.0 Tip","slug":"angularjs-v1-tip","date":"2017-02-26T07:48:03.000Z","updated":"2024-06-07T09:27:28.260Z","comments":true,"path":"2017/02/26/angularjs-v1-tip/","permalink":"https://woonyzzang.github.com/2017/02/26/angularjs-v1-tip/","excerpt":"","text":"Angular.js v1.0 TipngBind를 고려해 보자 앵귤러를 사용하다 보면 인터폴레이션 문자열이 순간적으로 나오는데 왜 그러는지 또 어떻게 해결해야 하는지 의문이 든다. 인터폴레이션 문법을 사용했던 손쉽게 타이핑할 수 있기 때문인데 사실은 인터폴레이션을 사용한 곳의 모든 코드를 ngBind 디렉티브로 변경해서 사용한다. 그러면 스콥 변수에 데이터가 할당될 때까지는 빈 문자열이 출력 되기 때문이다. 12&lt;p&gt;Hello &lt;/p&gt;&lt;p&gt;Hello &lt;span ng-bind=&quot;name&quot;&gt;&lt;/span&gt;&lt;/p&gt; One Time Binding (::)을 사용하자 그럼에도 불구하고 인터폴레이션을 사용해야 할때는 원타임바인딩(One time binding)을 사용하는 것을 고려해 볼 수 있다. 일단 그냥 바인딩 하게되면 스콥 변수의 변화에 따라 뷰에 출력되는 값이 달라진다. 이것은 스콥에서 그 바인딩된 변수를 감시(watch)하고 있기 때문인데 바인딩된 변수가 많을수록 감시해야 할 것은 많아지고 브라우져는 메모리를 더 많이 사용하게 된다.한편 원타임바인딩을 사용하게 되면 스콥변수에 할당된 초기값만 뷰에 출력된다. 이후 그 변수의 값이 변경 되더라도 뷰는 업데이트되지 않는다. 이것은 스콥 변수가 바인딩된 변수를 감시하지 않기 때문이며 그만큼 메모리를 절약할 수 있다. 12&lt;p&gt;Normal binding: &lt;b&gt;Hello &#123;&#123;name&#125;&#125;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;One time binding: &lt;b&gt;Hello &#123;&#123;::name&#125;&#125;&lt;/b&gt;&lt;/p&gt; 참조 http://webframeworks.kr/tutorials/angularjs/angular-facts-easy-to-miss/","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"SPA","slug":"Frontend/SPA","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/"},{"name":"Angular.js","slug":"Frontend/SPA/Angular-js","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/Angular-js/"}],"tags":[{"name":"angular v1","slug":"angular-v1","permalink":"https://woonyzzang.github.com/tags/angular-v1/"}]},{"title":"Require.js Plugin","slug":"requirejs-plugin","date":"2017-02-23T16:23:22.000Z","updated":"2024-06-07T09:27:28.374Z","comments":true,"path":"2017/02/24/requirejs-plugin/","permalink":"https://woonyzzang.github.com/2017/02/24/requirejs-plugin/","excerpt":"","text":"Require.js 플러그인 텍스트 로딩과 HTML 템플릿 관리require.js는 몇 가지 플러그인을 제공한다. 이 중 text 플러그인은 JS 파일 외에도 CSS와 HTML같은 텍스트 파일도 불러올 수 있게 한다. 간단히 다음과 같이 사용한다. 12345define([ &#x27;text!/template.html&#x27; // 플러그인은 플러그인 이름 뒤에 !를 붙인다.], function (templateHTML) &#123; //&#125;); 이를 사용하면 현재 페이지에 노출되진 않지만 갖고 있어야 되는 HTML 조각들(Fragments)을 동적으로 관리할 수 있다. 12345678910111213require([ &#x27;jquery&#x27;, &#x27;text!/sections/layer1.html&#x27;, &#x27;text!/sections/layer2.html&#x27;, &#x27;text!/sections/layer3.html&#x27;], function ($, layer1html, layer2html, layer3html) &#123; var $body = $(document.body), $layer1 = $(layer1html), $layer2 = $(layer2html), $layer3 = $(layer3html); $body.append($layer1);&#125;); 위 HTML에 해당하는 CSS 파일도 동적으로 가져올 수 있지만 CSS는 한 번만 정의하면 페이지에 적용할 수 있고 , 용량도 작은 편이기 때문에 전통적인 방법으로 관리하는 것이 더 합리적이다.","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Module","slug":"Frontend/Module","permalink":"https://woonyzzang.github.com/categories/Frontend/Module/"},{"name":"Require.js","slug":"Frontend/Module/Require-js","permalink":"https://woonyzzang.github.com/categories/Frontend/Module/Require-js/"}],"tags":[{"name":"loader","slug":"loader","permalink":"https://woonyzzang.github.com/tags/loader/"},{"name":"requirejs","slug":"requirejs","permalink":"https://woonyzzang.github.com/tags/requirejs/"}]},{"title":"Require.js","slug":"requirejs","date":"2017-02-23T12:57:55.000Z","updated":"2024-06-07T09:27:28.375Z","comments":true,"path":"2017/02/23/requirejs/","permalink":"https://woonyzzang.github.com/2017/02/23/requirejs/","excerpt":"","text":"Require.js란requirejs는 자바스크립트 코드들을 모듈화 관리가 가능한 프레임워크 이며, AMD(Asynchronous Module Definition) 모듈 로딩 표준을 따르기에 기본적으로 모든 모듈을 비동기적으로 처리한다. 또한 자바스크립트 모듈의 의존관계등의 관리도 쉽게 할수 있게 도와준다. 모듈 정의와 사용 모듈을 정의하는 기본 형태는 다음과 같다. 12345678910111213141516171819202122232425262728293031323334-js/foo.js// 모듈 정의의 기본 형태define([ // 의존 모듈들을 나열한다. 모듈이 한 개라도 배열로 넘겨야 한다. &#x27;js/util&#x27;, &#x27;js/Ajax&#x27;, &#x27;js/Event&#x27;], function (util, Ajax, Event) &#123; // 의존 모듈들은 순서대로 매개변수에 담긴다. // 의존 모듈들이 모두 로딩 완료되면 이 함수를 실행한다. // 초기화 영역 var i = 0; function increase() &#123; i++; &#125; function get() &#123; return i; &#125; // 외부에 노출할 함수들만 반환한다. return &#123; increase: increase, get: get &#125;;&#125;);-js/main.jsrequire([ &#x27;js/foo&#x27;], function (foo) &#123; console.log(foo.get()); // 0 foo.increase(); console.log(foo.get()); // 1&#125;); 모듈의 이름을 명시적으로 설정할 수도 있지만 이름 없는 모듈로 정의하는 것을 권장한다. 이름 없는 모듈은 호출될 때 모듈의 위치에 따라 이름을 결정한다. 개발할 때 파일의 이름이나 위치는 자주 변경되므로 유연한 상태로 둘 필요가 있다. 설정 옵션 require.js는 여러 설정 옵션들을 제공한다. 대표적인 옵션은 다음과 같다. 1234567891011121314151617181920&lt;script&gt;// RequireJS 설정 객체// require.js가 로딩되면 이 객체를 자동으로 읽어 들여 반영한다.var require = &#123; baseUrl: &#x27;/js/app&#x27;, paths: &#123; &#x27;lib&#x27;: &#x27;../lib&#x27; // &quot;/js/lib&quot; 과 동일하다. baseUrl 기준 &#125;, shim: &#123; &#x27;modernizr&#x27;: &#123; // Modernizr 라이브러리 exports: &#x27;Modernizr&#x27; &#125; &#125;, urlArgs : &#x27;ts=&#x27; + (new Date()).getTime()&#125;;&lt;/script&gt; &lt;script src=&quot;/js/lib/require.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // code...&lt;/script&gt; var require &#x3D; {}; 설정은 require.js 파일의 로딩 전에 사용하는 방법 이다.require.js 파일을 로딩한 후에는 require.config() 함수를 사용하여 설정할 수 있다. 모듈 위치 1234567891011121314151617/* /index.html */&lt;script&gt; var require = &#123; baseUrl: &#x27;/js/app&#x27;&#125;;&lt;/script&gt; &lt;script src=&quot;/js/lib/require.js&quot;&gt;&lt;/script&gt; &lt;script&gt; require([ &#x27;common/relative&#x27;, // (1) 위치: &quot;/js/app/common/relative.js&quot; &#x27;dotjs.js&#x27;, // (2) 위치: &quot;/dotjs.js&quot; &#x27;/js/lib/absolute.js&#x27;, // (3) 위치: &quot;/js/lib/absolute.js&quot; &#x27;http://another.com/foo.js&#x27; // (4) 위치: &quot;http://another.com/foo.js&quot;], function (relative, dotjs, absolute, foo) &#123; // code...&#125;);&lt;/script&gt; (1)의 경우가 일반적인 사용이며, (2), (3), (4)는 특별한 경우가 아니면 사용할 일이 없지만 알아 둘 필요는 있다.(2)의 경우 baseUrl이 설정을 무시하고 현재 페이지의 경로를 사용한 결과이다. (3), (4)는 절대 경로로 이름을 지정한 경우이며 꼭 이름의 뒤에 ‘.js’를 붙여야 한다. 모듈이 아닌 외부 라이브러리 사용 AMD를 지원하지 않는 외부의 좋은 라이브러리를 사용하려면 paths와 shim 설정 옵션을 사용한다. 외부 라이브러리를 모듈처럼 사용할 수 있게 한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667-config.jsrequirejs.config(&#123; // 모듈의 기본 위치를 지정한다. baseUrl: &#x27;vendor&#x27;, // 모듈의 단축 경로 지정 또는 이름에 대한 별칭(Alias)을 지정할 수 있다. // &quot;.js&quot;는 자동 추가 paths: &#123; app: &#x27;../app&#x27;, // 배열로 선언시 첫번째 파일 로드 실패 시 두번째 파일을 로드한다. jquery: [ &#x27;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min&#x27;, &#x27;jquery/dist/jquery.min&#x27; ], underscore: [ &#x27;https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min&#x27;, &#x27;underscore/underscore-min&#x27; ], text: [ &#x27;https://cdnjs.cloudflare.com/ajax/libs/require-text/2.0.12/text.min&#x27;, &#x27;text/text&#x27; ], backbone: [ &#x27;https://cdnjs.cloudflare.com/ajax/libs/backbone.js/1.3.3/backbone-min&#x27;, &#x27;backbone/backbone-min&#x27; ], bootstrap: [ &#x27;https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.0.0-alpha.6/js/bootstrap.min&#x27;, &#x27;bootstrap/dist/js/bootstrap.min&#x27; ] &#125;, // 타임스탬프 // 모듈 위치 URL뒤에 덧붙여질 쿼리를 설정한다. // 개발 환경에서는 브라우저 캐시를 회피하기 위해 사용할 수 있고, // 실제 서비스 환경이라면 bust값을 배포한 시간으로 설정하여 새로 캐시하게 할 수 있다. //urlArgs: &#x27;bust=&#x27; + (new Date()).getTime(), // 타이머 지연(타이머 관련 에러시 대처) //waitSeconds: 200, // AMD를 지원하지 않는 외부 라이브러리를 모듈로 사용할 수 있게 한다. ex) modernizr // jQuery의 경우 paths 설정만으로 사용 가능한 이유는 jQuery가 사실 AMD를 지원하기 때문이다. // jQuery 소스의 마지막 부분을 살펴보면 define으로 모듈을 반환하는 코드를 볼 수 있다. shim: &#123; /*jquery: &#123; exports: &#x27;$&#x27; &#125;, underscore: &#123; exports: &#x27;_&#x27; &#125;, text: &#123; deps: [&#x27;underscore&#x27;], exports: &#x27;text&#x27; &#125;, backbone: &#123; deps: [&#x27;jquery&#x27;, &#x27;underscore&#x27;], exports: &#x27;Backbone&#x27; &#125;,*/ bootstrap: &#123; deps: [&#x27;jquery&#x27;] &#125; &#125;&#125;);// Load the main app module to start the apprequirejs([&#x27;app/main&#x27;]); // 여기서 app은 상단의 paths.app 의 프로퍼티 값의 경로를 뜻한다. 1234567891011-app/main.jsrequire([ &#x27;jquery&#x27;, &#x27;underscore&#x27;, &#x27;backbone&#x27;, &#x27;text!/backbone/header.html&#x27;, &#x27;text!/backbone/home.html&#x27;, &#x27;text!/backbone/footer.html&#x27;], function($, _, Backbone, headerTempl, homeTempl, footerTempl) &#123; // code...&#125;); 참조 http://requirejs.org/ http://d2.naver.com/helloworld/591319","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Module","slug":"Frontend/Module","permalink":"https://woonyzzang.github.com/categories/Frontend/Module/"},{"name":"Require.js","slug":"Frontend/Module/Require-js","permalink":"https://woonyzzang.github.com/categories/Frontend/Module/Require-js/"}],"tags":[{"name":"loader","slug":"loader","permalink":"https://woonyzzang.github.com/tags/loader/"},{"name":"requirejs","slug":"requirejs","permalink":"https://woonyzzang.github.com/tags/requirejs/"}]},{"title":"[Chrome] Developer Tools Console","slug":"chrome-console","date":"2017-02-23T12:42:07.000Z","updated":"2024-06-14T10:41:36.571Z","comments":true,"path":"2017/02/23/chrome-console/","permalink":"https://woonyzzang.github.com/2017/02/23/chrome-console/","excerpt":"","text":"Chrome 개발자도구 콘솔 명령어브라우저별 개발자 도구가 계속 발전하고 있어서 웹 개발과 디버깅 시간이 많이 단축되었다.개발자 도구에 많은 기능 중 유용한 콘솔 API만 몇가지 정리한다. 크롬 개발자 도구 콘솔 팁 1.콘솔에서 selecter 사용이 가능하다. 12// $(&#x27;tagName&#x27;), $(&#x27;.class&#x27;), $(&#x27;#id&#x27;)$$(&#x27;tagName&#x27;) #매칭되는 셀렉터 DOM 엘리먼트 전부 반환 2.콘솔에서 document.body.contentEditable&#x3D;true 를 입력하면 해당영역이 에디터로 변하면서 모든 DOM element 수정이 가능하다. 3.DOM element에 걸린 이벤트 리스너 가져오기 12345getEventListeners($(&#x27;selector&#x27;));getEventListeners($(&#x27;selector&#x27;)).click[0].listener #클릭이벤트의 첫번째 이벤트 리스너getEventListeners($(&#x27;selector&#x27;)[0]);getEventListeners($$(&#x27;selector&#x27;)[0]);getEventListeners($0); #특정 DOM element 이벤트 리스너 (해당 엘리먼트 선택후 콘솔에서 커맨드 입력) 4.이벤트 모니터링팁) DOM 트리에 특정 element에서 발생하는 이벤트를 추적하는 방법http://stackoverflow.com/questions/10213703/how-do-i-view-events-fired-on-an-element-in-chrome-devtools/15923770#15923770 1234monitorEvents($(&#x27;selector&#x27;)); #이벤트 전부 모니터링monitorEvents($(&#x27;selector&#x27;), &#x27;eventName&#x27;); #특정 이벤트 하나만 모니터링 monitorEvents($(&#x27;selector&#x27;), [&#x27;eventName1&#x27;, &#x27;eventName3&#x27;, ….]); #이벤트 여러개 모니터링 unmonitorEvents($(&#x27;selector&#x27;)); #이벤트 모니터링 중지 5.실행시간 체크 123456console.time(&#x27;timer&#x27;); #시작for(var i=0; i &lt; 100000; i++)&#123; 2+4+5;&#125;console.timeEnd(&#x27;timer&#x27;); #실행시간 출력 //Output - timer:12345.00 ms 6.배열&#x2F;오브젝트 변수값을 테이블 형태로 보기 12var myArray = [&#123;a:1,b:2,c:3&#125;,&#123;a:1,b:2,c:3,d:4&#125;,&#123;k:11,f:22&#125;,&#123;a:1,b:2,c:3&#125;]console.table(myArray); 7.특정 DOM element inspect (개발자 도구의 Elements 탭으로 바로 이동) 12345inpect($(&#x27;selector&#x27;));inpect($(&#x27;a&#x27;)[1]); #2번재 a태그$0 = 직전에 inspect 했던 element(-1)$1 = 직전에 inspect 했던 element(-2)$2, $3... 8.디렉토리 형태로 property 보기 1dir($(&#x27;selector&#x27;)); 9.직전 결과값 가져오기 1$_ #예를 들어 5 + 5 같은 수식을 콘솔에 적으면 결과값은 키보드 위, 아래를 눌러 보아도 값을 사용할 수 없을 때 사용하면 된다. 10.콘솔 &amp; 메모리 삭제하기 1clear(); #단축키 ctrl + L 참조 https://medium.freecodecamp.com/10-tips-to-maximize-your-javascript-debugging-experience-b69a75859329#.luq41ijrx","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"Javascript","slug":"Frontend/Javascript","permalink":"https://woonyzzang.github.com/categories/Frontend/Javascript/"}],"tags":[{"name":"chrome","slug":"chrome","permalink":"https://woonyzzang.github.com/tags/chrome/"},{"name":"js","slug":"js","permalink":"https://woonyzzang.github.com/tags/js/"}]},{"title":"Backbone.js Sync","slug":"backbonejs-sync","date":"2017-02-23T12:40:53.000Z","updated":"2024-06-07T09:27:28.266Z","comments":true,"path":"2017/02/23/backbonejs-sync/","permalink":"https://woonyzzang.github.com/2017/02/23/backbonejs-sync/","excerpt":"","text":"Backbone SyncBackbone.js의 Sync기능은 기본적으로 Restful한 서버에서 동작 하며, Ajax 데이터 전송을 당담한다.CRUD method를 지원(‘create’, ‘read’, ‘update’, ‘delete’) Backbone.sync is sync(method, model, [options]); create -&gt; POST &#x2F;collection read -&gt; GET &#x2F;collection[&#x2F;id] update -&gt; PUT &#x2F;collection&#x2F;id patch -&gt; PATCH &#x2F;collection&#x2F;id delete -&gt; DELETE &#x2F;collection&#x2F;id Backbone.Sync 메소드 테스트 다음과 같이 전역 Sync 메소드를 구현하면 원래의 Sync기능을 오버라이드 한다. 즉, Restful하지 않은 서버와 통신해야 할 때, 이 함수를 구현하면 된다. 12345Backbone.sync = function(method, model)&#123; console.info(&#x27;전역 Sync메소드 호출[s]&#x27;); console.info(method + &#x27;:&#x27; + JSON.stringify(model.toJSON(), &#x27;&#x27;, 4)); console.info(&#x27;전역 Sync메소드 호출[e]&#x27;);&#125;; Backbone.Model.Sync, Backbone.Collection.Sync 메소드 테스트 이들 모두 오버라이드 가능한 sync메소드가 있다. 이 부분을 오버라이드 하면 Restful하지 않은 서버와 통신할 수 있게 된다. 1234567891011121314151617181920212223242526272829//모델 선언var User = Backbone.Model.extend(&#123; //모델 생성시의 초기값 설정 defaults: &#123; id:1, name:&#x27;익명&#x27; &#125;, urlRoot: &#x27;/users&#x27;, idAttribute:&#x27;id&#x27;, //이 부분을 오버라이드 하면 Restful하지 않은 서버와 통신할 수 있게 됩니다. sync:function(method, model, options)&#123; console.info(&#x27;모델의 Sync메소드 호출[s]&#x27;); console.info(method + &#x27;:&#x27; + JSON.stringify(model.toJSON(),&#x27;&#x27;,4)); console.info(&#x27;모델의 Sync메소드 호출[e]&#x27;); &#125;&#125;);//모델 생성var user = new User();user.fetch(); //전체 리스트를 Readuser.at(0).fetch(); //레코드 1개를 Readuser.create(&#123;title:&#x27;999&#x27;,category:&#x27;구구구&#x27;&#125;); //레코드 1개를 Createuser.at(0).set(&#123;name:&#x27;변경된 이름&#x27;&#125;).save(); //레코드 1개를 Updateuser.at(0).remove(); //레코드 1개를 Delete//모델 생성var user2 = new User(&#123;id:2, name:&#x27;woonyzzang&#x27;&#125;); // 모델생성과 동시에 신규모델 추가user2.save(); //모델 업데이트user2.destroy(); //모델 삭제 Backbone.sync, Backbone.Model.Sync, Backbone.Collection.Sync 함수를 구현해 주면 Restful하지 않은 서버를 대상으로도 Sync기능을 활용할 수 있다. Backbone.Model과 Backbone.Collection의 defaults 프로퍼티에 id 어트리뷰트를 삽입하면 Sync의 create명령이 update명령으로 오동작할 수 있다. 참조 http://backbonejs.org/#Router http://www.slideshare.net/jinkwonlee52/backbonejs-40817718 https://cinos81.bitbucket.io/blog/_site/javascript/2016/01/04/backboneSync-javascript.html","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"SPA","slug":"Frontend/SPA","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/"},{"name":"Backbone.js","slug":"Frontend/SPA/Backbone-js","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/Backbone-js/"}],"tags":[{"name":"backbone","slug":"backbone","permalink":"https://woonyzzang.github.com/tags/backbone/"}]},{"title":"Backbone.js Router","slug":"backbonejs-router","date":"2017-02-23T12:39:35.000Z","updated":"2024-06-07T09:27:28.265Z","comments":true,"path":"2017/02/23/backbonejs-router/","permalink":"https://woonyzzang.github.com/2017/02/23/backbonejs-router/","excerpt":"","text":"Backbone Router라우터 기능으로 MVC에서의 Controller 해당되며, location.hash(url 변경)의 변경에 따른 처리를 담당한다. 1234567891011121314var Router = Backbone.View.extend(&#123; routes: &#123; &#x27;&#x27;: &#x27;home&#x27;, //#default help: &#x27;help&#x27;, //#help &#x27;search/:query&#x27;: &#x27;search&#x27; //#search/test, &#x27;search/:query/p:page&#x27;: &#x27;search&#x27; //#search/test/p7 &#125;, home: function() &#123; console.log(&#x27;home&#x27;); &#125;, search: function(query, page) &#123; console.log(query, page); &#125;&#125;); 참조 http://backbonejs.org/#Router http://www.slideshare.net/jinkwonlee52/backbonejs-40817718","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"SPA","slug":"Frontend/SPA","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/"},{"name":"Backbone.js","slug":"Frontend/SPA/Backbone-js","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/Backbone-js/"}],"tags":[{"name":"backbone","slug":"backbone","permalink":"https://woonyzzang.github.com/tags/backbone/"}]},{"title":"Backbone.js Collection","slug":"backbonejs-collection","date":"2017-02-23T12:38:07.000Z","updated":"2024-06-07T09:27:28.263Z","comments":true,"path":"2017/02/23/backbonejs-collection/","permalink":"https://woonyzzang.github.com/2017/02/23/backbonejs-collection/","excerpt":"","text":"Backbone CollectionModel의 집합. View와 연결되어, Model에 변화가 생길 때 손쉽게 View(UI)를 갱신할 수 있다. 12345678910111213141516171819202122232425262728293031323334353637383940//모델 선언var Book = Backbone.Model.extend(&#123; //모델 생성시의 초기값 설정 defaults: &#123; //id: 1, &lt;=모델 생성 초기값에 id속성을 넣으면 Create명령 대신, Update명령을 실행하니 주의할것! title: &#x27;untitled&#x27;, category: &#x27;none&#x27; &#125;, urlRoot: &#x27;/books&#x27;, idAttribute: &#x27;id&#x27;&#125;);var book1 = new Book(&#123;title: &#x27;javascript&#x27;, category: &#x27;개발&#x27;&#125;); //모델 생성var book2 = new Book(&#123;title: &#x27;photoshop&#x27;, category: &#x27;디자인&#x27;&#125;); //모델 생성//컬렉션 선언var Books = Backbone.Collection.extend(&#123; model: Book, url: &#x27;/books&#x27;, //초기화 initialize: function()&#123; this.on(&#x27;add&#x27;, function(model, collection)&#123; console.log(&#x27;컬렉션의 add이벤트 핸들러 반응함&#x27;); &#125;); this.on(&#x27;remove&#x27;, function(model, collection)&#123; console.log(&#x27;컬렉션의 remove이벤트 핸들러 반응함&#x27;); &#125;); //모델 내부 name프로퍼티의 change이벤트핸들러 this.on(&#x27;change:title&#x27;, function(model, value)&#123; console.log(&#x27;컬렉션의 change이벤트 핸들러 반응함&#x27;); &#125;); &#125;&#125;);//컬렉션 생성var books = new Books();books.add([book1, book2]); //컬렉션에 배열로 push 한다. 참조 http://backbonejs.org/#Collection http://www.slideshare.net/jinkwonlee52/backbonejs-40817718","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"SPA","slug":"Frontend/SPA","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/"},{"name":"Backbone.js","slug":"Frontend/SPA/Backbone-js","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/Backbone-js/"}],"tags":[{"name":"backbone","slug":"backbone","permalink":"https://woonyzzang.github.com/tags/backbone/"}]},{"title":"Backbone.js View","slug":"backbonejs-view","date":"2017-02-23T12:36:23.000Z","updated":"2024-06-07T09:27:28.267Z","comments":true,"path":"2017/02/23/backbonejs-view/","permalink":"https://woonyzzang.github.com/2017/02/23/backbonejs-view/","excerpt":"","text":"Backbone ViewModel을 어떻게 보여줄지 View와 관련된 Event를 Listen &amp; React 하는 역할.화면에 나타나는 UI를 담당하며 프론트엔드의 특성상 view가 controller의 성격도 가지고 있다. 12345678910111213141516171819&lt;input type=&quot;input&quot; placeholder=&quot;검색어 입력&quot;&gt;//뷰 선언var Book = Backbone.View.extend(&#123; //초기화 initialize: function() &#123; console.log(&#x27;초기생성&#x27;); &#125;, //이벤트 핸들러 바인딩 events: &#123; &#x27;keydown input[type=input]&#x27; : &#x27;doSearch&#x27; &#125;, doSearch: function(event) &#123; console.log(&#x27;doSearch&#x27;); &#125;&#125;);//뷰 생성var book = new Book(); 참조 http://backbonejs.org/#View http://www.slideshare.net/jinkwonlee52/backbonejs-40817718","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"SPA","slug":"Frontend/SPA","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/"},{"name":"Backbone.js","slug":"Frontend/SPA/Backbone-js","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/Backbone-js/"}],"tags":[{"name":"backbone","slug":"backbone","permalink":"https://woonyzzang.github.com/tags/backbone/"}]},{"title":"Backbone.js Model","slug":"backbonejs-model","date":"2017-02-23T12:34:34.000Z","updated":"2024-06-07T09:27:28.264Z","comments":true,"path":"2017/02/23/backbonejs-model/","permalink":"https://woonyzzang.github.com/2017/02/23/backbonejs-model/","excerpt":"","text":"Backbone ModelMVC패턴에서의 Model로 개별 데이터를 나타낸다. 12345678910111213141516171819202122232425//모델 선언var Person = Backbone.Model.extend(&#123; //모델 생성시의 초기값 설정 defaults: &#123; age: 30, name: &#x27;woonyzzang&#x27; &#125;, //초기화 initialize: function() &#123; console.log(&#x27;초기생성&#x27;); this.on(&#x27;changeName&#x27;, function() &#123; console.log(&#x27;나이가&#x27; + this.get(&#x27;age&#x27;) + &#x27;변경 되었습니다.&#x27;); &#125;); &#125;, setAge: function(nAge) &#123; this.set(&#x27;age&#x27;, nAge); &#125;&#125;);var person = new Person;person.get(age); //30person.get(name); //woonyzzangperson.setAge(60);person.get(age); //60 참조 http://backbonejs.org/#Model http://www.slideshare.net/jinkwonlee52/backbonejs-40817718","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"SPA","slug":"Frontend/SPA","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/"},{"name":"Backbone.js","slug":"Frontend/SPA/Backbone-js","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/Backbone-js/"}],"tags":[{"name":"backbone","slug":"backbone","permalink":"https://woonyzzang.github.com/tags/backbone/"}]},{"title":"Backbone.js","slug":"backbonejs","date":"2017-02-23T12:30:40.000Z","updated":"2024-06-07T09:27:28.268Z","comments":true,"path":"2017/02/23/backbonejs/","permalink":"https://woonyzzang.github.com/2017/02/23/backbonejs/","excerpt":"","text":"Backbone.js란backbone.js은 클라이언트 사이드 웹애플리케이션 개발에 MVC패턴 적용을 가능하게 해주는 자바스크립트 프레임워크들 중 하나이다. MVC패턴이란 간략하게 M(model: 데이터), V(view: UI), C(controller: 로직, 데이터 처리)로 코드의 역할을 나눠서 작성하고 관리하는걸 뜻한다. 이 말은 클라이언트단에서 프로그램의 구조를 체계화가 가능하다란 말이다. backbone.js는 단일 페이지 웹애플리케이션 SPA(Single Page Application)으로 개발시 사용하면 유용하다. 여기서 단일 페이지란 하나의 마크업된 HTML 페이지, 사용자 인터렉션에 페이지 전환없이 변화되는 컨텐츠 이다. 이런 SPA는 화면갱신(refresh)가 발생하지 않아 사용자 UX 측면에서의 장점이 있다. 그리고 backbone.js는 underscore.js라는 유틸성 라이브러리에 의존성이 있어서, backbone.js를 사용하려면 필수적으로 underscore.js를 꼭 같이 사용해야 한다.공식적으로 jQuery&#x2F;Zepto 사용을 지지한다고 한다. 모듈화 개발로 가능하게 하는 require.js와 같이 사용하면 어느 정도 규모가 있는 자바스크립트 코드들을 모듈화하여 개발도 가능하다. backbone 구조 Model View Collection Router Sync History 참조 http://backbonejs.org/ http://codefactory.kr/2011/12/22/getting-started-with-backbonejs-1-what-is-backbone/","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"SPA","slug":"Frontend/SPA","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/"},{"name":"Backbone.js","slug":"Frontend/SPA/Backbone-js","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/Backbone-js/"}],"tags":[{"name":"backbone","slug":"backbone","permalink":"https://woonyzzang.github.com/tags/backbone/"}]},{"title":"APMSETUP 로컬 서버 환경 구축","slug":"apmsetup","date":"2017-02-20T16:33:43.000Z","updated":"2024-06-07T09:27:28.261Z","comments":true,"path":"2017/02/21/apmsetup/","permalink":"https://woonyzzang.github.com/2017/02/21/apmsetup/","excerpt":"","text":"APMSETUP 이란?APM은 Apach + PHP + MySQL의 약자로 무료로 배포되는 완전한 프리웨어 툴 이며, 로컬에서 웹서버를 구축할 수 있다. Apach, PHP, MySQL 일일히 설치할 필요없이 손쉽게 한번에 설치해주는 프로그램이며, 이 프로그램을 설치한 후 바로 웹서버의 용도로 활용이 가능하다.현재 7버전까지 나와있으며, 다운로드 링크 경로를 통해 받을 수 있다. 설치가 완료되고 바탕화면의 APMSETUP Monitor 아이콘을 클릭하면 Apache와 MySQL을 START하거나 STOP할 수 있는 모니터 창이 나타납니다. Apache와 MySQL 의 서버상태를 START를 활성화 시키면 APMSETUP이 기동된다. 아파치 서버 주소 1http://127.0.0.1 or http://localhost PHP MyAdmin 주소 123http://127.0.0.1/myadmin or http://localhost/myadmin아이디: root비밀번호: apmsetup(초기설정값) APMSETUP 기본 저장 위치 1C:/APM_Setup/htdocs/ APMSETUP 설정 팁색인화 리스트 목록 설정 APMSETUP 기동시 브라우저에 각 폴더링 목록으로 구분하고 싶을 시 유용한 방법이다.C:\\APM_Setup\\Server\\Apache\\conf\\httpd.conf 파일을 열어서 해당 코드에 “Indexes” 코드를 추가 한다. 1234567C:\\APM_Setup\\Server\\Apache\\conf\\httpd.conf&lt;Directory /&gt; Options FollowSymLinks Indexes #Indexes 코드 추가 AllowOverride All Order allow,deny Allow from all&lt;/Directory&gt; 윈도우 하단 상태바의 APMSETUP 마우스 오른쪽 누른다. 서버환경 설정 후 메뉴 &gt; Apache 설정 &gt; DirectoryIndex 의 값을 삭제 한다. 브라우저 url 입력란에 http://127.0.0.1 or http://localhost 입력하면 색인화 리스트 목록 화면으로 나온다.","categories":[{"name":"Tools","slug":"Tools","permalink":"https://woonyzzang.github.com/categories/Tools/"},{"name":"APMSETUP","slug":"Tools/APMSETUP","permalink":"https://woonyzzang.github.com/categories/Tools/APMSETUP/"}],"tags":[{"name":"apmsetup","slug":"apmsetup","permalink":"https://woonyzzang.github.com/tags/apmsetup/"},{"name":"server","slug":"server","permalink":"https://woonyzzang.github.com/tags/server/"}]},{"title":"ionic-v1 ios statusbar text color 변경","slug":"ionic-v1-ios-statusbar-text-color","date":"2017-02-20T16:05:48.000Z","updated":"2024-06-05T05:59:36.446Z","comments":true,"path":"2017/02/21/ionic-v1-ios-statusbar-text-color/","permalink":"https://woonyzzang.github.com/2017/02/21/ionic-v1-ios-statusbar-text-color/","excerpt":"","text":"ios status bar text color 값 변경하기www\\js\\app.js 파일에서 아래 코드를 추가 하고 원하는 컬러값을 지정해주면 된다. 123456789101112www\\js\\app.jsapp.run(function ($ionicPlatform, $cordovaStatusbar) &#123; $ionicPlatform.ready(function () &#123; // Color the iOS status bar if (window.StatusBar) &#123; // $cordovaStatusbar.overlaysWebView(true); $cordovaStatusbar.styleHex(&#x27;#fff&#x27;); #텍스트 컬러값 변경 &#125; &#125;); &#125;); 참조 http://stackoverflow.com/questions/34623373/unable-to-change-cordovastatusbar-text-color/","categories":[{"name":"App","slug":"App","permalink":"https://woonyzzang.github.com/categories/App/"},{"name":"Ionic","slug":"App/Ionic","permalink":"https://woonyzzang.github.com/categories/App/Ionic/"}],"tags":[{"name":"ionic v1","slug":"ionic-v1","permalink":"https://woonyzzang.github.com/tags/ionic-v1/"}]},{"title":"ionic-v1 ios statusbar 이슈","slug":"ionic-v1-ios-statusbar","date":"2017-02-20T15:19:50.000Z","updated":"2024-06-05T05:58:38.244Z","comments":true,"path":"2017/02/21/ionic-v1-ios-statusbar/","permalink":"https://woonyzzang.github.com/2017/02/21/ionic-v1-ios-statusbar/","excerpt":"","text":"아이오닉v1.0 ios status bar 겹치는 이슈아이오닉v1.0에서 아이폰 ios 7이상에서 나타나는 현상으로 상태바와 겹치는 이슈가 있다.이문제를 해결 할려면 cordova-plugin-statusbar 플러그인을 설치한다. 혹시 plugins 디렉토리에 이미 설치되어 있다면 따로 설치할 필요가 없다. 1$ cordova plugin add cordova-plugin-statusbar 플러그인 설치가 완료되면 config.xml 파일에 아래 코드를 추가하면 된다. 123&lt;preference name=&quot;StatusBarOverlaysWebView&quot; value=&quot;false&quot; /&gt; #상태바 오버레이 기능 비활성&lt;preference name=&quot;StatusBarBackgroundColor&quot; value=&quot;#000000&quot; /&gt; #상태바 백그라운드 컬러값 &lt;preference name=&quot;StatusBarStyle&quot; value=&quot;lightcontent&quot; /&gt; #상태바 스타일 옵션값: lightcontent, blacktranslucent, blackopaque 참조 https://github.com/apache/cordova-plugin-statusbar/","categories":[{"name":"App","slug":"App","permalink":"https://woonyzzang.github.com/categories/App/"},{"name":"Ionic","slug":"App/Ionic","permalink":"https://woonyzzang.github.com/categories/App/Ionic/"}],"tags":[{"name":"ionic v1","slug":"ionic-v1","permalink":"https://woonyzzang.github.com/tags/ionic-v1/"}]},{"title":"[Markdown] Syntax","slug":"markdown-syntax","date":"2017-02-20T15:17:49.000Z","updated":"2024-06-14T10:41:36.582Z","comments":true,"path":"2017/02/21/markdown-syntax/","permalink":"https://woonyzzang.github.com/2017/02/21/markdown-syntax/","excerpt":"","text":"Markdown Syntax마크다운 (Markdown)은 마크업 언어의 일종으로, 존 그루버(John Gruber)와 아론 스워츠(Aaron Swartz)가 만들었다. 읽기도 쓰기도 쉽다는 장점이 있다. 그루버는 마크다운으로 작성한 문서를 HTML로 변환하는 펄 스크립트도 만들었다. 확장자는 .md를 쓴다. 문단 제목문단 제목은 다음과 같이 표현한다. 123# 큰 제목## 중간 제목### 작은 제목 또는, 큰 제목과 중간 제목은 다음과 같은 문법도 사용가능하다. 12345큰 제목====================중간 제목--------------------- 문단줄바꿈을 두 번 하면 된다. 123하나의 문단.다른 문단. 목록순서가 부여된 리스트 1231. 첫 번째2. 두 번째3. 세 번째 전부 다 같은 숫자를 넣어도 순서가 제대로 부여된다. 1231. 첫 번째1. 두 번째1. 세 번째 순서없는 리스트는 다음과 같은 문법을 사용한다. 123- 첫 번째- 두 번째- 세 번째 또는, 123* 첫 번째* 두 번째* 세 번째 이탤릭체 1*이탤릭체* 또는, 1_이탤릭체_ 볼드체 1**볼드체** 또는, 1__볼드체__ 취소선 1~~취소선~~ 인용문 1&gt; 인용문 링크 1[텍스트](http://url) 또는, 다음과 같이 써서 참조링크를 쓸 수 있다. 12출처는 [텍스트][link]입니다.[link]: url &quot;툴팁 메세지 표기 생략가능&quot; 또는, 다음과 같이 써서 자동연결링크를 쓸 수 있다. 12&lt;http://example.com/&gt;&lt;address@example.com/&gt; 테이블 1234| 헤더1 | 헤더2 | 헤더3 || ----- | ----- | ----- || 내용1 | 내용2 | 내용3 || 내용1 | 내용2 | 내용3 | 마크다운 테이블 자동생성 코드 1`code` 이미지 1![alt text](이미지.png &quot;툴팁 메시지 표기 생략가능&quot;) 또는, 다음과 같이 써서 주석형태로 그림을 넣을 수 있다. 12![alt text][link][link]: 이미지.png &quot;툴팁 메시지 표기 생략가능&quot; 가로줄 12345* * *********- - ------------- Github-Flavored Markdowngithub에서 쓰이며 다음과 같은 차이점이 있다. 줄바꿈을 한번만 해도 강제개행을 할 수 있다. do_this_and_do_that과 같은 형태의 단어를 기울임꼴 글자로 처리하지 않는다. URL을 자동으로 링크로 변환해준다. 코드를 입력할 때 &#96;&#96;&#96; 로 감싸주는 문법이 추가되었다. 문법 강조가 적용이 된다. Linguist를 이용하여 처리한다. 작업 목록(Task lists) 문법이 추가되었다. Git관련 링크를 자동으로 처리해준다. (SHA, 사용자, 이슈 등) 참조 https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet/ https://namu.wiki/w/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4/","categories":[{"name":"Tools","slug":"Tools","permalink":"https://woonyzzang.github.com/categories/Tools/"},{"name":"Git","slug":"Tools/Git","permalink":"https://woonyzzang.github.com/categories/Tools/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://woonyzzang.github.com/tags/git/"},{"name":"markdown","slug":"markdown","permalink":"https://woonyzzang.github.com/tags/markdown/"}]},{"title":"Webstorm Column Selection Mode","slug":"webstorm-column-selection-mode","date":"2017-02-20T15:16:05.000Z","updated":"2020-09-05T13:07:56.152Z","comments":true,"path":"2017/02/21/webstorm-column-selection-mode/","permalink":"https://woonyzzang.github.com/2017/02/21/webstorm-column-selection-mode/","excerpt":"","text":"WebStrom Column Selection Mode 사용하기Column Selection Mode는 코드 세로 다중영역 선택 기능이다. Edit &gt; Column Selection Mode 를 클릭해서 사용해도 되고, Alt + Shift + Insert 단축키 조합으로도 사용 가능하지만 굳이 단축키 쓸 필요없이 마우스 휠 버튼 누른 상태에서 드래그해도 가능하다. 그러면 사각형 모양으로 다중 영역 선택이 가능하다. 중복된 코드 일괄로 변경시 편리하다.","categories":[{"name":"Editor","slug":"Editor","permalink":"https://woonyzzang.github.com/categories/Editor/"},{"name":"Webstorm","slug":"Editor/Webstorm","permalink":"https://woonyzzang.github.com/categories/Editor/Webstorm/"}],"tags":[{"name":"webstorm","slug":"webstorm","permalink":"https://woonyzzang.github.com/tags/webstorm/"}]},{"title":"Webstorm Plugin Markdown","slug":"webstorm-plugin-markdown","date":"2017-02-20T15:13:44.000Z","updated":"2024-06-05T06:58:14.129Z","comments":true,"path":"2017/02/21/webstorm-plugin-markdown/","permalink":"https://woonyzzang.github.com/2017/02/21/webstorm-plugin-markdown/","excerpt":"","text":"WebStrom Plugin Markdown Preview 기능 설치하기Markdown(.md) 파일 작성시 preview(미리보기) 화면도 같이 보면서 문서 작성 할수 있는 확장 플러그인 이다. PHPStorm은 기본적으로 Markdown support 플러그인이 내장되어 있는거 같은데, 그에 반에 Webstorm은 마크다운 파일 작성시 preview 기능이 없는 듯 했다. Settings &gt; Plugins 창을 확인해 보니 Markdown support 플러그인이 기본적으로 설치 되어 있지 않다. 혹, 설치가 되어 있지 않다면 “markdown”을 검색하여 Markdown support 플러그인 설치 후 체크 활성화 하면 된다. Markdown support 플러그인을 이용하면 별도의 Markdown 에디터 없이 WebStrom 자체 내에서 Preview 기능으로 해결할 수 있어 조금 더 편리하게 README.md 같은 Markdown 파일을 손쉽게 작성할 수 있다.","categories":[{"name":"Editor","slug":"Editor","permalink":"https://woonyzzang.github.com/categories/Editor/"},{"name":"Webstorm","slug":"Editor/Webstorm","permalink":"https://woonyzzang.github.com/categories/Editor/Webstorm/"}],"tags":[{"name":"webstorm","slug":"webstorm","permalink":"https://woonyzzang.github.com/tags/webstorm/"}]},{"title":"Webstorm Plugin Shortcut Translator","slug":"webstorm-plugin-shortcut-translator","date":"2017-02-20T15:08:02.000Z","updated":"2024-06-05T06:58:40.183Z","comments":true,"path":"2017/02/21/webstorm-plugin-shortcut-translator/","permalink":"https://woonyzzang.github.com/2017/02/21/webstorm-plugin-shortcut-translator/","excerpt":"","text":"WebStrom Plugin Markdown Shortcut Translator 기능 설치하기Shortcut Translator 플러그인 설치를 하고 ctrl + shift + k 를 단축키를 누르면 위와 같은 창이 나온다.예를 들어 Alt + Shift + Up 키를 누르면 하단에 Ctrl + W 라고 표시된다.From Eclicpe to Default 이것은 이클립스 단축키를 를 default 단축키로 알려 달라는 뜻이다.즉, 이클립스에서 사용하는 Alt + Shift + Up 단축키는 웹스톰에서는 Ctrl + W 라고 표시된다. 다른 편집기에서 쓰던 단축키를 웹스톰에서 쓰고 싶을때 유용한 플러그인 이다.(반대로, 웹스톰에서 사용하던 단축키를 다른편집기에서 쓰고 싶을때)","categories":[{"name":"Editor","slug":"Editor","permalink":"https://woonyzzang.github.com/categories/Editor/"},{"name":"Webstorm","slug":"Editor/Webstorm","permalink":"https://woonyzzang.github.com/categories/Editor/Webstorm/"}],"tags":[{"name":"webstorm","slug":"webstorm","permalink":"https://woonyzzang.github.com/tags/webstorm/"}]},{"title":"Hello World","slug":"log-hello-world","date":"2017-02-19T08:46:17.000Z","updated":"2024-06-14T10:41:36.581Z","comments":true,"path":"2017/02/19/log-hello-world/","permalink":"https://woonyzzang.github.com/2017/02/19/log-hello-world/","excerpt":"","text":"J Dev 블로그 오픈.J Dev 블로그는 초기에 WordPress를 기반으로 오픈했으나, 추후에 GitHub Pages와 Jekyll로 변경하게 되어 준비중이였다가 이번에 hexo로 최종 변경 하게 되었다. 블로그 환경 WordPress Apache, PHP, MySql Jekyll Ruby, Git, Github hexo Node.js, Git, Github 각각의 장단점이 있지만 WordPress는 유료 호스팅을 이용해야 하고, Jekyll, hexo는 정적페이지 기능을 제공중인 GitHub의 GitHub Pages를 이용한 호스팅을 지원하기 때문에 무료로 이용할 수 있다. Jekyll는 루비환경의 셋팅이 구성되어야 하지만 hexo는 간단하게 Node기반이라서 초기 리소스 비용을 절감할 수 있어 선택하게 되었다. 웹 개발시 프론트엔드 및 백 엔드 기술 공유 목적으로 바탕으로 전반적으로 마크업&#x2F;UI개발 시 실무에 도움이 될 만한 이슈나 팁 등의 컨텐츠들이 주로 구성되어 있으며 개인적으로 관심있는 풀스택 개발에 대한 컨텐츠들도 기재할 예정 이다.","categories":[{"name":"Log","slug":"Log","permalink":"https://woonyzzang.github.com/categories/Log/"}],"tags":[{"name":"log","slug":"log","permalink":"https://woonyzzang.github.com/tags/log/"}]}],"categories":[{"name":"OS","slug":"OS","permalink":"https://woonyzzang.github.com/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"https://woonyzzang.github.com/categories/OS/Linux/"},{"name":"Ubuntu","slug":"OS/Linux/Ubuntu","permalink":"https://woonyzzang.github.com/categories/OS/Linux/Ubuntu/"},{"name":"Server","slug":"Server","permalink":"https://woonyzzang.github.com/categories/Server/"},{"name":"Docker","slug":"Server/Docker","permalink":"https://woonyzzang.github.com/categories/Server/Docker/"},{"name":"Web","slug":"Web","permalink":"https://woonyzzang.github.com/categories/Web/"},{"name":"Architecture","slug":"Web/Architecture","permalink":"https://woonyzzang.github.com/categories/Web/Architecture/"},{"name":"App","slug":"App","permalink":"https://woonyzzang.github.com/categories/App/"},{"name":"Hybrid","slug":"App/Hybrid","permalink":"https://woonyzzang.github.com/categories/App/Hybrid/"},{"name":"Tools","slug":"Tools","permalink":"https://woonyzzang.github.com/categories/Tools/"},{"name":"Git","slug":"Tools/Git","permalink":"https://woonyzzang.github.com/categories/Tools/Git/"},{"name":"IOS","slug":"App/IOS","permalink":"https://woonyzzang.github.com/categories/App/IOS/"},{"name":"Backend","slug":"Backend","permalink":"https://woonyzzang.github.com/categories/Backend/"},{"name":"Node","slug":"Backend/Node","permalink":"https://woonyzzang.github.com/categories/Backend/Node/"},{"name":"Azure","slug":"Server/Azure","permalink":"https://woonyzzang.github.com/categories/Server/Azure/"},{"name":"Teams","slug":"Tools/Teams","permalink":"https://woonyzzang.github.com/categories/Tools/Teams/"},{"name":"Vim","slug":"OS/Linux/Vim","permalink":"https://woonyzzang.github.com/categories/OS/Linux/Vim/"},{"name":"Nuxt","slug":"Backend/Nuxt","permalink":"https://woonyzzang.github.com/categories/Backend/Nuxt/"},{"name":"Zendesk","slug":"Backend/Zendesk","permalink":"https://woonyzzang.github.com/categories/Backend/Zendesk/"},{"name":"Python","slug":"Backend/Python","permalink":"https://woonyzzang.github.com/categories/Backend/Python/"},{"name":"PyScript","slug":"Backend/Python/PyScript","permalink":"https://woonyzzang.github.com/categories/Backend/Python/PyScript/"},{"name":".Net Core","slug":"Backend/Net-Core","permalink":"https://woonyzzang.github.com/categories/Backend/Net-Core/"},{"name":"Frontend","slug":"Frontend","permalink":"https://woonyzzang.github.com/categories/Frontend/"},{"name":"SPA","slug":"Frontend/SPA","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/"},{"name":"JWT","slug":"Frontend/SPA/JWT","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/JWT/"},{"name":"Wasm","slug":"Backend/Wasm","permalink":"https://woonyzzang.github.com/categories/Backend/Wasm/"},{"name":"React.js","slug":"Frontend/SPA/React-js","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/React-js/"},{"name":"Editor","slug":"Editor","permalink":"https://woonyzzang.github.com/categories/Editor/"},{"name":"VSCode","slug":"Editor/VSCode","permalink":"https://woonyzzang.github.com/categories/Editor/VSCode/"},{"name":"CentOS","slug":"OS/Linux/CentOS","permalink":"https://woonyzzang.github.com/categories/OS/Linux/CentOS/"},{"name":"PHP","slug":"Backend/PHP","permalink":"https://woonyzzang.github.com/categories/Backend/PHP/"},{"name":"Wordpress","slug":"Backend/PHP/Wordpress","permalink":"https://woonyzzang.github.com/categories/Backend/PHP/Wordpress/"},{"name":"Javascript","slug":"Frontend/Javascript","permalink":"https://woonyzzang.github.com/categories/Frontend/Javascript/"},{"name":"CSS","slug":"Frontend/CSS","permalink":"https://woonyzzang.github.com/categories/Frontend/CSS/"},{"name":"VMware","slug":"Tools/VMware","permalink":"https://woonyzzang.github.com/categories/Tools/VMware/"},{"name":"Windows","slug":"OS/Windows","permalink":"https://woonyzzang.github.com/categories/OS/Windows/"},{"name":"Mac","slug":"OS/Mac","permalink":"https://woonyzzang.github.com/categories/OS/Mac/"},{"name":"HTML","slug":"Frontend/HTML","permalink":"https://woonyzzang.github.com/categories/Frontend/HTML/"},{"name":"Gitlab","slug":"Server/Gitlab","permalink":"https://woonyzzang.github.com/categories/Server/Gitlab/"},{"name":"Descktop","slug":"Web/Descktop","permalink":"https://woonyzzang.github.com/categories/Web/Descktop/"},{"name":"AWS","slug":"Server/AWS","permalink":"https://woonyzzang.github.com/categories/Server/AWS/"},{"name":"IIS","slug":"Server/IIS","permalink":"https://woonyzzang.github.com/categories/Server/IIS/"},{"name":"Mobile","slug":"Web/Mobile","permalink":"https://woonyzzang.github.com/categories/Web/Mobile/"},{"name":"Library","slug":"Frontend/Library","permalink":"https://woonyzzang.github.com/categories/Frontend/Library/"},{"name":"jQuery","slug":"Frontend/Library/jQuery","permalink":"https://woonyzzang.github.com/categories/Frontend/Library/jQuery/"},{"name":"Module","slug":"Frontend/Module","permalink":"https://woonyzzang.github.com/categories/Frontend/Module/"},{"name":"Webpack","slug":"Frontend/Module/Webpack","permalink":"https://woonyzzang.github.com/categories/Frontend/Module/Webpack/"},{"name":"Fiddler","slug":"Tools/Fiddler","permalink":"https://woonyzzang.github.com/categories/Tools/Fiddler/"},{"name":"SublimeText","slug":"Editor/SublimeText","permalink":"https://woonyzzang.github.com/categories/Editor/SublimeText/"},{"name":"Log","slug":"Log","permalink":"https://woonyzzang.github.com/categories/Log/"},{"name":"Visualstudio","slug":"Editor/Visualstudio","permalink":"https://woonyzzang.github.com/categories/Editor/Visualstudio/"},{"name":"Ionic","slug":"App/Ionic","permalink":"https://woonyzzang.github.com/categories/App/Ionic/"},{"name":"Webstorm","slug":"Editor/Webstorm","permalink":"https://woonyzzang.github.com/categories/Editor/Webstorm/"},{"name":"OpenSSl","slug":"Tools/OpenSSl","permalink":"https://woonyzzang.github.com/categories/Tools/OpenSSl/"},{"name":"Angular.js","slug":"Frontend/SPA/Angular-js","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/Angular-js/"},{"name":"D3.js","slug":"Frontend/Library/D3-js","permalink":"https://woonyzzang.github.com/categories/Frontend/Library/D3-js/"},{"name":"Require.js","slug":"Frontend/Module/Require-js","permalink":"https://woonyzzang.github.com/categories/Frontend/Module/Require-js/"},{"name":"Backbone.js","slug":"Frontend/SPA/Backbone-js","permalink":"https://woonyzzang.github.com/categories/Frontend/SPA/Backbone-js/"},{"name":"APMSETUP","slug":"Tools/APMSETUP","permalink":"https://woonyzzang.github.com/categories/Tools/APMSETUP/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://woonyzzang.github.com/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://woonyzzang.github.com/tags/ubuntu/"},{"name":"docker","slug":"docker","permalink":"https://woonyzzang.github.com/tags/docker/"},{"name":"architecture","slug":"architecture","permalink":"https://woonyzzang.github.com/tags/architecture/"},{"name":"ddd","slug":"ddd","permalink":"https://woonyzzang.github.com/tags/ddd/"},{"name":"cqrs","slug":"cqrs","permalink":"https://woonyzzang.github.com/tags/cqrs/"},{"name":"mvc","slug":"mvc","permalink":"https://woonyzzang.github.com/tags/mvc/"},{"name":"mvvm","slug":"mvvm","permalink":"https://woonyzzang.github.com/tags/mvvm/"},{"name":"hybridApp","slug":"hybridApp","permalink":"https://woonyzzang.github.com/tags/hybridApp/"},{"name":"git","slug":"git","permalink":"https://woonyzzang.github.com/tags/git/"},{"name":"simulator","slug":"simulator","permalink":"https://woonyzzang.github.com/tags/simulator/"},{"name":"jira","slug":"jira","permalink":"https://woonyzzang.github.com/tags/jira/"},{"name":"pr","slug":"pr","permalink":"https://woonyzzang.github.com/tags/pr/"},{"name":"node","slug":"node","permalink":"https://woonyzzang.github.com/tags/node/"},{"name":"azure","slug":"azure","permalink":"https://woonyzzang.github.com/tags/azure/"},{"name":"devops","slug":"devops","permalink":"https://woonyzzang.github.com/tags/devops/"},{"name":"teams","slug":"teams","permalink":"https://woonyzzang.github.com/tags/teams/"},{"name":"vim","slug":"vim","permalink":"https://woonyzzang.github.com/tags/vim/"},{"name":"spa","slug":"spa","permalink":"https://woonyzzang.github.com/tags/spa/"},{"name":"nuxt2","slug":"nuxt2","permalink":"https://woonyzzang.github.com/tags/nuxt2/"},{"name":"zendesk","slug":"zendesk","permalink":"https://woonyzzang.github.com/tags/zendesk/"},{"name":"wasm","slug":"wasm","permalink":"https://woonyzzang.github.com/tags/wasm/"},{"name":"blazor","slug":"blazor","permalink":"https://woonyzzang.github.com/tags/blazor/"},{"name":"jwt","slug":"jwt","permalink":"https://woonyzzang.github.com/tags/jwt/"},{"name":"test","slug":"test","permalink":"https://woonyzzang.github.com/tags/test/"},{"name":"storybook","slug":"storybook","permalink":"https://woonyzzang.github.com/tags/storybook/"},{"name":"vscode","slug":"vscode","permalink":"https://woonyzzang.github.com/tags/vscode/"},{"name":"centos","slug":"centos","permalink":"https://woonyzzang.github.com/tags/centos/"},{"name":"php","slug":"php","permalink":"https://woonyzzang.github.com/tags/php/"},{"name":"wordpress","slug":"wordpress","permalink":"https://woonyzzang.github.com/tags/wordpress/"},{"name":"js","slug":"js","permalink":"https://woonyzzang.github.com/tags/js/"},{"name":"chrome","slug":"chrome","permalink":"https://woonyzzang.github.com/tags/chrome/"},{"name":"css","slug":"css","permalink":"https://woonyzzang.github.com/tags/css/"},{"name":"webfont","slug":"webfont","permalink":"https://woonyzzang.github.com/tags/webfont/"},{"name":"vmware","slug":"vmware","permalink":"https://woonyzzang.github.com/tags/vmware/"},{"name":"windows","slug":"windows","permalink":"https://woonyzzang.github.com/tags/windows/"},{"name":"mac","slug":"mac","permalink":"https://woonyzzang.github.com/tags/mac/"},{"name":"html","slug":"html","permalink":"https://woonyzzang.github.com/tags/html/"},{"name":"html5","slug":"html5","permalink":"https://woonyzzang.github.com/tags/html5/"},{"name":"gitlab","slug":"gitlab","permalink":"https://woonyzzang.github.com/tags/gitlab/"},{"name":"descktop","slug":"descktop","permalink":"https://woonyzzang.github.com/tags/descktop/"},{"name":"visualsvn","slug":"visualsvn","permalink":"https://woonyzzang.github.com/tags/visualsvn/"},{"name":"aws","slug":"aws","permalink":"https://woonyzzang.github.com/tags/aws/"},{"name":"server","slug":"server","permalink":"https://woonyzzang.github.com/tags/server/"},{"name":"asp","slug":"asp","permalink":"https://woonyzzang.github.com/tags/asp/"},{"name":"css3","slug":"css3","permalink":"https://woonyzzang.github.com/tags/css3/"},{"name":"mobile","slug":"mobile","permalink":"https://woonyzzang.github.com/tags/mobile/"},{"name":"jquery","slug":"jquery","permalink":"https://woonyzzang.github.com/tags/jquery/"},{"name":"react","slug":"react","permalink":"https://woonyzzang.github.com/tags/react/"},{"name":"bundler","slug":"bundler","permalink":"https://woonyzzang.github.com/tags/bundler/"},{"name":"webpack","slug":"webpack","permalink":"https://woonyzzang.github.com/tags/webpack/"},{"name":"fiddler","slug":"fiddler","permalink":"https://woonyzzang.github.com/tags/fiddler/"},{"name":"tip","slug":"tip","permalink":"https://woonyzzang.github.com/tags/tip/"},{"name":"es6","slug":"es6","permalink":"https://woonyzzang.github.com/tags/es6/"},{"name":"sublimeText","slug":"sublimeText","permalink":"https://woonyzzang.github.com/tags/sublimeText/"},{"name":"log","slug":"log","permalink":"https://woonyzzang.github.com/tags/log/"},{"name":"visualstudio","slug":"visualstudio","permalink":"https://woonyzzang.github.com/tags/visualstudio/"},{"name":"ionic v1","slug":"ionic-v1","permalink":"https://woonyzzang.github.com/tags/ionic-v1/"},{"name":"webstorm","slug":"webstorm","permalink":"https://woonyzzang.github.com/tags/webstorm/"},{"name":"openssl","slug":"openssl","permalink":"https://woonyzzang.github.com/tags/openssl/"},{"name":"ionic v2","slug":"ionic-v2","permalink":"https://woonyzzang.github.com/tags/ionic-v2/"},{"name":"angular v1","slug":"angular-v1","permalink":"https://woonyzzang.github.com/tags/angular-v1/"},{"name":"d3","slug":"d3","permalink":"https://woonyzzang.github.com/tags/d3/"},{"name":"loader","slug":"loader","permalink":"https://woonyzzang.github.com/tags/loader/"},{"name":"requirejs","slug":"requirejs","permalink":"https://woonyzzang.github.com/tags/requirejs/"},{"name":"backbone","slug":"backbone","permalink":"https://woonyzzang.github.com/tags/backbone/"},{"name":"apmsetup","slug":"apmsetup","permalink":"https://woonyzzang.github.com/tags/apmsetup/"},{"name":"markdown","slug":"markdown","permalink":"https://woonyzzang.github.com/tags/markdown/"}]}